---
description: The sample demonstrates how to use select() to monitor multiple file descriptors simultaneously — watching both stdin and a TCP listening socket without blocking on either.
---

# Monitoring file descriptors with select

The sample demonstrates how to use **select()** to monitor multiple file descriptors at the same time. The program watches two sources simultaneously: **stdin** (keyboard input) and a **TCP listening socket** (incoming connections). It reacts to whichever becomes ready first, and times out after 5 seconds of inactivity.

Note that the `fd_set` must be **rebuilt before every call** to `select()` because the kernel overwrites it to indicate which descriptors are ready.

```c
#include <iostream>
#include <cstring>
#include <cerrno>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <sys/select.h>

#define PORT        9001
#define BACKLOG     5
#define BUFFER_SIZE 256
#define TIMEOUT_SEC 5

int main() {

    // create the TCP listening socket
    int serverFd = socket(AF_INET, SOCK_STREAM, 0);
    if (serverFd == -1) {
        std::cerr << "Socket failed: " << strerror(errno) << std::endl;
        return errno;
    }

    int opt = 1;
    int reuseResult = setsockopt(serverFd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));
    if (reuseResult == -1) {
        std::cerr << "Setsockopt failed: " << strerror(errno) << std::endl;
        close(serverFd);
        return errno;
    }

    struct sockaddr_in serverAddr;
    memset(&serverAddr, 0, sizeof(serverAddr));
    serverAddr.sin_family      = AF_INET;
    serverAddr.sin_addr.s_addr = INADDR_ANY;
    serverAddr.sin_port        = htons(PORT);

    int bindResult = bind(serverFd, (struct sockaddr*) &serverAddr, sizeof(serverAddr));
    if (bindResult == -1) {
        std::cerr << "Bind failed: " << strerror(errno) << std::endl;
        close(serverFd);
        return errno;
    }

    int listenResult = listen(serverFd, BACKLOG);
    if (listenResult == -1) {
        std::cerr << "Listen failed: " << strerror(errno) << std::endl;
        close(serverFd);
        return errno;
    }

    std::cout << "[select] Watching stdin and TCP port " << PORT << std::endl;
    std::cout << "[select] Type something and press Enter, or connect a client." << std::endl;

    while (true) {

        // the fd_set must be rebuilt on every iteration because select() modifies
        // it in place — after the call it only contains the ready descriptors
        fd_set readFds;
        FD_ZERO(&readFds);

        // watch stdin (fd 0) for keyboard input
        FD_SET(STDIN_FILENO, &readFds);

        // watch the server socket for incoming client connections
        FD_SET(serverFd, &readFds);

        // nfds must be the highest descriptor number + 1
        int nfds = serverFd + 1;

        // set a timeout so the loop does not block forever
        struct timeval timeout;
        timeout.tv_sec  = TIMEOUT_SEC;
        timeout.tv_usec = 0;

        // block until at least one descriptor is ready, or the timeout expires
        int ready = select(nfds, &readFds, NULL, NULL, &timeout);
        if (ready == -1) {
            std::cerr << "Select failed: " << strerror(errno) << std::endl;
            break;
        }

        if (ready == 0) {
            // neither descriptor became ready before the timeout
            std::cout << "[select] Timeout — nothing happened for " << TIMEOUT_SEC << " seconds" << std::endl;
            continue;
        }

        // check if stdin has data available
        if (FD_ISSET(STDIN_FILENO, &readFds)) {
            char buffer[BUFFER_SIZE];
            memset(buffer, 0, sizeof(buffer));
            ssize_t n = read(STDIN_FILENO, buffer, sizeof(buffer) - 1);
            if (n <= 0) {
                std::cout << "[select] stdin closed, exiting." << std::endl;
                break;
            }
            std::cout << "[select] stdin input: " << buffer;
        }

        // check if the server socket has a pending connection
        if (FD_ISSET(serverFd, &readFds)) {
            struct sockaddr_in clientAddr;
            socklen_t clientLen = sizeof(clientAddr);
            int clientFd = accept(serverFd, (struct sockaddr*) &clientAddr, &clientLen);
            if (clientFd == -1) {
                std::cerr << "Accept failed: " << strerror(errno) << std::endl;
                continue;
            }

            char clientIp[INET_ADDRSTRLEN];
            inet_ntop(AF_INET, &clientAddr.sin_addr, clientIp, sizeof(clientIp));
            std::cout << "[select] New connection from "
                      << clientIp << ":" << ntohs(clientAddr.sin_port) << std::endl;

            // close the client immediately — this sample only demonstrates readiness detection
            close(clientFd);
        }
    }

    close(serverFd);

    return 0;
}
```

The file can be compiled and executed as follows:
```sh
g++ select-fds.cpp -o select-fds
./select-fds
```

With no activity the program prints a timeout message every 5 seconds. Typing into the terminal or connecting with `nc` triggers the corresponding handler:
```
[select] Watching stdin and TCP port 9001
[select] Type something and press Enter, or connect a client.
[select] Timeout — nothing happened for 5 seconds
[select] stdin input: hello
[select] New connection from 127.0.0.1:54210
[select] Timeout — nothing happened for 5 seconds
```
