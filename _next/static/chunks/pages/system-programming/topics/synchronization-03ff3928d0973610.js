(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[2657],{4212:function(n,e,i){(window.__NEXT_P=window.__NEXT_P||[]).push(["/system-programming/topics/synchronization",function(){return i(4935)}])},4935:function(n,e,i){"use strict";i.r(e),i.d(e,{useTOC:function(){return l}});var s=i(2676),r=i(7250),t=i(9013),a=i(8583);function l(n){return[{value:"Overview",id:"overview",depth:2},{value:"Key Concepts",id:"key-concepts",depth:2},{value:"Concurrency and Race Conditions",id:"concurrency-and-race-conditions",depth:4},{value:"Synchronization Primitives",id:"synchronization-primitives",depth:4},{value:"Deadlocks and Starvation (Intro)",id:"deadlocks-and-starvation-intro",depth:4},{value:"Practice",id:"practice",depth:2},{value:"Demonstrating Race Conditions",id:"demonstrating-race-conditions",depth:4},{value:"Working with Mutexes",id:"working-with-mutexes",depth:4},{value:"Using Semaphores",id:"using-semaphores",depth:4},{value:"Condition Variables",id:"condition-variables",depth:4},{value:"Spinlocks and Atomics",id:"spinlocks-and-atomics",depth:4},{value:"Homework",id:"homework",depth:3},{value:"References",id:"references",depth:2},{value:"Quiz (Self-Check)",id:"quiz-self-check",depth:2}]}e.default=(0,r.c)(function(n){let{toc:e=l(n)}=n,i={a:"a",br:"br",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",hr:"hr",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,a.a)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(i.h1,{children:"Synchronization and Critical Sections"}),"\n",(0,s.jsx)(i.h2,{id:e[0].id,children:e[0].value}),"\n",(0,s.jsxs)(i.p,{children:["This week explores one of the most important challenges in multithreaded programming — ",(0,s.jsx)(i.strong,{children:"synchronization"}),".",(0,s.jsx)(i.br,{}),"\n","Students will understand how ",(0,s.jsx)(i.strong,{children:"race conditions"})," arise when multiple threads access shared data concurrently, and how to control access to critical sections using ",(0,s.jsx)(i.strong,{children:"synchronization primitives"})," such as mutexes, spinlocks, semaphores, condition variables, and atomic operations."]}),"\n",(0,s.jsx)(i.hr,{}),"\n",(0,s.jsx)(i.h2,{id:e[1].id,children:e[1].value}),"\n",(0,s.jsx)(i.h4,{id:e[2].id,children:e[2].value}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Race condition:"})," when multiple threads access and modify shared data simultaneously, leading to unpredictable results."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Critical section:"})," a segment of code that must not be executed by more than one thread at a time."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Data consistency:"})," maintaining integrity of shared resources under concurrent access."]}),"\n"]}),"\n",(0,s.jsx)(i.h4,{id:e[3].id,children:e[3].value}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.strong,{children:"Mutex (Mutual Exclusion Lock):"})}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Ensures only one thread executes a critical section at a time."}),"\n",(0,s.jsxs)(i.li,{children:["Core functions: ",(0,s.jsx)(i.code,{children:"pthread_mutex_init"}),", ",(0,s.jsx)(i.code,{children:"pthread_mutex_lock"}),", ",(0,s.jsx)(i.code,{children:"pthread_mutex_unlock"}),", ",(0,s.jsx)(i.code,{children:"pthread_mutex_destroy"}),"."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.strong,{children:"Spinlock:"})}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Lightweight lock that continuously checks availability without sleeping."}),"\n",(0,s.jsx)(i.li,{children:"Suitable for short critical sections on multicore systems."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.strong,{children:"Semaphore:"})}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"A counter-based synchronization mechanism for controlling access to a finite number of resources."}),"\n",(0,s.jsxs)(i.li,{children:["POSIX functions: ",(0,s.jsx)(i.code,{children:"sem_init"}),", ",(0,s.jsx)(i.code,{children:"sem_wait"}),", ",(0,s.jsx)(i.code,{children:"sem_post"}),", ",(0,s.jsx)(i.code,{children:"sem_destroy"}),"."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.strong,{children:"Condition Variable:"})}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Used for signaling between threads."}),"\n",(0,s.jsx)(i.li,{children:"Allows a thread to wait until a certain condition becomes true."}),"\n",(0,s.jsxs)(i.li,{children:["Core functions: ",(0,s.jsx)(i.code,{children:"pthread_cond_wait"}),", ",(0,s.jsx)(i.code,{children:"pthread_cond_signal"}),", ",(0,s.jsx)(i.code,{children:"pthread_cond_broadcast"}),"."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.strong,{children:"Atomic Operations and CAS (Compare-And-Swap):"})}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Low-level operations ensuring atomic updates without explicit locks."}),"\n",(0,s.jsx)(i.li,{children:"Foundation for lock-free synchronization structures."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(i.h4,{id:e[4].id,children:e[4].value}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Circular wait, hold and wait, no preemption, mutual exclusion — the four conditions for deadlock."}),"\n",(0,s.jsx)(i.li,{children:"Techniques to avoid or detect deadlocks will be discussed in future weeks."}),"\n"]}),"\n",(0,s.jsx)(i.hr,{}),"\n",(0,s.jsx)(i.h2,{id:e[5].id,children:e[5].value}),"\n",(0,s.jsx)(i.h4,{id:e[6].id,children:e[6].value}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Create a shared counter updated by multiple threads without locks — observe inconsistent results."}),"\n",(0,s.jsx)(i.li,{children:"Protect the counter using a mutex and verify correct output."}),"\n"]}),"\n",(0,s.jsx)(i.h4,{id:e[7].id,children:e[7].value}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Use a mutex to protect a critical section in a multi-threaded program."}),"\n",(0,s.jsxs)(i.li,{children:["Experiment with ",(0,s.jsx)(i.code,{children:"pthread_mutex_trylock"})," and ",(0,s.jsx)(i.code,{children:"PTHREAD_MUTEX_RECURSIVE"}),"."]}),"\n"]}),"\n",(0,s.jsx)(i.h4,{id:e[8].id,children:e[8].value}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Implement a simple producer-consumer synchronization using semaphores."}),"\n"]}),"\n",(0,s.jsx)(i.h4,{id:e[9].id,children:e[9].value}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Demonstrate thread signaling (one thread waits until another signals a condition)."}),"\n",(0,s.jsx)(i.li,{children:"Compare busy-waiting vs. condition-based waiting."}),"\n"]}),"\n",(0,s.jsx)(i.h4,{id:e[10].id,children:e[10].value}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Experiment with short critical sections using spinlocks."}),"\n",(0,s.jsx)(i.li,{children:"Observe CPU utilization differences compared to mutexes."}),"\n"]}),"\n",(0,s.jsx)(i.hr,{}),"\n",(0,s.jsx)(i.h3,{id:e[11].id,children:e[11].value}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.a,{href:"/system-programming/tasks/threads/thread-pool/",children:"TH-2: The thread pool implementation"})}),"\n"]}),"\n",(0,s.jsx)(i.hr,{}),"\n",(0,s.jsx)(i.h2,{id:e[12].id,children:e[12].value}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.strong,{children:"Required"})}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.a,{href:"https://www.youtube.com/watch?v=oehU_Jie3lI",children:"ECE 252 Lecture 12: Concurrency: Synchronization & Atomicity"})}),"\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.a,{href:"https://www.youtube.com/watch?v=TF9q76lEwKI",children:"ECE 252 Lecture 13: Semaphores"})}),"\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.a,{href:"https://www.youtube.com/watch?v=ru4Q55Jlf-Y",children:"ECE 252 Lecture 14: Synchronization Patterns"})}),"\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.a,{href:"https://www.lektorium.tv/lecture/13560",children:"Параллельное программирование. Лекция 2 Лекция"})}),"\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.a,{href:"https://www.geeksforgeeks.org/mutex-vs-semaphore/",children:"Mutex vs Semaphore"})}),"\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.a,{href:"https://www.youtube.com/watch?v=AN6XHy2znzc",children:"Spinlocks - Part 1 - A Basic Spinlock "})}),"\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Compare-and-swap",children:"Compare-and-swap"})}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.em,{children:"Advanced Programming in the UNIX Environment"})," — W. Richard Stevens, Chapter 12 “Thread Synchronization”"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.em,{children:"Programming with POSIX Threads"})," — David R. Butenhof, Chapters 4–6"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.em,{children:"Operating Systems: Three Easy Pieces"})," — Chapters “Concurrency,” “Locks,” and “Condition Variables”"]}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.strong,{children:"Recommended"})}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.a,{href:"https://www.youtube.com/watch?v=mB_CNguuiew",children:"ECE 252 Lecture 16: The Readers-Writers Problem"})}),"\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.a,{href:"https://www.youtube.com/watch?v=y1iDjVuGPSk",children:"ECE 252 Lecture 17: Deadlock"})}),"\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.a,{href:"https://www.youtube.com/watch?v=QU8PK97SeQE",children:"ECE 252 Lecture 18: Deadlock Avoidance"})}),"\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.a,{href:"https://www.youtube.com/watch?v=vZPLbMFXOHU",children:"ECE 252 Lecture 19: Deadlock Detection and Recovery"})}),"\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.a,{href:"https://www.geeksforgeeks.org/mutex-lock-for-linux-thread-synchronization/",children:"Mutex lock for Linux Thread Synchronization"})}),"\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.a,{href:"https://packt.medium.com/how-to-use-semaphores-in-posix-concurrency-control-144c34549807",children:"How to use Semaphores in POSIX Concurrency Control"})}),"\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.a,{href:"https://man7.org/linux/man-pages/man3/pthread_mutex_init.3p.html",children:"Linux manual page - pthread_mutex_init(3p)"})}),"\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.a,{href:"https://man7.org/linux/man-pages/man3/pthread_mutex_destroy.3p.html",children:"Linux manual page - pthread_mutex_destroy(3p)"})}),"\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.a,{href:"https://man7.org/linux/man-pages/man3/pthread_mutex_lock.3p.html",children:"Linux manual page - pthread_mutex_lock(3p)"})}),"\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.a,{href:"https://man7.org/linux/man-pages/man3/pthread_mutex_unlock.3p.html",children:"Linux manual page - pthread_mutex_unlock(3p)"})}),"\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.a,{href:"https://man7.org/linux/man-pages/man3/pthread_spin_lock.3.html",children:"Linux manual page - spin_lock(3)"})}),"\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.a,{href:"https://man7.org/linux/man-pages/man3/pthread_spin_unlock.3.html",children:"Linux manual page - spin_unlock(3)"})}),"\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.a,{href:"https://man7.org/linux/man-pages/man3/sem_init.3.html",children:"Linux manual page - sem_init(3)"})}),"\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.a,{href:"https://man7.org/linux/man-pages/man3/sem_destroy.3.html",children:"Linux manual page - sem_destroy(3p)"})}),"\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.a,{href:"https://man7.org/linux/man-pages/man3/sem_wait.3.html",children:"Linux manual page - sem_wait(3)"})}),"\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.a,{href:"https://man7.org/linux/man-pages/man3/sem_post.3.html",children:"Linux manual page - sem_post(3)"})}),"\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.a,{href:"https://man7.org/linux/man-pages/man3/pthread_cond_wait.3p.html",children:"Linux manual page - pthread_cond_wait(3)"})}),"\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.a,{href:"https://man7.org/linux/man-pages/man3/pthread_cond_signal.3p.html",children:"Linux manual page - pthread_cond_signal(3)"})}),"\n"]}),"\n",(0,s.jsx)(i.hr,{}),"\n",(0,s.jsx)(i.h2,{id:e[13].id,children:e[13].value}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsx)(i.li,{children:"What causes a race condition?"}),"\n",(0,s.jsx)(i.li,{children:"What is the difference between a mutex and a spinlock?"}),"\n",(0,s.jsx)(i.li,{children:"How does a semaphore differ from a mutex?"}),"\n",(0,s.jsx)(i.li,{children:"What are the typical use cases for condition variables?"}),"\n",(0,s.jsx)(i.li,{children:"What does “atomic operation” mean?"}),"\n",(0,s.jsx)(i.li,{children:"Name the four necessary conditions for a deadlock."}),"\n",(0,s.jsx)(i.li,{children:"Why is it important to minimize the time spent inside a critical section?"}),"\n"]})]})},"/system-programming/topics/synchronization",{filePath:"pages/system-programming/topics/synchronization.mdx",timestamp:1761486238e3,pageMap:t.v,frontMatter:{description:"Understanding synchronization problems in concurrent programming. Introduction to race conditions, critical sections, and main synchronization primitives in POSIX systems."},title:"Synchronization and Critical Sections"},"undefined"==typeof RemoteContent?l:RemoteContent.useTOC)}},function(n){n.O(0,[8977,2888,9774,179],function(){return n(n.s=4212)}),_N_E=n.O()}]);