(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[9780],{3021:function(e,n,s){(window.__NEXT_P=window.__NEXT_P||[]).push(["/system-programming/topics/classical-sync-problems",function(){return s(4160)}])},4160:function(e,n,s){"use strict";s.r(n),s.d(n,{useTOC:function(){return a}});var r=s(2676),i=s(6321),o=s(3383),l=s(2565);function a(e){return[{value:"Overview",id:"overview",depth:2},{value:"Key Concepts",id:"key-concepts",depth:2},{value:"Producer–Consumer (Bounded Buffer)",id:"producerconsumer-bounded-buffer",depth:4},{value:"Readers–Writers Problem",id:"readerswriters-problem",depth:4},{value:"Dining Philosophers Problem",id:"dining-philosophers-problem",depth:4},{value:"Sleeping Barber Problem",id:"sleeping-barber-problem",depth:4},{value:"Samples",id:"samples",depth:3},{value:"References",id:"references",depth:2},{value:"Quiz (Self-Check)",id:"quiz-self-check",depth:2}]}n.default=(0,i.c)(function(e){let{toc:n=a(e)}=e,s={a:"a",br:"br",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",hr:"hr",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,l.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(s.h1,{children:"Classical Synchronization Problems"}),"\n",(0,r.jsx)(s.h2,{id:n[0].id,children:n[0].value}),"\n",(0,r.jsxs)(s.p,{children:["This week focuses on ",(0,r.jsx)(s.strong,{children:"applying synchronization primitives"})," to solve classical concurrency problems that appear in operating systems, parallel systems, and real-world software design.",(0,r.jsx)(s.br,{}),"\n","Through hands-on examples, students will learn how mutexes, semaphores, and condition variables can coordinate multiple threads or processes to prevent race conditions and ensure correct execution order."]}),"\n",(0,r.jsx)(s.hr,{}),"\n",(0,r.jsx)(s.h2,{id:n[1].id,children:n[1].value}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Purpose of Classical Problems"})}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"Serve as canonical models for understanding synchronization mechanisms."}),"\n",(0,r.jsx)(s.li,{children:"Help develop reasoning about shared resources, fairness, and avoidance of deadlock or starvation."}),"\n"]}),"\n",(0,r.jsx)(s.h4,{id:n[2].id,children:n[2].value}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Scenario:"})," Producers generate data and place it in a buffer; consumers remove and process it."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Challenge:"})," Prevent buffer overflow (too many producers) and underflow (too many consumers)."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Solution:"})," Use semaphores or condition variables to control buffer state."]}),"\n",(0,r.jsxs)(s.li,{children:["Demonstrates: ",(0,r.jsx)(s.strong,{children:"resource counting"}),", ",(0,r.jsx)(s.strong,{children:"mutual exclusion"}),", ",(0,r.jsx)(s.strong,{children:"condition signaling"}),"."]}),"\n"]}),"\n",(0,r.jsx)(s.h4,{id:n[3].id,children:n[3].value}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Scenario:"})," Multiple readers can access shared data simultaneously, but writers require exclusive access."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Challenge:"})," Avoid conflicts between readers and writers."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Solution:"})," Use reader/writer counters, semaphores, or RW locks."]}),"\n",(0,r.jsxs)(s.li,{children:["Demonstrates: ",(0,r.jsx)(s.strong,{children:"fairness"}),", ",(0,r.jsx)(s.strong,{children:"reader/writer preference"}),", ",(0,r.jsx)(s.strong,{children:"starvation prevention"}),"."]}),"\n"]}),"\n",(0,r.jsx)(s.h4,{id:n[4].id,children:n[4].value}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Scenario:"})," Philosophers seated around a table alternate between thinking and eating, each needing two forks."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Challenge:"})," Prevent deadlock (everyone waiting) and starvation (someone never eating)."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Solution:"})," Control fork acquisition order or use semaphores for resource allocation."]}),"\n",(0,r.jsxs)(s.li,{children:["Demonstrates: ",(0,r.jsx)(s.strong,{children:"deadlock prevention"}),", ",(0,r.jsx)(s.strong,{children:"resource hierarchy"}),", ",(0,r.jsx)(s.strong,{children:"symmetry breaking"}),"."]}),"\n"]}),"\n",(0,r.jsx)(s.h4,{id:n[5].id,children:n[5].value}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Scenario:"})," A barber sleeps when no customers are waiting; customers wait if the barber is busy."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Challenge:"})," Synchronize waiting customers and barber’s state transitions."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Solution:"})," Semaphores for managing waiting chairs and signaling events."]}),"\n",(0,r.jsxs)(s.li,{children:["Demonstrates: ",(0,r.jsx)(s.strong,{children:"event signaling"}),", ",(0,r.jsx)(s.strong,{children:"resource utilization"}),", ",(0,r.jsx)(s.strong,{children:"thread coordination"}),"."]}),"\n"]}),"\n",(0,r.jsx)(s.hr,{}),"\n",(0,r.jsx)(s.h3,{id:n[6].id,children:n[6].value}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:(0,r.jsx)(s.a,{href:"/system-programming/samples/bounded-buffer/",children:"Bounded Buffer (Producer and Consumer)"})}),"\n",(0,r.jsx)(s.li,{children:(0,r.jsx)(s.a,{href:"/system-programming/samples/dining-philosophers/",children:"Dining Philosophers"})}),"\n"]}),"\n",(0,r.jsx)(s.hr,{}),"\n",(0,r.jsx)(s.h2,{id:n[7].id,children:n[7].value}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.em,{children:"Operating Systems: Three Easy Pieces"})," — Chapters “Synchronization Examples” and “Semaphores”"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.em,{children:"Modern Operating Systems"})," — Andrew S. Tanenbaum, Chapter on “Processes and Threads”"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.em,{children:"Programming with POSIX Threads"})," — David R. Butenhof, examples on coordination"]}),"\n",(0,r.jsx)(s.li,{children:(0,r.jsx)(s.a,{href:"https://man7.org/linux/man-pages/man7/pthreads.7.html",children:"pthreads(7)"})}),"\n",(0,r.jsx)(s.li,{children:(0,r.jsx)(s.a,{href:"https://man7.org/linux/man-pages/man7/sem_overview.7.html",children:"sem_overview(7)"})}),"\n",(0,r.jsx)(s.li,{children:(0,r.jsx)(s.a,{href:"https://en.wikipedia.org/wiki/Readers%E2%80%93writers_problem",children:"Synchronization problems overview (Wikipedia)"})}),"\n"]}),"\n",(0,r.jsx)(s.hr,{}),"\n",(0,r.jsx)(s.h2,{id:n[8].id,children:n[8].value}),"\n",(0,r.jsxs)(s.ol,{children:["\n",(0,r.jsx)(s.li,{children:"What causes deadlock in the Dining Philosophers problem?"}),"\n",(0,r.jsx)(s.li,{children:"How can starvation occur in the Readers–Writers problem?"}),"\n",(0,r.jsx)(s.li,{children:"Which synchronization primitives can be used to solve the Producer–Consumer problem?"}),"\n",(0,r.jsx)(s.li,{children:"In the Sleeping Barber problem, what does each semaphore represent?"}),"\n",(0,r.jsx)(s.li,{children:"Why is fairness important in synchronization design?"}),"\n",(0,r.jsx)(s.li,{children:"How does symmetry breaking help in preventing deadlocks?"}),"\n"]})]})},"/system-programming/topics/classical-sync-problems",{filePath:"pages/system-programming/topics/classical-sync-problems.mdx",timestamp:1762526931e3,pageMap:o.v,frontMatter:{description:"Exploration of classical synchronization problems including Producer–Consumer, Readers–Writers, Dining Philosophers, and others, applying mutexes, semaphores, and condition variables."},title:"Classical Synchronization Problems"},"undefined"==typeof RemoteContent?a:RemoteContent.useTOC)}},function(e){e.O(0,[8374,2888,9774,179],function(){return e(e.s=3021)}),_N_E=e.O()}]);