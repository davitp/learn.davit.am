{"/":{"title":"Home","data":{}},"/linux-programming/guides":{"title":"Guides","data":{}},"/linux-programming/guides/compilation":{"title":"Compilation and build process","data":{"":"The set of samples showcases different aspects of the compilation process in the Linux environment using various tools such as gcc, make, cmake, etc.","single-file-compilation#Single file compilation":"Consider main.cpp as a source file containing the whole logic of the application:\nTo compile the source code into an executable file execute the following line in the source directory:\nwhere parameter -o app defines the name of the output file (a.out by default).If the command completes successfully, the source directory will contain a file called app that is ready to execute as follows:","pre-processing-a-c-source-file#Pre-processing a C++ source file":"You may want to stop the compiler after the pre-processing phase when all the directives such as include, define, etc. are resolved.\nIn that case you will need to run the pass the -E flag to the compiler as follows:\nThe result of the command prints the result on a console by default, hence we redirected the content to be written to file \"preprocessed-main.cpp\" by using redirection operator (>) of shell.","translation-of-the-source#Translation of the source":"You may also want to stop the compiler after the translation phase to get the low-level code in assembler language. For that you need to pass -S flag to the compiler. It will generate a new file with .s extension by default:\nAfter the command is completed successfully you will get a main.s file containing your source in assembler language. The file will contain something like this:","assembling-the-compiled-file#Assembling the compiled file":"Most commonly, you will need to compile your source file to a binary object file containing your source code in a binary format, but not ready to execute. Object files are generated by passing -c to the compiler. By default a file with \".o\" extension will be generated:\nAfter this command, a file named main.o will be generated.","linking-object-files#Linking object files":"In most of the cases, you will have many source files compiled into object files separately and after all object files are ready you will link those together and add necessary libraries. For example, if you have files main.o, module1.o and module2.o you will need to link those together into an executable file (or a library):\nAfter this command, a file named \"a.out\" will be generated and will be ready to run.Also, you may want to see the libraries your executable is linked to using the following command:\nIn this basic example, your executable will be linked with the standard libraries as follows:"}},"/linux-programming":{"title":"Getting started","data":{}},"/linux-programming/samples":{"title":"Samples","data":{}},"/linux-programming/samples/copy-file":{"title":"Copy the given file","data":{"":"This sample demonstrates how to implement a basic copy program using read and write functions.\nThe file can be compiled with the following command:\nRunning the resulting application ./copy source-file.txt new-file.txt duplicate source-file.txt with name new-file.txt."}},"/linux-programming/samples/create-process":{"title":"Creating a process","data":{"":"The sample demonstrates how to create a process using fork() function.\nThe file can be compiled and executed as follows:\nThe program is supposed to start a process and clone itself printing appropriate messages as follows:"}},"/linux-programming/samples/create-thread":{"title":"Creating a thread","data":{"":"The sample demonstrates how to create a thread using pthread_create() function and wait for its completion.\nThe file can be compiled and executed as follows:\nThe program is supposed to print + and - signs without any particular order as follows:"}},"/linux-programming/samples/detect-holes":{"title":"Detect holes in the file","data":{"":"The sample demonstrates how to detect data and hole segments in the given file.\nThe file can be compiled and executed as follows:\nThe program is supposed to print start and end indexes of all the data and hole segments if any."}},"/linux-programming/samples/make-hole":{"title":"Create a file with holes","data":{"":"This sample demonstrates the ability to create a sparse file containing both data segments and holes using lseek function.\nThe program is expected to accept the target file name as a first argument and sequence of sizes for created data and hole segments in the file.\nThe file can be compiled and executed as follows:\nAfter successful completion of the program, we will have file \"file_with_holes\" created containing 2 data segments of size 4096 and 2 holes of size 4096."}},"/linux-programming/samples/makefile":{"title":"Compiling multiple files using Makefile","data":{"":"In this sample, we will compile a program having two modules with Makefile.The program will contain two modules:\nmain.cpp - the main logic of the application\nmessage.cpp - a module that can simply print messages\nLet's assume the main.cpp contains the following logic:\nThe file message.h contains only a declaration of the used function:\nThen the module message.cpp should implement the mentioned function as follows:\nWe can manually compile the modules one by one as follows:\nThen, having two modules main.o and message.o we can build the final executable by linking those together:\nTo automate the process we could also write a Makefile as follows:\nNow, invoking make command will create all the necessary files for the program.You may also want to clean the build output with a special clean target as follows:"}},"/linux-programming/samples/open-file":{"title":"Opening a file","data":{"":"This sample demonstrates the usage of functions open and close.\nThe file can be compiled with the following command:\nRunning the resulting application ./open should create a file named foo.txt and print the following result:"}},"/linux-programming/samples/read-file":{"title":"Reading file contents","data":{"":"This sample demonstrates how to read a text file using read() function.\nThe file can be compiled with the following command:\nRunning the resulting application ./read some-file.txt will print the contents of the given file to the console."}},"/linux-programming/samples/redirect-output":{"title":"Redirect standard output and error","data":{"":"This sample demonstrates how to redirect standard output and standard error into a file (using dup/dup2) while keeping possibility to write to the console when needed.\nThe file can be compiled with the following command:\nRunning the resulting application ./redirect is supposed to print \"Hello\" on the console screen and create a file output.log containing cout and cerr text."}},"/linux-programming/tasks":{"title":"Tasks","data":{}},"/linux-programming/tasks/environment":{"title":"Environment","data":{}},"/linux-programming/tasks/environment/complex-number":{"title":"ENV-2: Complex numbers and sorting","data":{"requirements#Requirements":"Write multi-file C++ program consisting of following 3 modules:\nA class that represents a complex number along with all the basic operations: plus, minus, multiply by a constant, absolute value.\nA function that implements any sorting algorithm on an array/vector of complex numbers.\nA main function containing a demonstration of having multiple complex numbers in array and sorting them.\nModules for complex number class and sorting algorithm should be separate and each of them should have source and header files.","expected-result#Expected result":"A solution containing all the described modules (source and header files), as well as, a Makefile for automated build of the solution.The final solution should contain a Makefile for the multi-stage build. The Makefile should also contain targets all and clean. It's recommended to have compiler and compiler flags to be declared as a Makefile variables. Alternatively, cmake could also be used instead of make."}},"/linux-programming/tasks/environment/environment-setup":{"title":"ENV-1: Setup GNU/Linux Environment","data":{"requirements#Requirements":"Install any GNU/Linux distribution on a Virtual or Physical Machine.\nRun lsb_release -a >> $USER.txt command (if available) in a shell and get the result.\nRun cat /etc/os-release >> $USER.txt command (if available) in a shell and get the result.\nSubmit $USER.txt file to the Github as a solution for the task.","expected-output#Expected output":"The expected output is a text file named $USER.txt where $USER is the current user's username. The content is expected to be similar to the following:"}},"/linux-programming/tasks/file-systems":{"title":"File Systems","data":{}},"/linux-programming/tasks/file-systems/copy-file":{"title":"FS-2: Copy a file","data":{"requirements#Requirements":"Write a C++ program simple-copy accepting two command line arguments representing source file path and destination file path.\nImplement proper error handling to account if not all arguments are passed or if one of arguments is not a valid one.\nCopy the content of the source file into a destination file. If destination file already exists, it should be overwritten.","expected-result#Expected result":"The resulting application should be able to build and execute from command line as follows:\nThe final solution should contain a Makefile for the multi-stage build. The Makefile should also contain targets all and clean. It's recommended to have compiler and compiler flags to be declared as a Makefile variables. Alternatively, cmake could also be used instead of make."}},"/linux-programming/tasks/file-systems/copy-with-holes":{"title":"FS-10: Copy a file accounting holes","data":{"requirements#Requirements":"Write a C++ program accepting two command line arguments representing source file path and destination file path.\nImplement proper error handling to account if not all arguments are passed or if one of arguments is not a valid one.\nCopy the content of the source file into a destination file. If destination file already exists, it should be overwritten.\nIf source file contains holes, the destination file should also contain hole as is.\nPrint overall amount of bytes copied to the destination file including total amount of physical data and total amount of holes if any.","expected-result#Expected result":"The resulting application should be able to build and execute from command line as follows:\nAfter copy is completed, program should print following message to the console:\nThe logical and physical sizes of source and destination files should match exactly.The final solution should contain a Makefile for the multi-stage build. The Makefile should also contain targets all and clean. It's recommended to have compiler and compiler flags to be declared as a Makefile variables. Alternatively, cmake could also be used instead of make."}},"/linux-programming/tasks/file-systems/manual-append":{"title":"FS-5: Manaul append","data":{"description#Description":"Your task is to write a program on C/C++ that writes two lines in the files \"first line\" and \"second line\".\nWriting should happen into two different file descriptors but write into the same file.","requirements#Requirements":"Write a C/C++ program that gets the filepath with the first argument and opens it.\nFile should not be opened with the O_APPEND file.\nYou are not allowed to use seek/lseek to move the cursor to the end.\nThe program writes two lines: \"first line\" and \"second line\". Each line is written in a different descriptor.\nAfter write, the file should contain both lines in the same file.\nHint: you may use dup/dup2.","expected-result#Expected result":"The resulting application should be able to build and execute from command line as follows:\nThe output file should contain the following text:\nThe final solution should contain a Makefile for the multi-stage build. The Makefile should also contain targets all and clean. It's recommended to have compiler and compiler flags to be declared as a Makefile variables. Alternatively, cmake could also be used instead of make."}},"/linux-programming/tasks/file-systems/read-file":{"title":"FS-1: Read from the file","data":{"description#Description":"You need to implement a program that does the same thing as the cat command in the Linux.","requirements#Requirements":"Write a C++ program read-file accepting a file path as an argument.\nImplement proper error handling to make sure required file path is passed.\nOpen the given file with proper mode and make sure errors are handled.\nRead the content of the file into a buffer until reaching the end of the file.\nPrint every portion of the file read in the iteration.\nHint: if you use printf or std::cin, make sure your strings are terminated with '\\0' symbol.","expected-result#Expected result":"The resulting application should be able to build and execute from command line as follows:\nThe program should output the content of the input.txt file on the screen.The final solution should contain a Makefile for the multi-stage build. The Makefile should also contain targets all and clean. It's recommended to have compiler and compiler flags to be declared as a Makefile variables. Alternatively, cmake could also be used instead of make."}},"/linux-programming/tasks/file-systems/redirect-cin":{"title":"FS-4: Redirect standard input","data":{"description#Description":"By default, program gets standard input waiting for the keyboard input. Your task is to make any program to read input from the file instead of waiting for the keyboard input without changing usages of std::cin or scanf.","requirements#Requirements":"Write a C++ program named \"redirect-cin\" that accepts a path to a file as a command-line argument.\nImplement the function initialize(int argc, char** argv) to start reading from the given file with a proper error handling.\nImplement a simple logic for main() function to read string from the standard input (std::cin) and print the reversed string to the cosnsole (std::out).\nIf there is an error with given file, the program should terminate with the proper error code.\nThe program's main source file should look like:\nHint: you can use one of dup() functions.","expected-result#Expected result":"The resulting application should be able to build and execute from command line as follows:\nAnd, assuming input file contains the text \"123456789\", the program should output the following:\nThe final solution should contain a Makefile for the multi-stage build. The Makefile should also contain targets all and clean. It's recommended to have compiler and compiler flags to be declared as a Makefile variables. Alternatively, cmake could also be used instead of make."}},"/linux-programming/tasks/file-systems/secure-file-deletion":{"title":"FS-3: Secure file deletion","data":{"description#Description":"Your task is to implement a C++ program that deletes the file from the filesystem along with its content by replacing every byte in the files with '\\0' character.","requirements#Requirements":"Write a C++ program named \"hacker-rm\" that accepts a path to a file as a command-line argument.\nImplement proper error handling to check if the file exists and if the input path is valid.\nOpen the file for writing and replace every byte with the null character ('\\0').\nRemove the file from the file system after overwriting its content.\nEnsure that your program works for various file sizes and types.\nHint: you can use write, stat, lseek, unlink function to solve the problem.","expected-result#Expected result":"The resulting application should be able to build and execute from command line as follows:\nThe final solution should contain a Makefile for the multi-stage build. The Makefile should also contain targets all and clean. It's recommended to have compiler and compiler flags to be declared as a Makefile variables. Alternatively, cmake could also be used instead of make."}},"/linux-programming/tasks/ipc":{"title":"IPC","data":{}},"/linux-programming/tasks/ipc/prime-calculator":{"title":"IPC-2: Prime calculator","data":{"requirements#Requirements":"Write a C++ program that creates a child process.\nThe main process infinitely waits for the user's input integer m.\nOnce number m is received by the main process, it gets passed to the child process via anonymous pipe.\nThe child process takes m from the anonymous pipe and calculates the m-th prime number.\nThe child process should send the result of the calculation back to the parent process, which, should print it and wait for the next input.\nIf the \"exit\" command is entered, the main process should stop its execution.","expected-result#Expected result":"The resulting application should be able to build and execute from the command line as follows:\nThe typical execution of the program should look like the following:\nThe final solution should contain a Makefile for the multi-stage build. The Makefile should also contain targets all and clean. It's recommended to have compiler and compiler flags declared as Makefile variables. Alternatively, cmake could also be used instead of make."}},"/linux-programming/tasks/ipc/shared-array":{"title":"IPC-3: Shared array implementation","data":{"requirements#Requirements":"Write a C++ class implementing a module shared_array which is an array of integers shared between processes.\nThe class is supposed to be initialized as follows: shared_array array(\"array-name\", size);\nThe size of the array (number of elements) could be between 1 and 1 000 000 000\nTwo shared arrays are the same in the system if they have equal names and sizes, otherwise, they are different.\nThe class should provide operator [] for indexing an element with a given index i.\nAny process that knows the name and the size of the array should be able to use it.\nWrite two infinite programs (first and second) to work with the shared array using cross-process semaphore.","expected-result#Expected result":"The resulting application should be able to build from the command line as follows:\nThe execution of the program should demonstrate how the array changes from the first and second processes.The final solution should contain a Makefile for the multi-stage build. The Makefile should also contain targets all and clean. It's recommended to have compiler and compiler flags declared as Makefile variables. Alternatively, cmake could also be used instead of make."}},"/linux-programming/tasks/ipc/signal-echo":{"title":"IPC-1: Signal echo","data":{"requirements#Requirements":"Write a C++ program that prints its PID and registers a signal handler for SIGUSR1.\nThe handler of the signal SIGUSR1 is suppose to react by printing the following information:\nThe PID of the sender process,\nThe UID and the user name of the sender,\nThe current values of the EIP, EAX, EBX registers.\nProgram should enter an infinite loop and perform a sleeping delay on each iteration (example: sleep for 10 seconds).","expected-result#Expected result":"The resulting application should be able to build and execute from command line as follows:\nThen, once any other process sends SIGUSR1 signal to our process, it should print the following information:\nThe final solution should contain a Makefile for the multi-stage build. The Makefile should also contain targets all and clean. It's recommended to have compiler and compiler flags to be declared as a Makefile variables. Alternatively, cmake could also be used instead of make."}},"/linux-programming/tasks/processes":{"title":"Processes","data":{}},"/linux-programming/tasks/processes/do-command":{"title":"PS-1: Do command","data":{"description#Description":"Your task is to implement a C++ program that accepts a command name and command arguments with command-line arguments and executes it in a new process.","requirements#Requirements":"Write a C++ program called \"do-command\" that takes N arguments as an input.\nAssume that first argument is command name and others are arguments for the given command.\nA program should contain a special function do_command(char** argv), where argv is null-terminated vector of arguments.\nThe function \"do_command\" should create a new process, execute the given command with the given arguments and wait for its completion.\nAfter program execution is done, do_function should print exit status of the command and the duration of the command execution.\nThe \"main\" function of the program is responsible for building proper argument vector and using do_command function to execute the command.","expected-result#Expected result":"The resulting application should be able to build and execute from command line as follows:\nThe command is expected to print program output to the console and a line as follows:\nThe final solution should contain a Makefile for the multi-stage build. The Makefile should also contain targets all and clean. It's recommended to have compiler and compiler flags to be declared as a Makefile variables. Alternatively, cmake could also be used instead of make."}},"/linux-programming/tasks/processes/interactive-shell":{"title":"PS-2: Interactive shell","data":{"requirements#Requirements":"Write a C++ program that implements an interactive shell with an infinite loop waiting for a command.\nOn every iteration of the loop a command string is passed to the shell program.\nA command can be either a name of command or a path (relative or absolute).\nAfter command is entered, program should create a new process to run the command.\nThe current directory of the shell program should be temporarily added to the PATH variable of every new process.\nIf \"exit\" command is entered, shell program should stop and exit with a success code.\nIf entered command starts with word \"silent\", the executing command should redirect the standard output and error streams into the PID.log file where PID is the process id of the child process.","expected-result#Expected result":"The resulting application should be able to build and execute from command line as follows:\nUser may enter commands as follows:\nor\nor\nand the command should print the output to the console.Also user may want to enter commands as follows\nand the output of program ls should be redirected into the file PID.log where PID is the identifier of the child process.The final solution should contain a Makefile for the multi-stage build. The Makefile should also contain targets all and clean. It's recommended to have compiler and compiler flags to be declared as a Makefile variables. Alternatively, cmake could also be used instead of make."}},"/linux-programming/tasks/threads":{"title":"Threads","data":{}},"/linux-programming/tasks/threads/array-sum":{"title":"TH-1: The array summary","data":{"requirements#Requirements":"Write a C++ program creates an array of N elements (N > 1 000 000).\nInitialize the array with random values at the beginning.\nCompute summary of the array using a regular for loop and calculate the time spent for the operation.\nCreate M threads to sum the same array with multiple threads, considering that every thread gets an equal portion to sum, except, maybe, the last one.\nWait for all the threads to complete and measure the time spent for summing the array using M threads.\nPrint the durations spent to sum the array with and without threads.\nNote that N and M variables should be passed to the program via command line arguments.","expected-result#Expected result":"The resulting application should be able to build and execute from command line as follows:\nand the command should print the output to the console as follows:\nThe final solution should contain a Makefile for the multi-stage build. The Makefile should also contain targets all and clean. It's recommended to have compiler and compiler flags to be declared as a Makefile variables. Alternatively, cmake could also be used instead of make."}},"/linux-programming/tasks/threads/thread-pool":{"title":"TH-2: The thread pool implementation","data":{"requirements#Requirements":"Create a C++ library (shared object) that implements a simple thread pool\nThread pool should be implemented as a class called \"parallel_scheduler\"\nThread pool takes a capacity argument in the constructor as a maximum number of threads in the pool.\nThread pool defines a method run that takes as an input two arguments function and the argument.\nAll the functions given to the \"run\" method are enqueued and the thread pool should execute them as soon as any of its threads gets time.\nNext, another executable application is implemented to demonstrate the usage of the thread pool library.\nThe demonstration application should enqueue various functions for the execution (more than the capacity).\nThe module \"parallel_scheduler\" should be compiled as a shared library (parallel_scheduler.so) and should be linked with the demo application.","expected-result#Expected result":"The resulting application should be able to build and execute from command line as follows:\nThe final solution should contain a Makefile for the multi-stage build. The Makefile should also contain targets all and clean. It's recommended to have compiler and compiler flags to be declared as a Makefile variables. Alternatively, cmake could also be used instead of make."}},"/linux-programming/topics":{"title":"Topics","data":{}},"/linux-programming/topics/advanced-input-output":{"title":"Advanced IO with File Systems API","data":{"overview#Overview":"Exploring more advanced functionalities provided by the File Systems API for file manipulations.\nUnderstanding concepts such as file descriptor duplication and granular control over file descriptors during file operations.\nDelving into the seek operation and its various modes, including handling holes and sparse files.","outline#Outline":"","controlling-standard-input-output-and-error-streams#Controlling Standard Input, Output, and Error Streams":"Understanding file descriptor duplication with functions like dup and dup2.\nExploring their applications in controlling standard streams for input/output redirection.","granular-control-over-open-file-descriptors#Granular Control Over Open File Descriptors":"Examining advanced options for opening files, including truncate-on-open, create-if-does-not-exist, and temporary files.\nUnderstanding how these options provide more flexibility and control in file handling.","seek-operation-lseek-on-open-files#Seek Operation (lseek) on Open Files":"Explaining the seek operation and its significance in navigating through files.\nUnderstanding various modes of seeking the file and their applications.","holes-and-sparse-files#Holes and Sparse Files":"Understanding the concept of holes and sparse files.\nExploring how to create sparse files using the seek operation and detecting holes within files.","practice#Practice":"","advanced-file-operations-using-shell#Advanced File Operations Using Shell":"Practical exercises involving advanced file operations in the shell, such as stream redirection, input/output piping, and utilities like grep and dd.\nDemonstrating how to leverage shell capabilities for efficient file handling.","random-file-access-using-lseek#Random File Access Using lseek":"Hands-on exercises to perform read and write operations at random file locations using the lseek function.\nUnderstanding the importance of random access in certain file manipulation scenarios.","creating-sparse-files-and-detecting-holes#Creating Sparse Files and Detecting Holes":"Practical demonstrations of creating sparse files using the lseek operation.\nExercises to detect and handle holes within sparse files for optimized file storage.","references#References":"Linux manual page - dup(2)\nLinux manual page - lseek(3p)\nlseek() in C/C++ to read the alternate nth byte and write it in another file","homework#Homework":"FS-4: Redirect standard input\nFS-5: Manaul append\nFS-10: Copy a file accounting holes","samples#Samples":"Redirect standard output and error\nCreate a file with holes\nDetect holes in the file"}},"/linux-programming/topics/file-systems-api":{"title":"The File Systems API and File Manipulations from Code","data":{"overview#Overview":"Providing a basic understanding of file abstractions in the API.\nExplaining the concept of file descriptors and their role in file operations.\nCovering main file operations such as creat, open, read, write, and close.","outline#Outline":"","concept-of-file-descriptors#Concept of File Descriptors":"Understanding file descriptors as integer values representing open files.\nExplaining the standard input (stdin) and standard output (stdout) file descriptors.","working-with-files-using-file-system-api-functions#Working with Files Using File System API Functions":"Introduction to essential file system API functions: open, read, write, close.\nExploring their parameters and return values.","proper-error-handling-with-system-calls#Proper Error Handling with System Calls":"Emphasizing the importance of error handling while using file system API functions.\nUtilizing the \"errno\" variable to identify and handle errors.","references#References":"File Descriptor (Wiki)\nHandling a File by its Descriptor in C\nOS5 - File Descriptors, File Descriptor Table","practice#Practice":"","writing-simple-programs-to-demonstrate-file-operations#Writing Simple Programs to Demonstrate File Operations":"Hands-on exercises to demonstrate main file operations such as file creation, reading, writing, and closing.\nPractical examples to reinforce understanding of file system API functions.","demonstrating-redirection-of-standard-input-and-output-streams#Demonstrating Redirection of Standard Input and Output Streams":"Writing programs to demonstrate redirection of standard input and output streams using basic open/close operations.\nUnderstanding how to manipulate file descriptors for redirection purposes.","references-1#References":"Linux manual page - open(2)\nLinux manual page - creat(3p)\nLinux manual page - read(2)\nLinux manual page - write(2)\nLinux manual page - close(2)\nLinux manual page - fcntl(2)\nLinux manual page - errno(3)\nReading and Writing Files in C, two ways (fopen vs. open)","homework#Homework":"FS-1: Read from the file\nFS-2: Copy a file\nFS-3: Secure file deletion","samples#Samples":"Opening a file"}},"/linux-programming/topics/file-systems-overview":{"title":"Overview of the Unix File Systems","data":{"overview#Overview":"Providing a concise understanding of files in Unix operating systems.\nDescribing the hierarchical tree structure of the file system.\nExploring different file types and their meanings in the Unix environment.\nCovering key attributes of files and directories, including ownership, permissions, and dates.","outline#Outline":"","tree-structure-of-unix-file-systems#Tree Structure of Unix File Systems":"Visualizing and understanding the hierarchical organization of files and directories in Unix.\nExploring the directory tree and its significance in file system navigation.","high-level-overview-of-main-file-types-in-unix#High-Level Overview of Main File Types in Unix":"Defining and discussing various file types: regular files, directories, links, etc.\nUnderstanding the purpose and characteristics of each file type in Unix.","main-attributes-of-files-and-directories#Main Attributes of Files and Directories":"Examining essential attributes such as owner, permissions, modification dates, etc.\nUnderstanding how these attributes contribute to file and directory management.","references#References":"The Unix File System\nThe Unix File System (GeeksForGeeks)\nLinux File System Explained\nLinux File Permissions Explained\nFile Permissions\nLinux для Начинающих - Права Доступа и владения файлами и директориями (RUS)","practice#Practice":"","working-with-unix-file-systems-using-shell#Working with Unix File Systems Using Shell":"Hands-on exercises for navigating and interacting with Unix file systems through the command line.\nIntroduction to essential shell commands for effective file system manipulation.","manipulating-files-and-directories#Manipulating Files and Directories":"Practical exercises for creating, modifying, and deleting files and directories.\nUnderstanding common file operations and their command-line counterparts.","working-with-file-ownership-and-permissions#Working with File Ownership and Permissions":"In-depth exploration of commands like chmod and chown for managing file permissions and ownership.\nHands-on practice to reinforce concepts of access control.","using-text-editors-from-the-shell#Using Text Editors from the Shell":"Introduction to popular text editors like nano and vim.\nHands-on experience with creating and editing text files directly from the shell.","references-1#References":"Linux Commands Part Two: Working With Files\n60 Linux Commands to Know\nBasic Linux Commands"}},"/linux-programming/topics/hardware-and-software":{"title":"Hardware and Software","data":{"overview#Overview":"Understanding the fundamental concepts of hardware and software.\nExploring the main components of a computer system.","outline#Outline":"","what-is-a-computer#What is a Computer?":"Defining the essential components and their functions.\nHighlighting the interplay between hardware and software.","operating-system-basics#Operating System Basics":"Providing a concise definition of an operating system.\nExploring the crucial role it plays in managing resources and providing user interfaces.","unix-gnu-and-free-software#UNIX, GNU, and Free Software":"Unveiling the significance of UNIX in computing history.\nUnderstanding the philosophy behind GNU and the concept of free software.","kernels-overview#Kernels: Overview":"Introduction to kernels and their role as the core of operating systems.\nExamining different kernels such as Minix, Linux, and BSD.","gnulinux-distributions#GNU/Linux Distributions":"Surveying the landscape of GNU/Linux distributions.\nDiscussing popular distributions and their unique features.","references#References":"Operating Systems: Wiki\nKernel: Wiki\nFree Software and Open-Source\nЭволюция вычислительных систем (RUS)\nWhat is Kernel\nMicrokernel and Monolithic Kernel\nComputer Basics: Inside a Computer\nGNU/Linux Distributions\nDistributions Tree","practice#Practice":"","setting-up-a-virtual-machine-with-gnulinux#Setting Up a Virtual Machine with GNU/Linux":"Practical guide to creating a virtual environment for hands-on experience.\nEmphasizing the importance of virtualization in system programming.","command-line-mastery#Command Line Mastery":"Utilizing the command line for fundamental operations.\nHands-on practice with file manipulation, software installation, and more.","development-environment-setup#Development Environment Setup":"Configuring essential tools like Git, gcc/g++, and make for efficient programming.\nEstablishing a robust development environment for system programming tasks.","github-repository-setup#GitHub Repository Setup":"Understanding key concepts for version control with Git.\nCreating and managing repositories on GitHub for organized collaboration.","overview-of-existing-gnulinux-distributions#Overview of Existing GNU/Linux Distributions":"In-depth exploration of prominent GNU/Linux distributions.\nInsight into the strengths and use-cases of different distributions.","references-1#References":"Download VirtualBox\nDownload Ubuntu\nInstall Ubuntu in VirtualBox\nGit and GitHub\nGit Username Setup\nGit Commit Email Setup","homework#Homework":"ENV-1: Setup GNU/Linux Environment"}},"/linux-programming/topics/linux-programming":{"title":"Introduction to Linux Programming","data":{"overview#Overview":"Providing a concise introduction to programming in the Linux operating system.\nExplaining the key aspects of compiling and executing C/C++ code.\nUnderstanding the main phases of compilation and the significance of binary executable files.","outline#Outline":"","anatomy-of-cc-source-file#Anatomy of C/C++ Source File":"Breaking down the components of a source file: directives, code, comments, etc.\nUnderstanding the structure that makes up C/C++ source code.","program-entry-point-main-function#Program Entry Point: Main Function":"Exploring the main function as the entry point of a C/C++ program.\nUnderstanding the role of arguments passed to the main function.","compilation-process#Compilation Process":"Overview of the compilation phases: pre-processing, translation, assembling, and linking.\nExplaining the transformation of source code into an executable binary.","understanding-elf-binary-format#Understanding ELF Binary Format":"Introduction to the ELF (Executable and Linkable Format) binary format.\nDifferentiating between static and dynamic linking libraries.","loading-program-into-memory-and-memory-layout#Loading Program into Memory and Memory Layout":"Understanding how programs are loaded into memory during execution.\nExploring the memory layout of a running program.","references#References":"Understanding C and C++ compilation process\nC++: препроцессор, компилятор, компоновщик (RUS)\nThe C++ compilation model\nMemory Layout of C Program","practice#Practice":"","analysis-of-a-hello-world-program-in-cc#Analysis of a \"Hello, World!\" Program in C/C++":"Step-by-step analysis of a simple program to understand its structure.\nEmphasizing key elements of C/C++ code.","compilation-using-g-from-shell#Compilation Using g++ from Shell":"Practical exercises on compiling C/C++ source code using the g++ compiler from the command line.\nExploring various compiler options.","introduction-to-development-tools#Introduction to Development Tools":"Brief overview of essential development tools such as man, nm, ldd, strip, etc.\nUnderstanding their roles in the development process.","build-process-and-makefiles#Build Process and Makefiles":"Explaining the build process and the importance of automation.\nIntroduction to writing Makefiles for streamlining the compilation and linking process.\nExploring alternative build tools.","references-1#References":"Compiling with g++\nC Programming: Makefiles\nBegineer Makefile tutorial\nMakefile tutorial\n9 Essential GNU binutils tools\nCMake Tutorial EP 1 | Understanding The Basics","homework#Homework":"ENV-2: Complex numbers and sorting","guides#Guides":"Compilation and build process","samples#Samples":"Compiling multiple files using Makefile"}},"/linux-programming/topics/processes":{"title":"Overview of Unix Processes","data":{"outline#Outline":"","definition-of-process-and-process-tree#Definition of Process and Process Tree":"Understanding the concept of a process as a program in execution state.\nIntroduction to the init process and the hierarchical tree structure of processes.","introduction-to-virtual-memory#Introduction to Virtual Memory":"Brief overview of virtual memory and its role in process execution.\nExplaining concepts such as pages and page tables within the virtual memory of a process.","properties-of-a-process#Properties of a Process":"Exploring key properties of processes, including process ID (pid) and file descriptor table.\nUnderstanding other process-related attributes essential for management and identification.","process-creation-workflow#Process Creation Workflow":"Understanding the process creation workflow through functions like fork and clone.\nExplaining the parent-child relationship and the lifecycle of a process.","execution-of-programs-in-processes#Execution of Programs in Processes":"Overview of executing programs within a process using exec* functions.\nUnderstanding how these functions replace the current process image with a new one.","references#References":"ECE 252 Lecture 5: Processes in UNIX\nThe Exec Family of Functions\nThe fork function in C\nWaiting for processes to finish in C","practice#Practice":"","practical-overview-of-the-process-tree#Practical Overview of the Process Tree":"Hands-on exploration of the process tree using shell commands like ps.\nUnderstanding the structure and relationships within the process hierarchy.","demonstration-of-process-lifecycle#Demonstration of Process Lifecycle":"Writing a simple program to demonstrate the lifecycle of a process using fork, wait, and exec functions.\nPractical exercises to illustrate process creation, execution, and termination.","usage-of-command-line-arguments-and-environment-variables#Usage of Command Line Arguments and Environment Variables":"Demonstrating the usage of command line arguments with exec functions.\nUnderstanding the inheritance of environment variables between parent and child processes.","references-1#References":"Linux manual page - fork(2)\nLinux manual page - wait(2)\nLinux manual page - clone(2)\nLinux manual page - exec(3)\nExample of fork() in C\nFork System Call in Operating System","homework#Homework":"PS-1: Do command\nPS-2: Interactive shell","samples#Samples":"Creating a process"}},"/linux-programming/topics/system-calls":{"title":"System calls, hardware-software communication, POSIX standard","data":{"overview#Overview":"Understanding the essential aspects of communication between hardware and software.\nExploring the functionality exposed by operating systems and the role of System Calls.\nIntroduction to the POSIX standard for hardware and software compatibility.","outline#Outline":"","how-cpu-and-memory-work-together#How CPU and Memory Work Together?":"Explaining the synergy between the CPU and RAM in a computer system.\nUnderstanding the fundamental principles of memory management.","kernel-communication-with-cpu-ram-and-devices#Kernel Communication with CPU, RAM, and Devices":"Unraveling the mechanisms through which the Kernel communicates with critical components.\nInsight into the role of the Kernel in managing hardware resources.","operating-system-functionality-for-application-development-system-calls#Operating System Functionality for Application Development: System Calls":"Examining the functionality exposed by the operating system for application development.\nUnderstanding the significance of System Calls in facilitating communication between applications and the OS.","introduction-to-posix-standard#Introduction to POSIX Standard":"Exploring the POSIX standard and its importance for ensuring hardware and software compatibility.\nDiscussing key POSIX concepts and their impact on cross-platform development.","references#References":"The Fetch-Execute Cycle\nЛекция 1. Генезис операционных систем: Назначение ОС (RUS)\nSystem Calls\nSystem Calls: Wiki\nPOSIX Standard Explained","practice#Practice":"","using-gnulinux-as-a-development-environment#Using GNU/Linux as a Development Environment":"Practical guidance on leveraging GNU/Linux for efficient development.\nIncorporating essential tools and practices for seamless system programming.","overview-of-git-and-repository-setup#Overview of Git and Repository Setup":"Brief overview of Git for version control and collaboration.\nStep-by-step guide on setting up repositories for homework assignments.","basic-shell-commands-and-inputoutput-operations#Basic Shell Commands and Input/Output Operations":"Hands-on experience with fundamental shell commands.\nExploring standard input and output operations, including redirection and piping.","high-level-introduction-to-shell-scripting#High-Level Introduction to Shell Scripting":"Introduction to the basics of shell scripting.\nUnderstanding the power of automation through simple script creation.","references-1#References":"Man Pages - The Complete Guide\nManual Pages\nThe Missing Semester of Your CS Education\nMissing Semester: The Shell\nMissing Semester: Shell Tools and Scripting\nMissing Semester: Editors (vim)\nMissing Semester: Version Control (git)"}},"/linux-programming/topics/threads":{"title":"Threading: Parallelism and Concurrency","data":{"topic-outline#Topic Outline":"","overview-of-memory-layout-heap-and-stack#Overview of Memory Layout: Heap and Stack":"Understanding the memory layout of a process, including the heap and stack.\nExplaining the concept of the call stack and its role in thread execution.","the-concept-of-thread-and-thread-context#The Concept of Thread and Thread Context":"Introducing the concept of a thread and its execution context.\nHighlighting the main differences between a process and a thread in terms of isolation, memory management, and scheduling.","understanding-parallelism-and-concurrency#Understanding Parallelism and Concurrency":"Explaining the difference between parallel and concurrent execution.\nUnderstanding how threads enable concurrent execution within a single process.","introduction-to-pthread-library#Introduction to Pthread Library":"Overview of the Pthread library (POSIX threads) for thread programmability.\nCovering essential functions for creating, joining, and cancelling threads using the Pthread API.","references#References":"Function Pointer in C\nECE 252 Lecture 10: Threads\nECE 252 Lecture 11: Threads and Concurrency\nIntroduction to Pthreads","practice#Practice":"","writing-multi-threaded-programs-using-pthread-library#Writing Multi-threaded Programs using Pthread Library":"Hands-on exercises to write multi-threaded programs using the Pthread library.\nImplementing parallel execution of tasks within a single process using threads.","using-library-functions-to-manage-threads#Using Library Functions to Manage Threads":"Practical demonstrations of using library functions to join and cancel threads within a program.\nUnderstanding the role of thread synchronization and coordination.","compilation-and-linking-with-pthread-library#Compilation and Linking with Pthread Library":"Understanding the compilation and linking process with the Pthread library.\nEnsuring proper integration of Pthread library functions in multi-threaded programs.","references-1#References":"Linux manual page - pthread_create(3)\nLinux manual page - pthread_join(3)\nLinux manual page - pthread_exit(3)\nLinux manual page - pthread_cancel(3)\nLinux manual page - pthread_attr_init(3)\nLinux manual page - pthread_attr_destroy(3)\nMultithreading in C\nThread functions in C/C++","homework#Homework":"TH-1: The array summary\nTH-2: The thread pool implementation","samples#Samples":"Creating a thread"}},"/operating-systems":{"title":"Getting Started","data":{}},"/operating-systems/topics":{"title":"Topics","data":{"":"This is topics outline"}},"/operating-systems/topics/introduction":{"title":"Introduction","data":{"":"This is an intro"}}}