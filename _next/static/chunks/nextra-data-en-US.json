{"/":{"title":"Home","data":{}},"/system-programming/guides":{"title":"Guides","data":{}},"/system-programming/guides/compilation":{"title":"Compilation and build process","data":{"":"The set of samples showcases different aspects of the compilation process in the Linux environment using various tools such as gcc, make, cmake, etc.","single-file-compilation#Single file compilation":"Consider main.cpp as a source file containing the whole logic of the application:\nTo compile the source code into an executable file execute the following line in the source directory:\nwhere parameter -o app defines the name of the output file (a.out by default).If the command completes successfully, the source directory will contain a file called app that is ready to execute as follows:","pre-processing-a-c-source-file#Pre-processing a C++ source file":"You may want to stop the compiler after the pre-processing phase when all the directives such as include, define, etc. are resolved.\nIn that case you will need to run the pass the -E flag to the compiler as follows:\nThe result of the command prints the result on a console by default, hence we redirected the content to be written to file \"preprocessed-main.cpp\" by using redirection operator (>) of shell.","translation-of-the-source#Translation of the source":"You may also want to stop the compiler after the translation phase to get the low-level code in assembler language. For that you need to pass -S flag to the compiler. It will generate a new file with .s extension by default:\nAfter the command is completed successfully you will get a main.s file containing your source in assembler language. The file will contain something like this:","assembling-the-compiled-file#Assembling the compiled file":"Most commonly, you will need to compile your source file to a binary object file containing your source code in a binary format, but not ready to execute. Object files are generated by passing -c to the compiler. By default a file with \".o\" extension will be generated:\nAfter this command, a file named main.o will be generated.","linking-object-files#Linking object files":"In most of the cases, you will have many source files compiled into object files separately and after all object files are ready you will link those together and add necessary libraries. For example, if you have files main.o, module1.o and module2.o you will need to link those together into an executable file (or a library):\nAfter this command, a file named \"a.out\" will be generated and will be ready to run.Also, you may want to see the libraries your executable is linked to using the following command:\nIn this basic example, your executable will be linked with the standard libraries as follows:"}},"/system-programming":{"title":"Getting started","data":{"":"This course introduces students to system programming in Linux, focusing on how applications interact directly with the operating system through the kernel API. Students will move from basic exploration of the Linux environment to writing programs that manage files, processes, threads, interprocess communication, and network connections.","sections#Sections":"","bibliography#Bibliography":"Programming via Operating Systems, Vahram Martirosyan, Feb 2022\nThe Art of Unix Programming, Eric S. Raymond\nW. Richard Stevens & Stephen A. Rago — Advanced Programming in the UNIX Environment (APUE), 3rd Edition\nW. Richard Stevens — UNIX Network Programming, Volume 1: The Sockets Networking API, 3rd Edition\nRemzi H. Arpaci-Dusseau & Andrea C. Arpaci-Dusseau — Operating Systems: Three Easy Pieces (OSTEP) read online\nMichael Kerrisk — The Linux Programming Interface (TLPI)\nThe Linux man-pages project read online\nBeej’s Guides read online\nOperating Systems: Design and Implementation, Andrew S. Tanenbaum Albert S. Woodhull, Jan 1997\nRobert Love — Linux System Programming (O’Reilly, 2nd Ed.)\nBrian W. Kernighan & Dennis M. Ritchie — The C Programming Language (K&R)\nStructured Computer Organization, Andrew S. Tanenbaum, Jan 1984\nOperating system design: the XINU approach, D. Comer Timothy V. Fossum, Jan 1984\nModern operating systems (2. ed.).,  Andrew S. Tanenbaum, Jan 2001\nLinux Kernel in a nutshell, Greg Kroah-Hartman, Jan 2006"}},"/system-programming/samples":{"title":"Samples","data":{}},"/system-programming/samples/bounded-buffer":{"title":"Bounded buffer (producer and consumer)","data":{"":"The sample demonstrates how to implement a producer-consumer solution (bounded buffer) using semaphores and using conditional variables.","using-semaphores#Using semaphores":"The below solution uses a mutex for synchronizing access to the buffer and two semaphores: available_counter to indicate number of available slots and occupied_counter to indicate the number of used slots.","using-conditional-variables#Using conditional variables":"The above solution uses a mutex for synchronizing access to the buffer and two conditional variables: not_full to indicate that there are available slots and not_empty to indicate that there are occupied/used slots."}},"/system-programming/samples/copy-file":{"title":"Copy the given file","data":{"":"This sample demonstrates how to implement a basic copy program using read and write functions.\nThe file can be compiled with the following command:\nRunning the resulting application ./copy source-file.txt new-file.txt duplicate source-file.txt with name new-file.txt."}},"/system-programming/samples/create-process":{"title":"Creating a process","data":{"":"The sample demonstrates how to create a process using fork() function.\nThe file can be compiled and executed as follows:\nThe program is supposed to start a process and clone itself printing appropriate messages as follows:"}},"/system-programming/samples/detect-holes":{"title":"Detect holes in the file","data":{"":"The sample demonstrates how to detect data and hole segments in the given file.\nThe file can be compiled and executed as follows:\nThe program is supposed to print start and end indexes of all the data and hole segments if any."}},"/system-programming/samples/create-thread":{"title":"Creating a thread","data":{"":"The sample demonstrates how to create a thread using pthread_create() function and wait for its completion.\nThe file can be compiled and executed as follows:\nThe program is supposed to print + and - signs without any particular order as follows:"}},"/system-programming/samples/dining-philosophers":{"title":"Dining philosophers","data":{"":"The sample demonstrates a simple implementation of dining philosophers problem's solution using semaphore.","naive-implementation-#Naive implementation ❌":"The following code is a simple implementation for the problem that solves race condition, however, introduces the deadlock.\nThe problem is following: whenever philosopher tries to pick up forks, they try picking up the left fork and then the right fork.\nIf, two all the philosophers will simultaneously pick up the left fork, they will succeed, however, no philosopher will be able to pick up the right fork, and hence, no one will eat and put down the left fork.This will lead to circular infinite waiting - a deadlock.To break the circular dependency, one of the practices is odd/even strategy - philosophers with even index pick up left fork first, while odd-indexed philosophers pick up the right fork first.\nThis way, the circular waiting will be impossible.","implementation-oddeven-picking-strategy-#Implementation (odd/even picking strategy) ✅":"This is the part of the code that needs to be added/modified:\nThe full implementation looks like this:"}},"/system-programming/samples/epoll-server":{"title":"Non-blocking server with epoll","data":{"":"The sample demonstrates how to build a non-blocking TCP server using epoll. All sockets are set to non-blocking mode with SOCK_NONBLOCK / accept4(). The epoll instance tracks the listening socket and every connected client. When a client sends its name the server replies with a personalised greeting and closes the connection.\nThe file can be compiled and executed as follows:\nSend a name from several terminals simultaneously:\nThe server output should look like:\nEach client receives its greeting:"}},"/system-programming/samples/make-hole":{"title":"Create a file with holes","data":{"":"This sample demonstrates the ability to create a sparse file containing both data segments and holes using lseek function.\nThe program is expected to accept the target file name as a first argument and sequence of sizes for created data and hole segments in the file.\nThe file can be compiled and executed as follows:\nAfter successful completion of the program, we will have file \"file_with_holes\" created containing 2 data segments of size 4096 and 2 holes of size 4096."}},"/system-programming/samples/makefile":{"title":"Compiling multiple files using Makefile","data":{"":"In this sample, we will compile a program having two modules with Makefile.The program will contain two modules:\nmain.cpp - the main logic of the application\nmessage.cpp - a module that can simply print messages\nLet's assume the main.cpp contains the following logic:\nThe file message.h contains only a declaration of the used function:\nThen the module message.cpp should implement the mentioned function as follows:\nWe can manually compile the modules one by one as follows:\nThen, having two modules main.o and message.o we can build the final executable by linking those together:\nTo automate the process we could also write a Makefile as follows:\nNow, invoking make command will create all the necessary files for the program.You may also want to clean the build output with a special clean target as follows:"}},"/system-programming/samples/open-file":{"title":"Opening a file","data":{"":"This sample demonstrates the usage of functions open and close.\nThe file can be compiled with the following command:\nRunning the resulting application ./open should create a file named foo.txt and print the following result:"}},"/system-programming/samples/poll-fds":{"title":"Monitoring file descriptors with poll","data":{"":"The sample demonstrates how to use poll() to monitor multiple file descriptors without the FD limit of select(). The server keeps a pollfd array that starts with the listening socket and grows as clients connect. Whenever a client sends a message the server reads and prints it; disconnections are detected and the slot is freed.Unlike select(), the pollfd array does not need to be rebuilt on every call — only revents is overwritten by the kernel.\nThe file can be compiled and executed as follows:\nConnect several clients simultaneously using nc and send messages:\nThe server output should look like:"}},"/system-programming/samples/read-file":{"title":"Reading file contents","data":{"":"This sample demonstrates how to read a text file using read() function.\nThe file can be compiled with the following command:\nRunning the resulting application ./read some-file.txt will print the contents of the given file to the console."}},"/system-programming/samples/select-fds":{"title":"Monitoring file descriptors with select","data":{"":"The sample demonstrates how to use select() to monitor multiple file descriptors at the same time. The program watches two sources simultaneously: stdin (keyboard input) and a TCP listening socket (incoming connections). It reacts to whichever becomes ready first, and times out after 5 seconds of inactivity.Note that the fd_set must be rebuilt before every call to select() because the kernel overwrites it to indicate which descriptors are ready.\nThe file can be compiled and executed as follows:\nWith no activity the program prints a timeout message every 5 seconds. Typing into the terminal or connecting with nc triggers the corresponding handler:"}},"/system-programming/samples/redirect-output":{"title":"Redirect standard output and error","data":{"":"This sample demonstrates how to redirect standard output and standard error into a file (using dup/dup2) while keeping possibility to write to the console when needed.\nThe file can be compiled with the following command:\nRunning the resulting application ./redirect is supposed to print \"Hello\" on the console screen and create a file output.log containing cout and cerr text."}},"/system-programming/samples/tcp-client":{"title":"TCP client","data":{"":"The sample demonstrates how to create a TCP client using the BSD socket API. The client connects to a server at a given IP address and port, sends a short message, and closes the connection.\nStart the TCP server sample first, then compile and run the client:\nThe client output should look like:\nAnd on the server side:"}},"/system-programming/samples/tcp-server":{"title":"TCP server","data":{"":"The sample demonstrates how to create a TCP server using the BSD socket API. The server binds to a local port, listens for incoming connections, and accepts clients one at a time. For each client it reads one message, prints it to stdout, and closes the connection.\nThe file can be compiled and executed as follows:\nConnect with nc from another terminal to test:\nThe server output should look like:"}},"/system-programming/tasks":{"title":"Tasks","data":{}},"/system-programming/tasks/environment":{"title":"Environment","data":{}},"/system-programming/tasks/environment/complex-number":{"title":"ENV-2: Complex numbers and sorting","data":{"requirements#Requirements":"Write multi-file C++ program consisting of following 3 modules:\nA class that represents a complex number along with all the basic operations: plus, minus, multiply by a constant, absolute value.\nA function that implements any sorting algorithm on an array/vector of complex numbers.\nA main function containing a demonstration of having multiple complex numbers in array and sorting them.\nModules for complex number class and sorting algorithm should be separate and each of them should have source and header files.","expected-result#Expected result":"A solution containing all the described modules (source and header files), as well as, a Makefile for automated build of the solution.The final solution should contain a Makefile for the multi-stage build. The Makefile should also contain targets all and clean. It's recommended to have compiler and compiler flags to be declared as a Makefile variables. Alternatively, cmake could also be used instead of make."}},"/system-programming/tasks/environment/environment-setup":{"title":"ENV-1: Setup GNU/Linux Environment","data":{"requirements#Requirements":"Install any GNU/Linux distribution on a Virtual or Physical Machine.\nRun lsb_release -a >> $USER.txt command (if available) in a shell and get the result.\nRun cat /etc/os-release >> $USER.txt command (if available) in a shell and get the result.\nSubmit $USER.txt file to the Github as a solution for the task.","expected-output#Expected output":"The expected output is a text file named $USER.txt where $USER is the current user's username. The content is expected to be similar to the following:"}},"/system-programming/tasks/file-systems":{"title":"File Systems","data":{}},"/system-programming/tasks/file-systems/copy-file":{"title":"FS-2: Copy a file","data":{"requirements#Requirements":"Write a C++ program simple-copy accepting two command line arguments representing source file path and destination file path.\nImplement proper error handling to account if not all arguments are passed or if one of arguments is not a valid one.\nCopy the content of the source file into a destination file. If destination file already exists, it should be overwritten.","expected-result#Expected result":"The resulting application should be able to build and execute from command line as follows:\nThe final solution should contain a Makefile for the multi-stage build. The Makefile should also contain targets all and clean. It's recommended to have compiler and compiler flags to be declared as a Makefile variables. Alternatively, cmake could also be used instead of make."}},"/system-programming/tasks/file-systems/copy-with-holes":{"title":"FS-10: Copy a file accounting holes","data":{"requirements#Requirements":"Write a C++ program accepting two command line arguments representing source file path and destination file path.\nImplement proper error handling to account if not all arguments are passed or if one of arguments is not a valid one.\nCopy the content of the source file into a destination file. If destination file already exists, it should be overwritten.\nIf source file contains holes, the destination file should also contain hole as is.\nPrint overall amount of bytes copied to the destination file including total amount of physical data and total amount of holes if any.","expected-result#Expected result":"The resulting application should be able to build and execute from command line as follows:\nAfter copy is completed, program should print following message to the console:\nThe logical and physical sizes of source and destination files should match exactly.The final solution should contain a Makefile for the multi-stage build. The Makefile should also contain targets all and clean. It's recommended to have compiler and compiler flags to be declared as a Makefile variables. Alternatively, cmake could also be used instead of make."}},"/system-programming/tasks/file-systems/read-file":{"title":"FS-1: Read from the file","data":{"description#Description":"You need to implement a program that does the same thing as the cat command in the Linux.","requirements#Requirements":"Write a C++ program read-file accepting a file path as an argument.\nImplement proper error handling to make sure required file path is passed.\nOpen the given file with proper mode and make sure errors are handled.\nRead the content of the file into a buffer until reaching the end of the file.\nPrint every portion of the file read in the iteration.\nHint: if you use printf or std::cin, make sure your strings are terminated with '\\0' symbol.","expected-result#Expected result":"The resulting application should be able to build and execute from command line as follows:\nThe program should output the content of the input.txt file on the screen.The final solution should contain a Makefile for the multi-stage build. The Makefile should also contain targets all and clean. It's recommended to have compiler and compiler flags to be declared as a Makefile variables. Alternatively, cmake could also be used instead of make."}},"/system-programming/tasks/file-systems/manual-append":{"title":"FS-5: Manaul append","data":{"description#Description":"Your task is to write a program on C/C++ that writes two lines in the files \"first line\" and \"second line\".\nWriting should happen into two different file descriptors but write into the same file.","requirements#Requirements":"Write a C/C++ program that gets the filepath with the first argument and opens it.\nFile should not be opened with the O_APPEND file.\nYou are not allowed to use seek/lseek to move the cursor to the end.\nThe program writes two lines: \"first line\" and \"second line\". Each line is written in a different descriptor.\nAfter write, the file should contain both lines in the same file.\nHint: you may use dup/dup2.","expected-result#Expected result":"The resulting application should be able to build and execute from command line as follows:\nThe output file should contain the following text:\nThe final solution should contain a Makefile for the multi-stage build. The Makefile should also contain targets all and clean. It's recommended to have compiler and compiler flags to be declared as a Makefile variables. Alternatively, cmake could also be used instead of make."}},"/system-programming/tasks/file-systems/redirect-cin":{"title":"FS-4: Redirect standard input","data":{"description#Description":"By default, program gets standard input waiting for the keyboard input. Your task is to make any program to read input from the file instead of waiting for the keyboard input without changing usages of std::cin or scanf.","requirements#Requirements":"Write a C++ program named \"redirect-cin\" that accepts a path to a file as a command-line argument.\nImplement the function initialize(int argc, char** argv) to start reading from the given file with a proper error handling.\nImplement a simple logic for main() function to read string from the standard input (std::cin) and print the reversed string to the cosnsole (std::out).\nIf there is an error with given file, the program should terminate with the proper error code.\nThe program's main source file should look like:\nHint: you can use one of dup() functions.","expected-result#Expected result":"The resulting application should be able to build and execute from command line as follows:\nAnd, assuming input file contains the text \"123456789\", the program should output the following:\nThe final solution should contain a Makefile for the multi-stage build. The Makefile should also contain targets all and clean. It's recommended to have compiler and compiler flags to be declared as a Makefile variables. Alternatively, cmake could also be used instead of make."}},"/system-programming/tasks/file-systems/secure-file-deletion":{"title":"FS-3: Secure file deletion","data":{"description#Description":"Your task is to implement a C++ program that deletes the file from the filesystem along with its content by replacing every byte in the files with '\\0' character.","requirements#Requirements":"Write a C++ program named \"hacker-rm\" that accepts a path to a file as a command-line argument.\nImplement proper error handling to check if the file exists and if the input path is valid.\nOpen the file for writing and replace every byte with the null character ('\\0').\nRemove the file from the file system after overwriting its content.\nEnsure that your program works for various file sizes and types.\nHint: you can use write, stat, lseek, unlink function to solve the problem.","expected-result#Expected result":"The resulting application should be able to build and execute from command line as follows:\nThe final solution should contain a Makefile for the multi-stage build. The Makefile should also contain targets all and clean. It's recommended to have compiler and compiler flags to be declared as a Makefile variables. Alternatively, cmake could also be used instead of make."}},"/system-programming/tasks/ipc":{"title":"IPC","data":{}},"/system-programming/tasks/ipc/prime-calculator":{"title":"IPC-2: Prime calculator","data":{"requirements#Requirements":"Write a C++ program that creates a child process.\nThe main process infinitely waits for the user's input integer m.\nOnce number m is received by the main process, it gets passed to the child process via anonymous pipe.\nThe child process takes m from the anonymous pipe and calculates the m-th prime number.\nThe child process should send the result of the calculation back to the parent process, which, should print it and wait for the next input.\nIf the \"exit\" command is entered, the main process should stop its execution.","expected-result#Expected result":"The resulting application should be able to build and execute from the command line as follows:\nThe typical execution of the program should look like the following:\nThe final solution should contain a Makefile for the multi-stage build. The Makefile should also contain targets all and clean. It's recommended to have compiler and compiler flags declared as Makefile variables. Alternatively, cmake could also be used instead of make."}},"/system-programming/tasks/ipc/shared-array":{"title":"IPC-3: Shared array implementation","data":{"requirements#Requirements":"Write a C++ class implementing a module shared_array which is an array of integers shared between processes.\nThe class is supposed to be initialized as follows: shared_array array(\"array-name\", size);\nThe size of the array (number of elements) could be between 1 and 1 000 000 000\nTwo shared arrays are the same in the system if they have equal names and sizes, otherwise, they are different.\nThe class should provide operator [] for indexing an element with a given index i.\nAny process that knows the name and the size of the array should be able to use it.\nWrite two infinite programs (first and second) to work with the shared array using cross-process semaphore.","expected-result#Expected result":"The resulting application should be able to build from the command line as follows:\nThe execution of the program should demonstrate how the array changes from the first and second processes.The final solution should contain a Makefile for the multi-stage build. The Makefile should also contain targets all and clean. It's recommended to have compiler and compiler flags declared as Makefile variables. Alternatively, cmake could also be used instead of make."}},"/system-programming/tasks/ipc/signal-echo":{"title":"IPC-1: Signal echo","data":{"requirements#Requirements":"Write a C++ program that prints its PID and registers a signal handler for SIGUSR1.\nThe handler of the signal SIGUSR1 is suppose to react by printing the following information:\nThe PID of the sender process,\nThe UID and the user name of the sender,\nThe current values of the EIP, EAX, EBX registers.\nProgram should enter an infinite loop and perform a sleeping delay on each iteration (example: sleep for 10 seconds).","expected-result#Expected result":"The resulting application should be able to build and execute from command line as follows:\nThen, once any other process sends SIGUSR1 signal to our process, it should print the following information:\nThe final solution should contain a Makefile for the multi-stage build. The Makefile should also contain targets all and clean. It's recommended to have compiler and compiler flags to be declared as a Makefile variables. Alternatively, cmake could also be used instead of make."}},"/system-programming/tasks/networking":{"title":"Networking","data":{}},"/system-programming/tasks/networking/echo-server":{"title":"NET-1: Echo Server","data":{"requirements#Requirements":"Write a C/C++ TCP echo server program that:\nCreates a TCP socket and binds it to a specified port (default: 8080)\nListens for incoming client connections\nAccepts a client connection and echoes back any data received from the client\nHandles the client until the connection is closed, then waits for the next client\nPrints connection information (client IP address and port) when a client connects\nThe server should run indefinitely until terminated with Ctrl+C\nWrite a C/C++ TCP client program that:\nConnects to the echo server at a specified IP address and port\nReads user input from stdin and sends it to the server\nReceives the echoed response from the server and prints it\nContinues until the user types \"exit\" or closes stdin (Ctrl+D)\nBoth programs must use the BSD socket API (socket(), bind(), listen(), accept(), connect(), send(), recv(), close())\nUse proper byte order conversion (htons(), inet_pton(), etc.)\nHandle errors appropriately (check return values of all socket calls)","expected-result#Expected result":"The resulting applications should be able to build and execute from command line as follows:\nIn a separate terminal, run the client:\nServer terminal output:\nClient terminal output:","bonus-optional#Bonus (Optional)":"Support multiple concurrent clients using fork() or threads\nAdd a command-line option to specify the server's listening address (not just port)\nImplement a simple protocol: prefix each message with its length","deliverables#Deliverables":"The final solution should contain a Makefile for building both programs. The Makefile should contain targets:\nall — build both server and client\necho-server — build only the server\necho-client — build only the client\nclean — remove compiled binaries\nIt's recommended to have compiler and compiler flags declared as Makefile variables. Alternatively, cmake could also be used instead of make."}},"/system-programming/tasks/networking/multiplexed-sqrt-server":{"title":"NET-2: Multiplexed Sqrt Server","data":{"requirements#Requirements":"Write a C/C++ TCP server program that:\nCreates a TCP socket and binds it to a specified port (default: 8080)\nListens for incoming client connections\nUses epoll to handle multiple simultaneous clients in a single thread — no fork(), no threads\nAll sockets (listening and client) must be set to non-blocking mode (O_NONBLOCK)\nFor each connected client:\nReads exactly 4 bytes representing a signed 32-bit integer (int32_t) in network byte order\nComputes f(x) = sqrt(abs(x)) and sends the result back as an 8-byte IEEE 754 double in network byte order\nHandles the case where the client sends multiple requests over the same connection\nDetects client disconnection and removes the descriptor from the epoll instance\nPrints a log line when a client connects or disconnects, and for each request processed\nRuns indefinitely until terminated with Ctrl+C\nWrite a C/C++ TCP client program that:\nConnects to the server at a specified IP address and port\nReads an integer from stdin, sends it to the server as a 4-byte network-order int32_t\nReceives the 8-byte double response and prints the result\nRepeats until EOF (Ctrl+D) or the user types exit\nBoth programs must use the BSD socket API and proper byte order conversion\nHandle all system call errors — check every return value","expected-result#Expected result":"The resulting applications should be able to build and execute from command line as follows:\nIn separate terminals, run multiple clients simultaneously:\nServer terminal output:\nClient terminal output:","notes#Notes":"Use epoll_create1(EPOLL_CLOEXEC) to create the epoll instance\nUse level-triggered mode (default) — no need for edge-triggered for this task\ndouble has no standard network byte order representation — use a byte-swap approach or send as raw bytes with a defined endianness (document your choice)\nsqrt and fabs are in <math.h> / <cmath>; link with -lm if needed","bonus-optional#Bonus (Optional)":"Switch to edge-triggered mode (EPOLLET) and implement the full draining loop for reads\nSupport an arbitrary number of requests per connection with a per-client receive buffer to handle partial reads correctly\nAdd a timeout: disconnect clients that send no request within 30 seconds (use epoll_wait timeout or timerfd)\nReport the number of active connections when receiving SIGUSR1","deliverables#Deliverables":"The final solution should contain a Makefile for building both programs. The Makefile should contain targets:\nall — build both server and client\nsqrt-server — build only the server\nsqrt-client — build only the client\nclean — remove compiled binaries\nIt's recommended to have the compiler and compiler flags declared as Makefile variables. Alternatively, cmake could also be used instead of make."}},"/system-programming/tasks/processes":{"title":"Processes","data":{}},"/system-programming/tasks/processes/do-command":{"title":"PS-1: Do command","data":{"description#Description":"Your task is to implement a C++ program that accepts a command name and command arguments with command-line arguments and executes it in a new process.","requirements#Requirements":"Write a C++ program called \"do-command\" that takes N arguments as an input.\nAssume that first argument is command name and others are arguments for the given command.\nA program should contain a special function do_command(char** argv), where argv is null-terminated vector of arguments.\nThe function \"do_command\" should create a new process, execute the given command with the given arguments and wait for its completion.\nAfter program execution is done, do_function should print exit status of the command and the duration of the command execution.\nThe \"main\" function of the program is responsible for building proper argument vector and using do_command function to execute the command.","expected-result#Expected result":"The resulting application should be able to build and execute from command line as follows:\nThe command is expected to print program output to the console and a line as follows:\nThe final solution should contain a Makefile for the multi-stage build. The Makefile should also contain targets all and clean. It's recommended to have compiler and compiler flags to be declared as a Makefile variables. Alternatively, cmake could also be used instead of make."}},"/system-programming/tasks/processes/interactive-shell":{"title":"PS-2: Interactive shell","data":{"requirements#Requirements":"Write a C++ program that implements an interactive shell with an infinite loop waiting for a command.\nOn every iteration of the loop a command string is passed to the shell program.\nA command can be either a name of command or a path (relative or absolute).\nAfter command is entered, program should create a new process to run the command.\nThe current directory of the shell program should be temporarily added to the PATH variable of every new process.\nIf \"exit\" command is entered, shell program should stop and exit with a success code.\nIf entered command starts with word \"silent\", the executing command should redirect the standard output and error streams into the PID.log file where PID is the process id of the child process.","expected-result#Expected result":"The resulting application should be able to build and execute from command line as follows:\nUser may enter commands as follows:\nor\nor\nand the command should print the output to the console.Also user may want to enter commands as follows\nand the output of program ls should be redirected into the file PID.log where PID is the identifier of the child process.The final solution should contain a Makefile for the multi-stage build. The Makefile should also contain targets all and clean. It's recommended to have compiler and compiler flags to be declared as a Makefile variables. Alternatively, cmake could also be used instead of make."}},"/system-programming/tasks/threads":{"title":"Threads","data":{}},"/system-programming/tasks/threads/array-sum":{"title":"TH-1: The array summary","data":{"requirements#Requirements":"Write a C++ program creates an array of N elements (N > 1 000 000).\nInitialize the array with random values at the beginning.\nCompute summary of the array using a regular for loop and calculate the time spent for the operation.\nCreate M threads to sum the same array with multiple threads, considering that every thread gets an equal portion to sum, except, maybe, the last one.\nWait for all the threads to complete and measure the time spent for summing the array using M threads.\nPrint the durations spent to sum the array with and without threads.\nNote that N and M variables should be passed to the program via command line arguments.","expected-result#Expected result":"The resulting application should be able to build and execute from command line as follows:\nand the command should print the output to the console as follows:\nThe final solution should contain a Makefile for the multi-stage build. The Makefile should also contain targets all and clean. It's recommended to have compiler and compiler flags to be declared as a Makefile variables. Alternatively, cmake could also be used instead of make."}},"/system-programming/tasks/threads/thread-pool":{"title":"TH-2: The thread pool implementation","data":{"requirements#Requirements":"Create a C++ library (shared object) that implements a simple thread pool\nThread pool should be implemented as a class called \"parallel_scheduler\"\nThread pool takes a capacity argument in the constructor as a maximum number of threads in the pool.\nThread pool defines a method run that takes as an input two arguments function and the argument.\nAll the functions given to the \"run\" method are enqueued and the thread pool should execute them as soon as any of its threads gets time.\nNext, another executable application is implemented to demonstrate the usage of the thread pool library.\nThe demonstration application should enqueue various functions for the execution (more than the capacity).\nThe module \"parallel_scheduler\" should be compiled as a shared library (parallel_scheduler.so) and should be linked with the demo application.","expected-result#Expected result":"The resulting application should be able to build and execute from command line as follows:\nThe final solution should contain a Makefile for the multi-stage build. The Makefile should also contain targets all and clean. It's recommended to have compiler and compiler flags to be declared as a Makefile variables. Alternatively, cmake could also be used instead of make."}},"/system-programming/topics":{"title":"Topics","data":{}},"/system-programming/topics/advanced-io":{"title":"Advanced File I/O","data":{"overview#Overview":"This week extends the foundation of Linux file I/O by exploring advanced file descriptor manipulation and low-level file positioning.\nStudents will learn how to duplicate file descriptors, control file behavior using fcntl, and manage files beyond simple read/write operations — including seeking, truncation, and sparse file handling.By the end of this week, students will have a complete understanding of how Linux manages file descriptors and how processes interact with files efficiently and flexibly.","key-concepts#Key Concepts":"","file-descriptor-duplication#File Descriptor Duplication":"dup() and dup2() system calls\nFile descriptor table and shared open file descriptions\nStandard output redirection example with dup2()\nRelationship between dup2() and shell redirection","file-positioning#File Positioning":"The lseek() system call: repositioning file offsets\nSeeking modes:\nSEEK_SET – from beginning\nSEEK_CUR – from current position\nSEEK_END – from end of file\nPractical uses: appending, measuring file size, random access","sparse-files-and-holes#Sparse Files and Holes":"Concept of holes (unallocated regions in files)\nCreating and inspecting sparse files\nComparing allocated and logical sizes\nSEEK_DATA and SEEK_HOLE (modern extensions for efficient traversal)","file-control-and-management#File Control and Management":"The fcntl() system call:\nDuplicating descriptors (F_DUPFD)\nManaging flags (FD_CLOEXEC, O_APPEND, O_NONBLOCK)\nTruncating files with ftruncate()\nRetrieving file information with fstat()","practice--lab#Practice / Lab":"","descriptor-duplication#Descriptor Duplication":"Redirect program output to files using file descriptor duplication.\nExplore descriptor inheritance and redirection behavior.","file-positioning-and-sparse-files#File Positioning and Sparse Files":"Create files with gaps using lseek() to demonstrate sparse allocation.\nCompare logical and physical file sizes using shell utilities.","file-control-and-metadata#File Control and Metadata":"Use fcntl() to retrieve and modify descriptor properties.\nTruncate and inspect file length using system utilities.","homework#Homework":"FS-4: Redirect standard input\nFS-5: Manaul append\nFS-10: Copy a file accounting holes","samples#Samples":"Redirect standard output and error\nCreate a file with holes\nDetect holes in the file","references--resources#References & Resources":"Required\nKerrisk, The Linux Programming Interface\nChapter 5: File I/O – Deeper Concepts\nChapter 6: Advanced File I/O\nRecommended\nUnderstanding Sparse Files (Red Hat)\nBeej’s Guide – File Descriptors\nLinux manual page - fcntl(2)\nLinux manual page - dup(2)\nLinux manual page - lseek(3p)\nlseek() in C/C++ to read the alternate nth byte and write it in another file","quiz-self-check#Quiz (Self-check)":"What happens to the file offset when a descriptor is duplicated?\nHow does dup2() differ from shell redirection?\nWhat is the difference between SEEK_END and SEEK_CUR?\nHow does a sparse file conserve storage space?\nWhat are the purposes of SEEK_DATA and SEEK_HOLE?\nWhat does FD_CLOEXEC accomplish in practice?","suggested-tools#Suggested Tools":"strace – observe system calls like dup2 and lseek\nls, du, stat – inspect logical and physical file properties\nhexdump – verify data placement within sparse files"}},"/system-programming/topics/basic-io":{"title":"System Calls and Basic File I/O","data":{"overview#Overview":"This week marks the beginning of direct interaction with the kernel.\nStudents will learn what a system call (syscall) is, how it bridges user space and kernel space, and how errors are communicated via errno.We then explore file descriptors, the foundation of Linux’s “everything is a file” philosophy, and practice with fundamental file-related system calls: creat, open, read, write, and close.","key-concepts#Key Concepts":"System Calls\nRole of syscalls in OS design\nUser mode vs. kernel mode\nInterrupts, traps, and context switching\nsyscall interface vs. library wrappers (glibc)\nError Handling\nReturn values (-1 convention)\nerrno global variable\nUsing perror() and strerror()\nFile Descriptors\nConcept of file descriptors (integers representing open files)\nStandard descriptors: stdin (0), stdout (1), stderr (2)\n“Everything is a file” in Unix: devices, pipes, sockets\nEssential File System Calls\ncreat(), open(), read(), write(), close()\nFlags: O_RDONLY, O_WRONLY, O_RDWR, O_CREAT, O_APPEND, etc.\nPermissions and the umask effect\nDifferences between system calls and stdio (fopen, fread, etc.)","practice--lab#Practice / Lab":"Syscall Tracing\nUse strace ls to observe syscalls in action\nIdentify open, read, write, close in the trace\nError Handling\nWrite a C program to open a non-existent file, print error with perror\nFile I/O Basics\nWrite a program that:\nCreates a file with creat()\nWrites a string to it with write()\nReads it back with read() and prints to stdout\nCloses the file descriptor","homework#Homework":"FS-1: Read from the file\nFS-2: Copy a file\nFS-3: Secure file deletion","references--resources#References & Resources":"Required\nThe Linux Programming Interface – Kerrisk, Ch. 4–5: System Calls & File I/O\nFile Descriptor (Wiki)\nHandling a File by its Descriptor in C\nOS5 - File Descriptors, File Descriptor Table\nOptional\nBeej’s Guide to Unix IPC (intro chapters)\nLinux Syscalls Table\nLinux manual page - open(2)\nLinux manual page - creat(3p)\nLinux manual page - read(2)\nLinux manual page - write(2)\nLinux manual page - close(2)\nLinux manual page - fcntl(2)\nLinux manual page - errno(3)\nerrno – C library\nReading and Writing Files in C, two ways (fopen vs. open)\nTools\nstrace, errno, perror, man","quiz-self-check#Quiz (Self-check)":"What distinguishes a system call from a regular library function?\nWhich system calls are involved when reading a file from disk?\nWhat values are reserved for stdin, stdout, and stderr file descriptors?\nHow does errno get set, and how should you properly print its meaning?\nWhat is the difference between open and creat?"}},"/system-programming/topics/classical-sync-problems":{"title":"Classical Synchronization Problems","data":{"overview#Overview":"This week focuses on applying synchronization primitives to solve classical concurrency problems that appear in operating systems, parallel systems, and real-world software design.\nThrough hands-on examples, students will learn how mutexes, semaphores, and condition variables can coordinate multiple threads or processes to prevent race conditions and ensure correct execution order.","key-concepts#Key Concepts":"Purpose of Classical Problems\nServe as canonical models for understanding synchronization mechanisms.\nHelp develop reasoning about shared resources, fairness, and avoidance of deadlock or starvation.","producerconsumer-bounded-buffer#Producer–Consumer (Bounded Buffer)":"Scenario: Producers generate data and place it in a buffer; consumers remove and process it.\nChallenge: Prevent buffer overflow (too many producers) and underflow (too many consumers).\nSolution: Use semaphores or condition variables to control buffer state.\nDemonstrates: resource counting, mutual exclusion, condition signaling.","readerswriters-problem#Readers–Writers Problem":"Scenario: Multiple readers can access shared data simultaneously, but writers require exclusive access.\nChallenge: Avoid conflicts between readers and writers.\nSolution: Use reader/writer counters, semaphores, or RW locks.\nDemonstrates: fairness, reader/writer preference, starvation prevention.","dining-philosophers-problem#Dining Philosophers Problem":"Scenario: Philosophers seated around a table alternate between thinking and eating, each needing two forks.\nChallenge: Prevent deadlock (everyone waiting) and starvation (someone never eating).\nSolution: Control fork acquisition order or use semaphores for resource allocation.\nDemonstrates: deadlock prevention, resource hierarchy, symmetry breaking.","sleeping-barber-problem#Sleeping Barber Problem":"Scenario: A barber sleeps when no customers are waiting; customers wait if the barber is busy.\nChallenge: Synchronize waiting customers and barber’s state transitions.\nSolution: Semaphores for managing waiting chairs and signaling events.\nDemonstrates: event signaling, resource utilization, thread coordination.","samples#Samples":"Bounded Buffer (Producer and Consumer)\nDining Philosophers","references#References":"Operating Systems: Three Easy Pieces — Chapters “Synchronization Examples” and “Semaphores”\nModern Operating Systems — Andrew S. Tanenbaum, Chapter on “Processes and Threads”\nProgramming with POSIX Threads — David R. Butenhof, examples on coordination\npthreads(7)\nsem_overview(7)\nSynchronization problems overview (Wikipedia)","quiz-self-check#Quiz (Self-Check)":"What causes deadlock in the Dining Philosophers problem?\nHow can starvation occur in the Readers–Writers problem?\nWhich synchronization primitives can be used to solve the Producer–Consumer problem?\nIn the Sleeping Barber problem, what does each semaphore represent?\nWhy is fairness important in synchronization design?\nHow does symmetry breaking help in preventing deadlocks?"}},"/system-programming/topics/compilation":{"title":"The Compilation Process","data":{"overview#Overview":"This week introduces the compilation pipeline that turns source code into an executable program.\nStarting with a simple Hello World in C/C++, we’ll explore each step: preprocessing, compiling, assembling, and linking. Students will gain hands-on experience using gcc or g++ at each stage and learn how Makefiles automate the build process.By the end of this week, you should be able to manually trace the build process, understand the role of each stage, and create a simple Makefile for structured project builds.","key-concepts#Key Concepts":"Source code lifecycle: from .c or .cpp to executable binary\nStages of the compilation pipeline:\nPreprocessing (cpp): handling #include, #define, macros, conditional compilation\nCompilation: converting preprocessed code into assembly\nAssembling: turning assembly into object files (.o)\nLinking: combining object files and libraries into an executable\nUsing gcc or g++ to invoke each stage individually\nUnderstanding object files and executables with file, nm, objdump\nStatic vs. dynamic linking basics\nBuild automation: Makefiles, rules, targets, dependencies\nOther useful tools: make, pkg-config, ldd","practice--lab#Practice / Lab":"Hello World Compilation Steps:\nRun gcc -E hello.c -o hello.i (preprocessor)\nRun gcc -S hello.i -o hello.s (compiler → assembly)\nRun gcc -c hello.s -o hello.o (assembler → object file)\nRun gcc hello.o -o hello (linker → executable)\nExploring Artifacts:\nInspect .i, .s, .o and executable with less and file\nUse nm hello.o to list symbols\nUse objdump -d hello.o to view assembly\nMakefile Basics:\nWrite a simple Makefile with targets: all, clean\nPractice make, make clean, dependency tracking\nLinking Check:\nUse ldd hello to see linked libraries\nCompare static vs dynamic builds (gcc -static)","homework#Homework":"ENV-2: Complex numbers and sorting","guides#Guides":"Compilation and build process","references--resources#References & Resources":"Required\nGNU Compiler Collection (GCC) Documentation\nMake Manual (GNU Make)\nIntroduction to the Compilation Process (GeeksforGeeks)\nECE 252 Lecture 1: Our C Toolkit\nUnderstanding C and C++ compilation process\nC++: препроцессор, компилятор, компоновщик (RUS)\nThe C++ compilation model\nMemory Layout of C Program\nOptional\nThe Linux Programming Interface (Kerrisk) – Chapter 4: Program Execution\nLearn Makefiles by Example (GNU)\nobjdump, nm, and ldd Usage Guide (Tutorialspoint)\nCompiling with g++\nC Programming: Makefiles\nBegineer Makefile tutorial\nMakefile tutorial\n9 Essential GNU binutils tools\nCMake Tutorial EP 1 | Understanding The Basics\nTools\ngcc, cpp, as, ld\nmake, pkg-config, ldd, objdump, nm","quiz-self-check#Quiz (Self-check)":"What is the role of the preprocessor in compilation?\nWhat file extension is typically produced by the assembler?\nHow does static linking differ from dynamic linking?\nWhich tool is used to inspect the symbols inside an object file?\nWhy are Makefiles useful in larger projects?"}},"/system-programming/topics/intro":{"title":"Introduction to Unix and Linux","data":{"overview#Overview":"In this first week, we establish the foundation for system programming. Students will explore what an operating system is, how kernels are structured, and how Linux fits into the broader family of operating systems. We also introduce GNU/Linux distributions, the concept of free and open-source software, and the shell as the main interface to the system.By the end of this week, students will have a working Linux environment, a basic understanding of the command line, and an introduction to version control with Git and GitHub.","key-concepts#Key Concepts":"What is an operating system? Roles and responsibilities\nKernel vs. user space; system calls as the bridge\nKernel architectures: monolithic, microkernel, hybrid\nUnix lineage and Linux history (vs. Windows, macOS, BSD)\nGNU/Linux ecosystem: distributions and package managers\nThe shell: prompt, commands, redirection, and pipelines","practice--lab#Practice / Lab":"Set up a Virtual Machine: Install Ubuntu (or another Linux distribution) on VirtualBox/VMware.\nCommand Line Basics:\nRun and understand ls, cd, pwd, man, echo, cat\nTry redirection (>, >>) and pipelines (|)\nInstall software with apt or your distro’s package manager\nDevelopment Environment Setup: Install and test gcc, g++, make, and git. Configure an editor (e.g., VS Code or Vim).\nGit & GitHub Essentials: Initialize a local repo, make a commit, and push to GitHub.\nExploring Distributions: Find your kernel version (uname -a) and distro info (lsb_release -a). Compare Ubuntu, Fedora, Arch, Debian.","homework#Homework":"Complete task: ENV-1: Setup GNU/Linux Environment","references--resources#References & Resources":"Required\nOperating Systems (Wikipedia)\nKernel (Wikipedia)\nGNU/Linux Distributions\nOptional / Enrichment\nWhat is Kernel (Video)\nMicrokernel vs Monolithic Kernel (Video)\nLinux Distribution Timeline (Diagram)\nЭволюция вычислительных систем (RUS)\nTools\nDownload VirtualBox\nDownload Ubuntu\nInstall Ubuntu in VirtualBox (Video)\nGit and GitHub Basics (Video)","quiz-self-check#Quiz (Self-check)":"What is the difference between the kernel and user space?\nName two major differences between Linux and Windows.\nWhich shell command is used to find your current directory?\nWhat is the purpose of a package manager in Linux?"}},"/system-programming/topics/io-multiplexing":{"title":"I/O Multiplexing","data":{"overview#Overview":"This week introduces I/O multiplexing — the technique of monitoring multiple file descriptors simultaneously to determine which ones are ready for I/O, without blocking on any individual one.\nWhen building servers that handle many simultaneous connections, blocking on a single read() or accept() is not acceptable. I/O multiplexing solves this by letting the kernel notify your program when descriptors become ready.By the end of this week, students will understand the difference between blocking and non-blocking I/O, how each multiplexing interface works (select, poll, epoll), when to use each, and how to implement an event-driven server loop.","key-concepts#Key Concepts":"","blocking-vs-non-blocking-io#Blocking vs. Non-Blocking I/O":"By default, I/O system calls block until data is available or the operation completes\nA process blocked on accept() or recv() cannot handle any other descriptor\nNon-blocking mode makes calls return immediately with EAGAIN / EWOULDBLOCK when they would block\nSet non-blocking mode with fcntl():\nOr pass SOCK_NONBLOCK directly to socket():\nBusy-polling non-blocking FDs in a loop wastes CPU — multiplexing is the right solution","the-problem-multiple-file-descriptors#The Problem: Multiple File Descriptors":"A server may handle hundreds or thousands of simultaneous client connections\nNeither blocking (misses other clients) nor busy-polling (wastes CPU) is acceptable\nI/O multiplexing: register interest in a set of descriptors with the kernel; the kernel tells you which ones are ready\nYour program then only calls read() / write() on descriptors that are confirmed ready — the calls will not block\nThis is the foundation of event-driven / reactor-pattern servers","select--the-classic-interface-avoid-in-new-code#select() — The Classic Interface (Avoid in New Code)":"Monitors up to nfds file descriptors across three sets: readable, writable, exceptional conditions\nnfds must be the highest file descriptor number + 1\nReturns the total number of ready descriptors, 0 on timeout, -1 on error\nfd_set manipulation macros:\nMinimal example:\nWhy select() is not recommended:\nHard limit of FD_SETSIZE descriptors (typically 1024) — cannot be changed without recompiling\nThe fd_set must be rebuilt before every call (it is modified in place)\nRequires an O(n) scan over all descriptor positions on return to find which ones fired\nPoor scalability — performance degrades as descriptor count grows\nOnly use select() when portability to very old or non-Linux systems is required","poll--a-better-select-portable-fallback#poll() — A Better select() (Portable Fallback)":"Accepts an array of pollfd structures instead of bit sets:\nCommon event flags:\nPOLLIN — data available to read\nPOLLOUT — space available to write\nPOLLERR — error condition\nPOLLHUP — hangup (peer closed connection)\nPOLLRDHUP — peer shut down writing half (Linux extension)\ntimeout: milliseconds to wait (-1 = block forever, 0 = return immediately)\nReturns number of pollfd entries with non-zero revents, 0 on timeout\nMinimal example:\npoll() vs select():\nNo hard FD limit (just allocate a larger array)\nNo need to rebuild sets — only revents is overwritten, events is preserved\nStill O(n) — kernel and user both scan the entire array\nPOSIX standard, portable across Linux, macOS, BSDs\nUse poll() when you need portability across Unix-like systems; prefer epoll() on Linux","epoll--the-linux-high-performance-solution-use-this#epoll — The Linux High-Performance Solution (Use This)":"epoll is a Linux-specific interface designed for high-concurrency servers. Unlike select and poll, it does not require passing the entire monitored set on each call — the kernel maintains the set internally. Event notification is O(1) regardless of how many descriptors are registered.","creating-an-epoll-instance#Creating an epoll instance":"","adding-modifying-or-removing-descriptors#Adding, modifying, or removing descriptors":"op:\nEPOLL_CTL_ADD — start monitoring fd\nEPOLL_CTL_MOD — change events for fd\nEPOLL_CTL_DEL — stop monitoring fd\nepoll_event structure:","waiting-for-events#Waiting for events":"Blocks until one or more monitored descriptors become ready\nFills events array with only the ready descriptors — no scanning needed\nReturns the number of ready events; 0 on timeout; -1 on error","typical-epoll-server-loop#Typical epoll server loop":"","level-triggered-vs-edge-triggered#Level-triggered vs. Edge-triggered":"Level-triggered (LT) — default:\nepoll_wait keeps returning the event as long as the condition holds (e.g., data still in buffer)\nEasier to use correctly; you can read partial data and pick up next iteration\nWorks with blocking and non-blocking descriptors\nEdge-triggered (ET) — EPOLLET flag:\nNotified only when the state changes (e.g., new data arrives)\nYou must drain the descriptor completely in one shot (loop until EAGAIN)\nRequires non-blocking descriptors (O_NONBLOCK)\nMore efficient (fewer wakeups) but more complex to implement correctly\nUse ET when you understand the draining requirement; LT is safer to start with","why-epoll-is-the-right-choice-for-linux#Why epoll is the right choice for Linux":"O(1) event delivery — scales to millions of connections\nNo need to re-register descriptors on each call\nSupports edge-triggered mode for maximum efficiency\nUsed internally by nginx, Redis, Node.js (libuv), and virtually every high-performance Linux server\nDefault choice for any new Linux server","io_uring--the-modern-async-interface-brief-introduction#io_uring — The Modern Async Interface (Brief Introduction)":"Introduced in Linux 5.1 (2019), io_uring takes a fundamentally different approach:\nUses two shared ring buffers between kernel and user space (submission queue + completion queue)\nOperations are submitted in bulk — dramatically fewer syscalls than epoll\nSupports network I/O, file I/O, and arbitrary I/O operations uniformly\nSupports true zero-copy and kernel-side polling modes\nHighest possible throughput for I/O-bound applications\nPractical notes:\nComplex API — use liburing to simplify usage\nStill actively evolving — new features added with each kernel version\nRequires Linux ≥ 5.1 (full feature set needs ≥ 5.10–6.x)\nNot yet the default choice; consider it for specialized high-throughput applications where epoll is a bottleneck\nProjects like io_uring-based servers (e.g., newer versions of nginx, Tokio in Rust) are beginning to adopt it","interface-comparison#Interface Comparison":"select\tpoll\tepoll\tio_uring\tFD limit\t1024 (FD_SETSIZE)\tUnlimited\tUnlimited\tUnlimited\tScalability\tO(n)\tO(n)\tO(1)\tO(1)\tPortability\tPOSIX\tPOSIX\tLinux only\tLinux only\tAPI complexity\tLow\tLow\tModerate\tHigh\tTriggered modes\tLevel\tLevel\tLevel + Edge\tAsync completion\tKernel set tracking\tNo\tNo\tYes\tYes\tRecommendation\tAvoid\tPortable fallback\tUse this\tSpecialized/future","the-event-driven-server-pattern-reactor#The Event-Driven Server Pattern (Reactor)":"A single event loop calls epoll_wait, dispatches to handlers based on ready FDs\nAll descriptors set to non-blocking — no call ever blocks\nEliminates thread-per-connection overhead (no context switching, no stack memory per connection)\nOne thread can serve tens of thousands of connections\nUsed by: nginx, Redis, HAProxy, Node.js (via libuv), Memcached","common-pitfalls#Common Pitfalls":"Forgetting to drain on edge-triggered epoll — missed events, stalled connection\nCalling blocking operations inside the event loop — blocks all connections\nNot handling EAGAIN / EWOULDBLOCK — crashing or incorrect logic on non-blocking FDs\nRebuilding fd_set every iteration with select() — common bug causing incorrect behavior\nUsing select() without checking the FD_SETSIZE limit — silent corruption for FD > 1023\nLeaking epoll descriptors — epoll_create1() returns an FD that must be close()d\nNot removing closed FDs from epoll — stale events, confusion (though kernel auto-removes on close())\nUsing EPOLLET with blocking sockets — undefined, must always pair with O_NONBLOCK","practice--lab#Practice / Lab":"","non-blocking-read#Non-Blocking Read":"Open a regular file or pipe with O_NONBLOCK.\nObserve EAGAIN behavior when no data is available.\nCompare behavior with blocking mode.","echo-server-with-poll#Echo Server with poll()":"Implement a TCP echo server using poll() to monitor the listening socket and all connected client sockets simultaneously.\nHandle new connections, incoming data, and disconnections in a single loop.","echo-server-with-epoll#Echo Server with epoll()":"Rewrite the poll()-based server using epoll() with level-triggered mode.\nAdd all connected client sockets to the epoll instance.\nBenchmark both versions with many simultaneous clients.","edge-triggered-epoll#Edge-Triggered epoll":"Modify the epoll server to use EPOLLET.\nImplement the draining loop (read until EAGAIN).\nVerify correctness: no data should be lost or stuck between iterations.","timeout-handling#Timeout Handling":"Use the timeout parameter of poll() or epoll_wait() to implement periodic tasks (e.g., connection keep-alive checks) alongside I/O event handling.","homework#Homework":"NET-2: Multiplexed Sqrt Server","samples#Samples":"Using select\nUsing poll\nUsing epoll","references--resources#References & Resources":"Required\nBeej's Guide to Network Programming — select() — approachable introduction\nKerrisk, The Linux Programming Interface\nChapter 63: Alternative I/O Models (select, poll, epoll, signal-driven I/O)\nStevens, Unix Network Programming, Volume 1 — Chapter 6: I/O Multiplexing\nepoll(7) — Linux man page — authoritative reference\nThe C10K Problem — historical context for why epoll was created\nRecommended\nLinux manual page - select(2)\nLinux manual page - poll(2)\nLinux manual page - epoll_create1(2)\nLinux manual page - epoll_ctl(2)\nLinux manual page - epoll_wait(2)\nLinux manual page - fcntl(2) — setting O_NONBLOCK\nIllustrative epoll tutorial (suchprogramming.com)\nio_uring and liburing (Kernel documentation) — Jens Axboe's overview paper\nliburing GitHub repository — helper library for io_uring\nEfficient IO with io_uring (lwn.net)","quiz-self-check#Quiz (Self-check)":"What is the difference between blocking and non-blocking I/O?\nWhat does EAGAIN mean when returned from a read() on a non-blocking descriptor?\nHow do you set a socket to non-blocking mode using fcntl()?\nWhy is busy-polling on non-blocking descriptors a bad idea?\nWhat is the fundamental problem that I/O multiplexing solves?\nWhat is the FD limit of select() and why is it a problem?\nWhy must the fd_set be rebuilt before every select() call?\nHow does poll() improve on select() in terms of descriptor limits?\nWhat does POLLIN indicate, and how do you check it after poll() returns?\nWhy does epoll scale better than select or poll as the number of connections grows?\nWhat is the difference between epoll_ctl() and epoll_wait()?\nExplain the difference between level-triggered and edge-triggered epoll.\nWhy must edge-triggered epoll be used with non-blocking file descriptors?\nWhat is the \"draining\" requirement in edge-triggered mode?\nWhat does the data field of struct epoll_event allow you to store, and why is it useful?\nWhat is io_uring and how does it differ from epoll?\nWhich interface would you choose for a new high-performance Linux server, and why?\nWhat is the Reactor pattern, and how does it relate to epoll?","suggested-tools#Suggested Tools":"strace — observe epoll_create, epoll_ctl, epoll_wait, poll, select syscalls\nss -s — summary of socket statistics\nnetstat -an — inspect connection states\nwrk / ab (Apache Bench) — HTTP load testing to stress-test servers\niperf3 — raw TCP throughput testing\nperf — profile event loop performance"}},"/system-programming/topics/networking":{"title":"Networking","data":{"overview#Overview":"This week introduces computer networking fundamentals — the essential concepts required to understand how data is transmitted across networks. Before diving into socket programming and network-based IPC, students must understand how networks are structured, how devices are identified, and how data travels from one machine to another.We will explore network topologies, the OSI reference model, and walk through each layer from the physical hardware up to application protocols. By the end of this week, students will understand IP addressing, routing, DNS, and the difference between TCP and UDP — laying the groundwork for implementing network communication in system programs.","key-concepts#Key Concepts":"","what-is-a-computer-network#What is a Computer Network?":"A network is a collection of interconnected devices that can exchange data\nNetworks enable resource sharing, communication, and distributed computing\nNetwork nodes: computers, servers, routers, switches, printers, IoT devices\nNetwork media: cables (copper, fiber), wireless (Wi-Fi, Bluetooth)\nThe Internet is a global network of networks","network-topologies#Network Topologies":"Bus topology: all devices share a single communication line\nStar topology: all devices connect to a central hub/switch\nRing topology: devices form a circular chain (data travels in one direction)\nMesh topology: devices interconnected (full or partial mesh)\nHybrid topology: combination of multiple topologies\nMost modern LANs use star topology with switches","the-osi-reference-model#The OSI Reference Model":"A conceptual framework for understanding network communication\nDivides networking into 7 layers, each with specific responsibilities\nEach layer provides services to the layer above and uses services from the layer below\nEnables interoperability between different vendors and technologies\nProtocol Data Units (PDUs): data is encapsulated at each layer\nLayer\tName\tPDU\tFunction\t7\tApplication\tData\tUser interface, application services\t6\tPresentation\tData\tData formatting, encryption, compression\t5\tSession\tData\tSession management, dialog control\t4\tTransport\tSegment\tEnd-to-end communication, reliability\t3\tNetwork\tPacket\tLogical addressing, routing\t2\tData Link\tFrame\tPhysical addressing, error detection\t1\tPhysical\tBits\tPhysical transmission of raw bits","layer-1-physical-layer#Layer 1: Physical Layer":"","responsibilities#Responsibilities":"Transmission of raw bit streams over physical medium\nDefines electrical, mechanical, and timing specifications\nHandles encoding/decoding of bits into signals (electrical, optical, radio)","physical-media#Physical Media":"Copper cables:\nCoaxial cable (legacy)\nTwisted pair: Cat5, Cat5e, Cat6, Cat6a (Ethernet)\nFiber optic cables:\nSingle-mode (long distance)\nMulti-mode (shorter distance, data centers)\nWireless:\nWi-Fi (IEEE 802.11 standards)\nBluetooth, cellular (4G/5G)","layer-1-devices#Layer 1 Devices":"Hubs: broadcast data to all ports (obsolete, replaced by switches)\nRepeaters: amplify signals to extend network range\nNetwork Interface Cards (NICs): connect computers to network media\nModems: modulate/demodulate signals for transmission","layer-2-data-link-layer#Layer 2: Data Link Layer":"","responsibilities-1#Responsibilities":"Framing: encapsulating network layer packets into frames\nPhysical addressing: using MAC addresses to identify devices\nError detection: detecting transmission errors (CRC checksums)\nMedia access control: managing access to shared medium (CSMA/CD, CSMA/CA)","mac-addresses#MAC Addresses":"Media Access Control (MAC) address — unique hardware identifier\n48-bit address, typically written as 6 pairs of hex digits: 00:1A:2B:3C:4D:5E\nFirst 24 bits: OUI (Organizationally Unique Identifier) — identifies manufacturer\nLast 24 bits: device-specific identifier\nMAC addresses are burned into network interface hardware (but can be spoofed)\nUsed for local network communication (within the same LAN segment)","layer-2-devices#Layer 2 Devices":"Switches: forward frames based on MAC addresses (MAC address table)\nBridges: connect network segments (largely replaced by switches)\nWireless Access Points (WAPs): bridge wireless and wired networks","ethernet-ieee-8023#Ethernet (IEEE 802.3)":"The dominant LAN technology\nDefines frame format, addressing, and media access methods\nModern Ethernet uses full-duplex communication with switches (no collisions)\nSpeeds: 10 Mbps → 100 Mbps → 1 Gbps → 10 Gbps → 100 Gbps","layer-3-network-layer#Layer 3: Network Layer":"","responsibilities-2#Responsibilities":"Logical addressing: assigning IP addresses to devices\nRouting: determining the best path for packets across networks\nPacket forwarding: moving packets from source to destination\nFragmentation: breaking large packets into smaller ones if needed","ip-internet-protocol#IP (Internet Protocol)":"The core protocol of the Internet\nProvides connectionless, best-effort delivery (no guarantees)\nTwo versions in use: IPv4 (most common) and IPv6 (growing adoption)","ipv4-addresses#IPv4 Addresses":"32-bit address, written as four decimal octets: 192.168.1.100\nAddress space: 2³² = ~4.3 billion addresses (exhausted)\nAddress classes (historical):\nClass A: 1.0.0.0 – 126.255.255.255 (large networks)\nClass B: 128.0.0.0 – 191.255.255.255 (medium networks)\nClass C: 192.0.0.0 – 223.255.255.255 (small networks)\nModern approach: CIDR (Classless Inter-Domain Routing)","subnetting-and-cidr#Subnetting and CIDR":"Subnet mask: defines which portion of IP is network vs. host\nExample: 255.255.255.0 or /24 — first 24 bits are network\nNetwork address: identifies the subnet (host bits = 0)\nBroadcast address: reaches all hosts in subnet (host bits = 1)\nExample: 192.168.1.0/24\nNetwork: 192.168.1.0\nHosts: 192.168.1.1 – 192.168.1.254\nBroadcast: 192.168.1.255","private-vs-public-ip-addresses#Private vs Public IP Addresses":"Private addresses: not routable on the Internet (used in LANs)\n10.0.0.0/8 — Class A private\n172.16.0.0/12 — Class B private\n192.168.0.0/16 — Class C private\nPublic addresses: globally unique, routable on the Internet\nNAT (Network Address Translation): allows private IPs to access Internet via a single public IP","special-ip-addresses#Special IP Addresses":"127.0.0.1 — loopback (localhost, refers to the local machine)\n0.0.0.0 — \"any\" address (used by servers to listen on all interfaces)\n255.255.255.255 — limited broadcast (local network broadcast)","dhcp-dynamic-host-configuration-protocol#DHCP (Dynamic Host Configuration Protocol)":"Automatically assigns IP addresses to devices on a network\nDHCP server manages a pool of available addresses\nDHCP lease process:\nDiscover: client broadcasts request for IP\nOffer: server offers an available IP\nRequest: client requests the offered IP\nAcknowledge: server confirms the assignment\nAlso provides: subnet mask, default gateway, DNS servers","routing#Routing":"Routers connect different networks and forward packets between them\nRouting table: maps destination networks to next-hop routers\nDefault gateway: router used when no specific route matches\nRouting protocols:\nStatic routing (manually configured)\nDynamic routing: RIP, OSPF, BGP (automatic route discovery)\nHops: each router a packet passes through is one hop\nUse traceroute (Linux) / tracert (Windows) to see the path","layer-3-devices#Layer 3 Devices":"Routers: forward packets based on IP addresses\nLayer 3 switches: switches with routing capabilities","ipv6-brief-overview#IPv6 (Brief Overview)":"128-bit addresses: vastly larger address space (3.4 × 10³⁸)\nWritten in hexadecimal: 2001:0db8:85a3:0000:0000:8a2e:0370:7334\nSimplified notation: 2001:db8:85a3::8a2e:370:7334\nNo NAT required (enough addresses for every device)\nBuilt-in security (IPsec), better multicast support","layer-4-transport-layer#Layer 4: Transport Layer":"","responsibilities-3#Responsibilities":"End-to-end communication between applications on different hosts\nSegmentation: breaking data into segments\nMultiplexing: multiple applications sharing network via ports\nReliability (optional): ensuring data arrives correctly and in order","ports#Ports":"16-bit number (0–65535) identifying a specific application/service\nCombined with IP address forms a socket: IP:port (e.g., 192.168.1.100:8080)\nWell-known ports (0–1023): reserved for standard services\nHTTP: 80, HTTPS: 443, SSH: 22, FTP: 21, SMTP: 25, DNS: 53\nRegistered ports (1024–49151): assigned to specific applications\nDynamic/private ports (49152–65535): used by client applications","tcp-transmission-control-protocol#TCP (Transmission Control Protocol)":"Connection-oriented: establishes connection before data transfer\nReliable delivery: guarantees all data arrives correctly and in order\nFlow control: prevents sender from overwhelming receiver\nCongestion control: adapts to network conditions\nThree-way handshake (connection establishment):\nClient → Server: SYN (synchronize)\nServer → Client: SYN-ACK (synchronize-acknowledge)\nClient → Server: ACK (acknowledge)\nFour-way termination: FIN → ACK → FIN → ACK\nUse cases: web browsing, email, file transfer, SSH","udp-user-datagram-protocol#UDP (User Datagram Protocol)":"Connectionless: no connection establishment\nUnreliable: no guarantee of delivery, order, or duplicate protection\nLow overhead: minimal protocol headers\nFast: no handshake, no waiting for acknowledgments\nUse cases: DNS queries, video streaming, online gaming, VoIP\nApplications handle reliability if needed","tcp-vs-udp-comparison#TCP vs UDP Comparison":"Feature\tTCP\tUDP\tConnection\tConnection-oriented\tConnectionless\tReliability\tGuaranteed delivery\tBest-effort\tOrdering\tMaintains order\tNo ordering\tSpeed\tSlower (overhead)\tFaster (minimal overhead)\tFlow Control\tYes\tNo\tUse Cases\tHTTP, FTP, SSH, Email\tDNS, Streaming, Gaming","layers-5--6-session-and-presentation#Layers 5 & 6: Session and Presentation":"","layer-5-session-layer#Layer 5: Session Layer":"Manages sessions (ongoing conversations) between applications\nHandles session establishment, maintenance, and termination\nDialog control: determines who can transmit (half-duplex, full-duplex)\nSynchronization: checkpoints for resuming interrupted transfers\nIn practice, often handled by application layer protocols","layer-6-presentation-layer#Layer 6: Presentation Layer":"Data format translation: converting between different data formats\nEncryption/Decryption: securing data (e.g., TLS/SSL)\nCompression/Decompression: reducing data size\nCharacter encoding: ASCII, UTF-8, EBCDIC\nExamples: JPEG, GIF, MPEG encoding; TLS encryption\nNote: In the TCP/IP model, Layers 5–7 are often combined into a single Application Layer.","layer-7-application-layer#Layer 7: Application Layer":"","responsibilities-4#Responsibilities":"Provides network services directly to end-users and applications\nImplements application protocols for specific services\nInterfaces with user applications (browsers, email clients, etc.)","dns-domain-name-system#DNS (Domain Name System)":"Translates domain names (e.g., google.com) to IP addresses\nHierarchical distributed database\nDNS hierarchy:\nRoot servers (.)\nTop-level domains (TLDs): .com, .org, .net, country codes\nSecond-level domains: google.com, github.com\nSubdomains: mail.google.com\nDNS query process:\nClient queries local DNS resolver\nResolver queries root server → TLD server → authoritative server\nIP address returned to client\nDNS record types:\nA: IPv4 address mapping\nAAAA: IPv6 address mapping\nCNAME: canonical name (alias)\nMX: mail exchange servers\nNS: name servers\nTools: nslookup, dig, host","httphttps-web#HTTP/HTTPS (Web)":"HyperText Transfer Protocol — foundation of the World Wide Web\nRequest-response model: client sends request, server returns response\nHTTP methods: GET, POST, PUT, DELETE, PATCH, etc.\nHTTPS: HTTP over TLS/SSL (encrypted, secure)\nDefault ports: HTTP (80), HTTPS (443)","other-application-layer-protocols#Other Application Layer Protocols":"FTP (File Transfer Protocol): file transfer (ports 20, 21)\nSMTP (Simple Mail Transfer Protocol): sending email (port 25)\nPOP3/IMAP: receiving email (ports 110, 143)\nSSH (Secure Shell): secure remote access (port 22)\nTelnet: unencrypted remote access (port 23, legacy)\nSNMP: network management (ports 161, 162)\nNTP: time synchronization (port 123)","tcpip-protocol-stack#TCP/IP Protocol Stack":"","osi-vs-tcpip-model#OSI vs TCP/IP Model":"The TCP/IP model (also called the Internet model) is a simplified, practical model used for the Internet:\nTCP/IP Layer\tOSI Layers\tProtocols\tApplication\t7, 6, 5\tHTTP, HTTPS, FTP, SMTP, DNS, SSH\tTransport\t4\tTCP, UDP\tInternet\t3\tIP, ICMP, ARP\tNetwork Access\t2, 1\tEthernet, Wi-Fi, PPP","key-differences#Key Differences":"TCP/IP has 4 layers vs OSI's 7\nTCP/IP is protocol-specific (describes actual Internet protocols)\nOSI is conceptual (vendor-neutral reference model)\nTCP/IP combines Session, Presentation, Application into one layer\nTCP/IP combines Physical and Data Link into Network Access layer","arp-address-resolution-protocol#ARP (Address Resolution Protocol)":"Maps IP addresses to MAC addresses\nWhen sending to a local host, ARP finds the corresponding MAC\nARP request: \"Who has IP X? Tell me your MAC\"\nARP reply: \"I have IP X, my MAC is Y\"\nARP cache stores recent mappings (arp -a to view)","icmp-internet-control-message-protocol#ICMP (Internet Control Message Protocol)":"Network diagnostics and error reporting\nUsed by ping (echo request/reply)\nUsed by traceroute (TTL exceeded messages)\nError messages: destination unreachable, time exceeded, etc.","practice--lab#Practice / Lab":"","exploring-network-configuration#Exploring Network Configuration":"Use ip addr (or ifconfig) to view network interfaces and IP addresses\nUse ip route to view the routing table and default gateway\nIdentify your MAC address with ip link or ifconfig\nCheck DHCP lease information in /var/lib/dhcp/","dns-resolution#DNS Resolution":"Use nslookup or dig to query DNS records for various domains\nTrace the DNS resolution process with dig +trace google.com\nView your DNS servers in /etc/resolv.conf\nExamine /etc/hosts for local hostname mappings","testing-connectivity#Testing Connectivity":"Use ping to test reachability to local and remote hosts\nUse traceroute to view the path packets take to a destination\nObserve how many hops and latency vary for different destinations","inspecting-network-traffic#Inspecting Network Traffic":"Use ss or netstat to view active connections and listening ports\nIdentify TCP vs UDP connections\nSee which ports your system is listening on (ss -tuln)","tcp-three-way-handshake#TCP Three-Way Handshake":"Use tcpdump or Wireshark to capture TCP connection establishment\nObserve SYN, SYN-ACK, ACK packets\nCapture and analyze HTTP traffic","arp-and-mac-addresses#ARP and MAC Addresses":"View the ARP cache with arp -a or ip neigh\nObserve ARP requests/replies with tcpdump -n arp","homework#Homework":"(Socket programming tasks will be assigned after the Sockets topic)","references--resources#References & Resources":"Required\nComputer Networks Crash Course (Video)\nOSI Model Explained (Video)\nTCP/IP Model vs OSI Model\nIP Addresses and Subnetting\nTCP vs UDP Comparison\nHow DNS Works (Video)\nRecommended\nBeej's Guide to Network Programming — excellent resource for socket programming\nRFC 791: Internet Protocol — official IP specification\nRFC 793: Transmission Control Protocol — official TCP specification\nRFC 768: User Datagram Protocol — official UDP specification\nComputer Networking: A Top-Down Approach — Kurose & Ross textbook\nStevens, Unix Network Programming, Volume 1: The Sockets Networking API\nNetworking Fundamentals (IBM)\nTools Documentation\nLinux manual page - ip(8)\nLinux manual page - ss(8)\nLinux manual page - ping(8)\nLinux manual page - traceroute(8)\nLinux manual page - tcpdump(8)","quiz-self-check#Quiz (Self-check)":"What are the 7 layers of the OSI model? Name them in order from bottom to top.\nWhat is the difference between a MAC address and an IP address?\nAt which OSI layer do switches operate? What about routers?\nWhat is the purpose of subnetting, and how does a subnet mask work?\nExplain the difference between private and public IP addresses.\nWhat is DHCP, and what information does it provide to clients?\nDescribe the TCP three-way handshake process.\nWhen would you choose UDP over TCP?\nWhat is the role of DNS in networking?\nWhat is NAT, and why is it commonly used?\nWhat is the difference between the OSI and TCP/IP models?\nWhat is ARP, and why is it necessary?\nWhat well-known port numbers are used by HTTP, HTTPS, and SSH?\nHow does traceroute work?\nWhat happens when you type google.com in your browser? (Describe the network flow)","suggested-tools#Suggested Tools":"ip — modern tool for network configuration (ip addr, ip route, ip link)\nifconfig — legacy tool for network interface configuration\nping — test network connectivity using ICMP\ntraceroute / tracepath — trace packet route to destination\nnslookup / dig / host — DNS lookup tools\nss / netstat — display socket statistics and connections\narp — view and manipulate ARP cache\ntcpdump — command-line packet analyzer\nwireshark — GUI packet analyzer (excellent for learning)\ncurl / wget — command-line HTTP clients\nnc (netcat) — versatile networking utility for testing"}},"/system-programming/topics/pipes":{"title":"Pipes and FIFOs","data":{"overview#Overview":"This week introduces pipes as a fundamental mechanism for inter-process communication in Unix/Linux systems.\nStudents will learn about anonymous pipes (unnamed pipes) for communication between related processes, and named pipes (FIFOs) for communication between unrelated processes. We will explore how data flows through pipes, their characteristics, and the system calls used to create and manage them.By the end of this week, students will understand how to use pipes for process communication, the differences between anonymous and named pipes, and when to use each type.","key-concepts#Key Concepts":"","what-are-pipes#What are Pipes?":"Pipes as unidirectional byte streams for IPC\nProducer-consumer model: one process writes, another reads\nPipes as the foundation of Unix philosophy (\"do one thing well\")\nShell pipes (|) connecting command outputs to inputs","pipe-characteristics#Pipe Characteristics":"Unidirectional data flow: one-way communication channel\nByte stream: no message boundaries, continuous stream of bytes\nBuffered I/O: kernel maintains a buffer (typically 64KB on Linux)\nBlocking behavior:\nread() blocks if pipe is empty\nwrite() blocks if pipe buffer is full\nAutomatic synchronization: kernel handles coordination between reader and writer\nEOF condition: read() returns 0 when all write ends are closed","anonymous-pipes-unnamed-pipes#Anonymous Pipes (Unnamed Pipes)":"Created with pipe() system call\nReturns two file descriptors: fd[0] for reading, fd[1] for writing\nCommunication between related processes (parent-child via fork())\nFile descriptors inherited by child processes\nTypical workflow:\nParent creates pipe with pipe()\nParent forks child process\nBoth close unused ends (parent closes read end if writing, etc.)\nProcesses communicate via read() and write()\nClose all pipe ends when done","named-pipes-fifos#Named Pipes (FIFOs)":"Created with mkfifo() system call or mkfifo command\nExist as special files in the filesystem (ls -l shows p type)\nEnable communication between unrelated processes\nPersist in the filesystem until explicitly removed\nOpened with standard open() call\nMultiple readers and writers possible (but data interleaving may occur)\nOpening behavior:\nopen() for reading blocks until a writer opens the FIFO\nopen() for writing blocks until a reader opens the FIFO\nUse O_NONBLOCK flag to prevent blocking on open","bidirectional-communication#Bidirectional Communication":"Single pipe provides one-way communication\nFor bidirectional communication: create two pipes\nPipe 1: parent → child\nPipe 2: child → parent\nEach process closes the ends it doesn't use","common-patterns-and-best-practices#Common Patterns and Best Practices":"Always close unused pipe ends to avoid deadlocks and resource leaks\nCheck return values of pipe(), read(), write(), and close()\nHandle SIGPIPE signal (sent when writing to a pipe with no readers)\nUse select(), poll(), or epoll() for non-blocking I/O on multiple pipes\nBe aware of pipe buffer size limits (use fcntl() with F_GETPIPE_SZ)","practice--lab#Practice / Lab":"","anonymous-pipes-parent-child-communication#Anonymous Pipes: Parent-Child Communication":"Write a program where a parent creates a pipe, forks a child, and sends a message to the child.\nHave the child read from the pipe and print the message.\nEnsure both processes close unused pipe ends.","bidirectional-communication-1#Bidirectional Communication":"Create two pipes for bidirectional communication between parent and child.\nParent sends a number to child; child squares it and sends back the result.","command-pipeline-implementation#Command Pipeline Implementation":"Implement a simplified version of shell piping: command1 | command2\nUse pipe(), fork(), dup2(), and exec() to redirect output/input.","named-pipes-fifos-1#Named Pipes (FIFOs)":"Create a FIFO using mkfifo() in one program.\nWrite a sender program that opens the FIFO and writes messages.\nWrite a receiver program that opens the FIFO and reads messages.\nRun sender and receiver as separate processes and observe communication.","exploring-pipe-limits#Exploring Pipe Limits":"Write to a pipe without reading to observe blocking behavior when buffer fills.\nUse ulimit -p or /proc/sys/fs/pipe-max-size to inspect pipe buffer sizes.","homework#Homework":"IPC-2: Prime Calculator","references--resources#References & Resources":"Required\nPipes in C programming\nUnix Pipes Explained\nNamed Pipes (FIFOs) in Linux\nPipe, Fork and Exec\nPipes in Linux (GeeksforGeeks)\nKerrisk, The Linux Programming Interface\nChapter 44: Pipes and FIFOs\nAdvanced Programming in the UNIX Environment — W. Richard Stevens, Chapter 15 \"Interprocess Communication\"\nRecommended\nLinux manual page - pipe(2)\nLinux manual page - mkfifo(3)\nLinux manual page - fifo(7)\nLinux manual page - dup2(2)\nUnderstanding Pipes in Unix\nNamed Pipes (IBM Developer)\nPipe Implementation in Linux Kernel\nHow Unix Pipes Are Implemented (LWN.net)","quiz-self-check#Quiz (Self-check)":"What is the difference between anonymous pipes and named pipes (FIFOs)?\nWhy must unused pipe ends be closed in both parent and child processes?\nWhat happens when you try to write to a pipe that has no readers?\nHow does pipe() communicate the file descriptors to the caller?\nWhat is the typical size of a pipe buffer in Linux?\nHow can you implement bidirectional communication using pipes?\nWhen would you use a FIFO instead of an anonymous pipe?\nWhat does read() return when all write ends of a pipe are closed?\nWhat flag can you use to prevent open() from blocking when opening a FIFO?\nHow do shell pipelines like ls | grep txt | wc -l work internally?","suggested-tools#Suggested Tools":"mkfifo — create named pipes from the command line\nls -l — identify FIFOs (shown as type p)\ncat — read from or write to FIFOs for testing\nstrace — trace pipe(), read(), write() system calls\nlsof — list open file descriptors including pipes\npv — pipe viewer for monitoring data flow through pipes\ntee — read from stdin and write to both stdout and files"}},"/system-programming/topics/processes":{"title":"Processes","data":{"overview#Overview":"This week introduces the process model — the fundamental abstraction for executing programs in an operating system.\nStudents will learn how processes are created, how they relate to one another, and how Linux represents and manages them.\nWe will also briefly explore virtual memory and its role in isolating processes, followed by the main system calls for creating and controlling processes.By the end of this week, students will understand how programs become running processes, how parent and child processes interact, and how process management underpins multitasking in Linux.","key-concepts#Key Concepts":"","what-is-a-process#What is a Process?":"A process as an executing program instance\nProcess attributes: PID, state, program counter, registers, open files\nProcess lifecycle: creation → execution → termination\nRelationship between programs and processes\nContext switching overview","virtual-memory-brief-overview#Virtual Memory (Brief Overview)":"Concept of process isolation\nLogical vs physical address spaces\nPaging: mapping memory in fixed-size blocks (pages)\nRole of MMU and page tables (at a high level)\nHow virtual memory supports multitasking and protection","process-hierarchy-and-inheritance#Process Hierarchy and Inheritance":"The process tree: init/systemd as ancestor of all processes\nParent and child relationships\nInheritance of environment variables and file descriptors\nProcess groups and sessions","process-creation-and-execution#Process Creation and Execution":"fork() — duplicating the current process\nReturn semantics of fork() (0 in child, PID in parent)\nexec() family — replacing the current process image\ngetpid(), getppid() — identifying process lineage\nwait() and waitpid() — synchronizing process termination\nZombies and orphan processes","practice--lab#Practice / Lab":"","exploring-the-process-tree#Exploring the Process Tree":"Use shell tools (ps, pstree, top, htop) to inspect running processes.\nIdentify parent-child relationships and PIDs.\nObserve behavior when starting background jobs (&) and pipelines.","process-creation#Process Creation":"Write a simple program that spawns child processes using fork().\nObserve execution order and differences in PID and PPID.","executing-new-programs#Executing New Programs":"Use exec() to replace a process image and observe that it does not return.\nCombine fork() and exec() to launch external commands from your program.","process-synchronization#Process Synchronization":"Use wait() and waitpid() to ensure orderly termination of child processes.\nObserve zombie processes when a parent does not wait.","homework#Homework":"PS-1: Do command\nPS-2: Interactive shell","samples#Samples":"Creating a process","references--resources#References & Resources":"Required\nECE 252 Lecture 4: Processes\nECE 252 Lecture 5: Processes in UNIX\nThe Exec Family of Functions\nThe fork function in C\nWaiting for processes to finish in C\nKerrisk, The Linux Programming Interface\nChapter 24: Process Creation\nChapter 25: Process Termination\nChapter 26: Executing Programs\nRecommended\nLinux manual page - fork(2)\nLinux manual page - wait(2)\nLinux manual page - clone(2)\nLinux manual page - exec(3)\nExample of fork() in C\nFork System Call in Operating System\nLinux Processes and Threads (IBM Developer)\nUnderstanding fork() and exec() (GeeksforGeeks)\nThe Process Tree (Red Hat Docs)","quiz-self-check#Quiz (Self-check)":"What is the difference between a program and a process?\nWhat does virtual memory achieve in process isolation?\nWhat are the main differences between fork() and exec()?\nWhat is inherited by a child process after fork()?\nWhat happens if a parent process never calls wait()?\nWhat is a zombie process, and how is it removed?\nHow do getpid() and getppid() relate within a process tree?","suggested-tools#Suggested Tools":"ps, pstree, top, htop – inspect running processes\nstrace – trace fork, exec, wait system calls\npmap – display memory map of a process\nlsof – list open files for a given process"}},"/system-programming/topics/shared-memory":{"title":"Shared Memory","data":{"overview#Overview":"This week introduces shared memory as a high-performance mechanism for inter-process communication in Unix/Linux systems.\nStudents will learn about memory-mapped I/O (mmap), POSIX shared memory (shm_open, shm_unlink), and System V shared memory (shmget, shmat, shmdt) as different approaches to sharing memory regions between processes. We will explore the advantages, use cases, and synchronization requirements for shared memory.By the end of this week, students will understand how to create and manage shared memory segments, the differences between POSIX and System V approaches, and how to synchronize access to shared data.","key-concepts#Key Concepts":"","what-is-shared-memory#What is Shared Memory?":"Shared memory as the fastest IPC mechanism (no data copying between processes)\nDirect memory access without kernel intervention after setup\nMultiple processes mapping the same physical memory region into their address spaces\nRequires explicit synchronization (semaphores, mutexes, etc.) to avoid race conditions\nUse cases: high-performance computing, database systems, multimedia applications","memory-mapped-io-mmap#Memory-Mapped I/O (mmap)":"mmap() — map files or devices into memory\nVirtual memory technique: file contents accessible via pointer operations\nChanges to mapped region automatically reflected in the file (for file-backed mappings)\nAnonymous mappings (MAP_ANONYMOUS): not backed by any file, used for shared memory\nShared vs. Private mappings:\nMAP_SHARED — changes visible to other processes\nMAP_PRIVATE — copy-on-write, changes private to the process\nMemory protection flags: PROT_READ, PROT_WRITE, PROT_EXEC, PROT_NONE\nmunmap() — unmap memory region\nmsync() — synchronize mapped region with underlying file","posix-shared-memory-recommended-modern-approach#POSIX Shared Memory (Recommended Modern Approach)":"Creating shared memory objects:\nshm_open() — create/open a shared memory object (lives in /dev/shm/)\nReturns a file descriptor (POSIX compliant)\nftruncate() — set the size of the shared memory object\nmmap() — map the object into process address space\nRemoving shared memory:\nshm_unlink() — remove shared memory object (similar to unlink() for files)\nAdvantages:\nSimpler API using file descriptors\nIntegrates well with POSIX standards\nCan use with select(), poll(), epoll()\nAutomatic cleanup when all references are closed (if unlinked)","system-v-shared-memory-legacy-but-still-widely-used#System V Shared Memory (Legacy but Still Widely Used)":"Creating and accessing:\nshmget() — create or get a shared memory segment using a key\nKeys generated with ftok() or using IPC_PRIVATE\nshmat() — attach shared memory segment to process address space\nshmdt() — detach shared memory segment\nManaging and removing:\nshmctl() — control operations (get info, set permissions, remove)\nIPC_RMID flag to mark segment for removal\nSegments persist until explicitly removed or system reboot\nTools for inspection:\nipcs — display information about IPC facilities\nipcrm — remove IPC resources\nLimitations:\nMore complex API with keys and IDs\nNo automatic cleanup (segments persist)\nNot file descriptor based","synchronization-requirements#Synchronization Requirements":"Race conditions: multiple processes accessing shared memory simultaneously\nCritical sections: code that accesses shared data must be protected\nSynchronization primitives required:\nPOSIX semaphores (sem_open(), sem_wait(), sem_post())\nSystem V semaphores (semget(), semop(), semctl())\nProcess-shared mutexes (with PTHREAD_PROCESS_SHARED attribute)\nFile locking (fcntl(), flock())\nShared memory itself provides no synchronization — must be explicitly managed","posix-vs-system-v-comparison#POSIX vs System V Comparison":"Feature\tPOSIX Shared Memory\tSystem V Shared Memory\tAPI Style\tFile descriptor based\tKey and ID based\tCreation\tshm_open() + mmap()\tshmget() + shmat()\tRemoval\tshm_unlink()\tshmctl(IPC_RMID)\tPersistence\tRemoved when unlinked\tPersists until removed\tIntegration\tWorks with poll(), etc.\tSeparate API\tPortability\tModern POSIX systems\tWidely available (legacy)\tRecommended\t✅ Yes (modern approach)\t⚠️ Legacy (but still used)","practice--lab#Practice / Lab":"","memory-mapped-file-io#Memory-Mapped File I/O":"Create a file and use mmap() to map it into memory.\nModify the file contents by writing to the mapped memory region.\nVerify changes persist after munmap() and program termination.","posix-shared-memory#POSIX Shared Memory":"Write two programs: a writer and a reader.\nWriter creates shared memory with shm_open(), sizes it with ftruncate(), maps it with mmap(), and writes data.\nReader opens the same shared memory object, maps it, and reads the data.\nUse shm_unlink() to clean up.","system-v-shared-memory#System V Shared Memory":"Implement the same writer/reader pattern using shmget() and shmat().\nUse ftok() to generate a key from a file path.\nInspect shared memory segments with ipcs -m.\nClean up with shmctl() or ipcrm.","synchronized-shared-memory-access#Synchronized Shared Memory Access":"Create a shared counter in shared memory.\nLaunch multiple processes that increment the counter.\nFirst, observe race conditions without synchronization.\nThen, add POSIX semaphores (sem_open()) to protect the critical section.","performance-comparison#Performance Comparison":"Compare data transfer rates between:\nShared memory (direct access)\nPipes (kernel-mediated)\nFiles (disk I/O)\nMeasure and observe the performance differences.","homework#Homework":"IPC-3: Shared Array","references--resources#References & Resources":"Required\nMemory-mapped Files in Linux\nShared Memory in Linux\nPOSIX Shared Memory (shm_open)\nSystem V Shared Memory Tutorial\nUnderstanding mmap\nKerrisk, The Linux Programming Interface\nChapter 49: Memory Mappings\nChapter 48: System V Shared Memory\nChapter 54: POSIX Shared Memory\nAdvanced Programming in the UNIX Environment — W. Richard Stevens, Chapter 15.9 \"Shared Memory\"\nRecommended\nLinux manual page - mmap(2)\nLinux manual page - munmap(2)\nLinux manual page - shm_open(3)\nLinux manual page - shm_overview(7)\nLinux manual page - shmget(2)\nLinux manual page - shmat(2)\nLinux manual page - shmctl(2)\nShared Memory Programming (IBM Developer)\nUnderstanding Shared Memory (GeeksforGeeks)\nMemory Mapped Files Explained\nDifference between System V and POSIX IPC","quiz-self-check#Quiz (Self-check)":"Why is shared memory considered the fastest IPC mechanism?\nWhat is the difference between MAP_SHARED and MAP_PRIVATE in mmap()?\nWhat system call is used to set the size of a POSIX shared memory object?\nHow do you create a POSIX shared memory object, and where does it appear in the filesystem?\nWhat is the purpose of shm_unlink()?\nHow does System V shared memory differ from POSIX shared memory?\nWhat command-line tools can you use to inspect System V shared memory segments?\nWhy does shared memory require explicit synchronization?\nWhat happens if you don't call shmctl(IPC_RMID) to remove a System V shared memory segment?\nWhat are the advantages of using mmap() for file I/O?\nHow can you protect a critical section when multiple processes access shared memory?\nWhat is the role of ftok() in System V IPC?","suggested-tools#Suggested Tools":"ipcs — display information about System V IPC facilities (shared memory, semaphores, message queues)\nipcrm — remove System V IPC resources\nls /dev/shm/ — list POSIX shared memory objects\npmap — display memory map of a process\nvmstat — report virtual memory statistics\nstrace — trace mmap(), shm_open(), shmget() system calls\nvalgrind — detect memory access errors in shared memory programs\ngdb — debug shared memory applications"}},"/system-programming/topics/signals":{"title":"Signals","data":{"overview#Overview":"This week introduces signals as a fundamental mechanism for asynchronous inter-process communication in Unix/Linux systems.\nStudents will learn how signals are generated, how processes can handle them, and how to send signals between processes. We will explore the standard signal API and signal handling mechanisms.By the end of this week, students will understand how processes communicate through signals, how to handle exceptional events, and how to register custom signal handlers.","key-concepts#Key Concepts":"","what-are-signals#What are Signals?":"Signals as software interrupts for asynchronous event notification\nUses of signals: termination, suspension, error notification, timer events, user-defined IPC\nSignal lifecycle: generation → delivery → handling\nSynchronous vs. asynchronous signals\nSignals as a form of lightweight IPC between processes","standard-signals#Standard Signals":"Process control signals:\nSIGTERM — polite termination request\nSIGKILL — forced termination (uncatchable)\nSIGSTOP / SIGCONT — suspend and resume execution\nError and fault signals:\nSIGSEGV — segmentation fault\nSIGFPE — floating-point exception\nSIGILL — illegal instruction\nSIGBUS — bus error\nUser and timer signals:\nSIGUSR1 / SIGUSR2 — user-defined signals\nSIGALRM — timer expiration (from alarm())\nJob control signals:\nSIGINT — interrupt from keyboard (Ctrl+C)\nSIGQUIT — quit from keyboard (Ctrl+\\)\nSIGTSTP — terminal stop (Ctrl+Z)\nI/O and pipe signals:\nSIGPIPE — write to a pipe with no reader\nSIGIO — asynchronous I/O event\nChild process signals:\nSIGCHLD — child process terminated or stopped","signal-handling#Signal Handling":"Default actions: terminate, ignore, stop, continue, core dump\nCustom signal handlers:\nsigaction() — modern, reliable signal handling API\nsignal() — traditional (unreliable) signal handler registration [do not use]\nHandler function signature: void handler(int signum)\nPersistent vs. one-shot handlers\nSignal disposition: default, ignore (SIG_IGN), custom handler (SIG_DFL)","sending-and-raising-signals#Sending and Raising Signals":"kill() — send a signal to a process or process group\nraise() — send a signal to the calling process\nkillpg() — send a signal to a process group\npthread_kill() — send a signal to a specific thread\nCommand-line tools: kill, killall, pkill","practice--lab#Practice / Lab":"","signal-handling-1#Signal Handling":"Write a program that handles SIGINT (Ctrl+C) and prints a message instead of terminating.\nRegister a handler using sigaction() and observe the behavior.\nUse the kill command from the shell to send signals to your running program.","inter-process-signaling#Inter-Process Signaling":"Write a parent process that forks a child and sends SIGUSR1 using kill().\nHave the child process handle SIGUSR1 and respond with SIGUSR2 to the parent.","timers#Timers":"Use alarm() to schedule SIGALRM and implement a timeout mechanism.","homework#Homework":"IPC-1: Signal Echo","references--resources#References & Resources":"Required\nSignals in C programming\nSignal Handling in Linux\nSignals in C Language\nSignal handling — sigaction\nKerrisk, The Linux Programming Interface\nChapter 20: Signals — Fundamental Concepts\nChapter 21: Signals — Signal Handlers\nAdvanced Programming in the UNIX Environment — W. Richard Stevens, Chapter 10 \"Signals\"\nRecommended\nLinux manual page - signal(7)\nLinux manual page - sigaction(2)\nLinux manual page - kill(2)\nLinux manual page - raise(3)\nLinux manual page - alarm(2)\nPOSIX Signals (Wikipedia)\nUnderstanding sigaction","quiz-self-check#Quiz (Self-check)":"What is the difference between SIGTERM and SIGKILL?\nWhy is sigaction() preferred over signal() for signal handling?\nWhat are the default actions a process can take when receiving a signal?\nHow do you send a signal from one process to another?\nWhat is the purpose of SIGUSR1 and SIGUSR2?\nWhat happens when you press Ctrl+C in a terminal running a program?\nHow does the alarm() function use signals?","suggested-tools#Suggested Tools":"kill — send signals to processes by PID\nkillall — send signals to processes by name\npkill — send signals based on pattern matching\ntrap — shell built-in for handling signals in scripts\nstrace — trace signal delivery and system calls\ngdb — debug signal handling behavior"}},"/system-programming/topics/sockets":{"title":"Sockets","data":{"overview#Overview":"This week introduces socket programming — the fundamental API for network communication in Unix/Linux systems.\nBuilding on the networking concepts covered previously, students will learn how to create network applications using the BSD socket interface. We will explore different socket types (stream and datagram), socket domains (Unix and Internet), and implement both client and server programs.By the end of this week, students will understand how to establish TCP connections, send UDP datagrams, handle multiple clients, and build robust networked applications using the socket API.","key-concepts#Key Concepts":"","what-are-sockets#What are Sockets?":"A socket is an endpoint for communication between two machines\nSockets provide a bidirectional communication channel\nThe BSD socket API — standard interface for network programming (originated in 4.2BSD Unix)\nSockets abstract network communication as file descriptors (read/write paradigm)\nUsed for both inter-machine (network) and intra-machine (local) communication\nFoundation for virtually all networked applications: web servers, databases, chat applications","socket-domains-address-families#Socket Domains (Address Families)":"AF_INET (IPv4 Internet domain)\nCommunication over IPv4 networks\nUses IP addresses and port numbers\nMost common for network applications\nAF_INET6 (IPv6 Internet domain)\nCommunication over IPv6 networks\n128-bit addresses for larger address space\nAF_UNIX / AF_LOCAL (Unix domain)\nCommunication between processes on the same machine\nUses filesystem pathnames instead of IP addresses\nFaster than Internet sockets for local IPC (no network stack overhead)\nAlso known as Unix domain sockets or local sockets","socket-types#Socket Types":"SOCK_STREAM (Stream sockets)\nConnection-oriented, reliable, bidirectional byte stream\nUses TCP for Internet domain (AF_INET)\nGuarantees delivery and ordering\nData arrives as a continuous stream (no message boundaries)\nMust establish connection before data transfer\nSOCK_DGRAM (Datagram sockets)\nConnectionless, unreliable message delivery\nUses UDP for Internet domain\nPreserves message boundaries (each send = one receive)\nNo connection establishment required\nFaster but may lose, duplicate, or reorder messages\nSOCK_RAW (Raw sockets)\nDirect access to lower-level protocols (IP, ICMP)\nRequires root privileges\nUsed for network tools like ping, traceroute","socket-address-structures#Socket Address Structures":"struct sockaddr — generic socket address (used in function prototypes)\nstruct sockaddr_in — IPv4 socket address:\nstruct sockaddr_in6 — IPv6 socket address\nstruct sockaddr_un — Unix domain socket address:\nAlways cast specific address types to struct sockaddr * when calling socket functions","byte-ordering#Byte Ordering":"Network byte order: big-endian (most significant byte first)\nHost byte order: varies by architecture (x86 is little-endian)\nConversion functions (must use for portability):\nhtons() — host to network short (16-bit, for ports)\nhtonl() — host to network long (32-bit, for addresses)\nntohs() — network to host short\nntohl() — network to host long\nAddress conversion:\ninet_pton() — presentation (string) to network binary\ninet_ntop() — network binary to presentation (string)\nLegacy: inet_addr(), inet_ntoa() (IPv4 only, avoid in new code)","core-socket-system-calls#Core Socket System Calls":"","creating-a-socket#Creating a Socket":"Creates a socket and returns a file descriptor\ndomain: AF_INET, AF_INET6, or AF_UNIX\ntype: SOCK_STREAM, SOCK_DGRAM, or SOCK_RAW\nprotocol: usually 0 (default protocol for the type)","server-side-calls#Server-Side Calls":"Assigns a local address (IP + port) to a socket\nRequired for servers to specify which address/port to listen on\nUse INADDR_ANY (or in6addr_any) to accept connections on any interface\nMarks a stream socket as passive (willing to accept connections)\nbacklog: maximum length of pending connection queue\nOnly for SOCK_STREAM sockets\nAccepts a pending connection from the queue\nBlocks until a client connects\nReturns a new socket for the accepted connection\nOriginal socket continues listening for more connections\naddr filled with client's address (can be NULL)","client-side-calls#Client-Side Calls":"Establishes a connection to a server (TCP) or sets default destination (UDP)\nFor TCP: initiates three-way handshake\nFor UDP: just sets the peer address (no actual connection)","data-transfer#Data Transfer":"send() — transmit data on a connected socket\nrecv() — receive data from a connected socket\nCommon flags: MSG_DONTWAIT (non-blocking), MSG_PEEK (peek without removing)\nCan also use read() / write() for basic operations\nsendto() / recvfrom() — for connectionless (UDP) communication\nSpecify destination/source address with each call\nEssential for UDP servers handling multiple clients","closing-sockets#Closing Sockets":"close() — close the socket file descriptor\nshutdown() — selectively close read/write directions:\nSHUT_RD — no more receives\nSHUT_WR — no more sends (sends FIN for TCP)\nSHUT_RDWR — both directions","tcp-client-server-model#TCP Client-Server Model":"Server workflow:\nsocket() — create socket\nbind() — bind to address and port\nlisten() — mark as passive, set backlog\naccept() — accept client connection (returns new socket)\nrecv() / send() — communicate with client\nclose() — close client socket\nRepeat from step 4 for next client\nClient workflow:\nsocket() — create socket\nconnect() — connect to server\nsend() / recv() — communicate with server\nclose() — close socket","udp-client-server-model#UDP Client-Server Model":"Server workflow:\nsocket() — create datagram socket\nbind() — bind to address and port\nrecvfrom() — receive datagram (get client address)\nsendto() — send response to client address\nRepeat from step 3\nClient workflow:\nsocket() — create datagram socket\nsendto() — send datagram to server\nrecvfrom() — receive response\nclose() — close socket","address-resolution#Address Resolution":"getaddrinfo() — modern, protocol-independent name/address resolution\nResolves hostnames to addresses\nHandles both IPv4 and IPv6\nReturns linked list of results\nAlways call freeaddrinfo() to free results\ngethostbyname() — legacy, IPv4 only (deprecated, avoid)\ngetnameinfo() — reverse lookup (address to hostname)","socket-options#Socket Options":"SO_REUSEADDR — allow reuse of local addresses (essential for servers)\nSO_REUSEPORT — allow multiple sockets to bind to same port\nSO_KEEPALIVE — enable TCP keep-alive probes\nSO_RCVBUF / SO_SNDBUF — set receive/send buffer sizes\nTCP_NODELAY — disable Nagle's algorithm (reduce latency)","handling-multiple-clients#Handling Multiple Clients":"Iterative server: handles one client at a time (simple but doesn't scale)\nConcurrent server approaches:\nFork per client: fork() a child process for each connection\nThread per client: create a thread for each connection\nI/O multiplexing: select(), poll(), or epoll() to handle multiple connections in one process\nThread pool: pre-created threads handle connections from a queue\nI/O multiplexing is most efficient for high-concurrency servers","common-pitfalls#Common Pitfalls":"Forgetting byte order conversion — corrupted ports and addresses\nNot checking return values — silent failures\nIgnoring partial sends/receives — TCP may split or combine data\nNot handling SIGPIPE — crash when writing to closed connection\nAddress already in use — use SO_REUSEADDR socket option\nBlocking indefinitely — use timeouts or non-blocking I/O\nResource leaks — always close sockets, even on errors","practice--lab#Practice / Lab":"","basic-tcp-echo-server#Basic TCP Echo Server":"Write a TCP server that listens on a specified port.\nAccept client connections and echo back any data received.\nTest with nc (netcat) or telnet.","tcp-client#TCP Client":"Write a TCP client that connects to your echo server.\nSend user input to the server and display responses.\nHandle connection errors gracefully.","udp-echo-server-and-client#UDP Echo Server and Client":"Implement the same echo functionality using UDP.\nCompare the code structure with TCP version.\nObserve behavior differences (no connection, message boundaries).","multi-client-server#Multi-Client Server":"Modify your TCP server to handle multiple clients concurrently.\nTry both fork-based and thread-based approaches.\nTest with multiple simultaneous client connections.","unix-domain-sockets#Unix Domain Sockets":"Create a simple IPC mechanism using AF_UNIX sockets.\nCompare performance with Internet sockets for local communication.","address-resolution-1#Address Resolution":"Write a program that uses getaddrinfo() to resolve hostnames.\nHandle both IPv4 and IPv6 results.\nPrint all resolved addresses for a given hostname.","homework#Homework":"NET-1: Echo Server","samples#Samples":"TCP server\nTCP client","references--resources#References & Resources":"Required\nBeej's Guide to Network Programming — the definitive tutorial for socket programming\nSocket Programming in C (Video)\nTCP Server-Client in C\nUDP Server-Client in C\nSocket Programming (GeeksforGeeks)\nKerrisk, The Linux Programming Interface\nChapter 56: Sockets — Introduction\nChapter 57: Sockets — Unix Domain\nChapter 58: Sockets — Fundamentals of TCP/IP Networks\nChapter 59: Sockets — Internet Domains\nChapter 60: Sockets — Server Design\nStevens, Unix Network Programming, Volume 1: The Sockets Networking API — the classic reference\nRecommended\nLinux manual page - socket(2)\nLinux manual page - socket(7)\nLinux manual page - bind(2)\nLinux manual page - listen(2)\nLinux manual page - accept(2)\nLinux manual page - connect(2)\nLinux manual page - send(2)\nLinux manual page - recv(2)\nLinux manual page - getaddrinfo(3)\nLinux manual page - ip(7)\nLinux manual page - tcp(7)\nLinux manual page - udp(7)\nLinux manual page - unix(7)\nSocket Programming Tutorial (IBM)\nUnderstanding Sockets (Baeldung)\nC10K Problem — scalability considerations for socket servers","quiz-self-check#Quiz (Self-check)":"What is a socket, and what does it represent?\nWhat is the difference between AF_INET and AF_UNIX socket domains?\nExplain the difference between SOCK_STREAM and SOCK_DGRAM socket types.\nWhy do we need byte order conversion functions like htons() and htonl()?\nWhat is the purpose of the bind() system call?\nWhat is the difference between listen() and accept()?\nWhy does accept() return a new socket file descriptor?\nWhen would you use sendto() / recvfrom() instead of send() / recv()?\nWhat is the purpose of setting SO_REUSEADDR on a server socket?\nHow does the TCP client-server model differ from the UDP model?\nWhat is getaddrinfo() and why is it preferred over gethostbyname()?\nWhat happens if you write to a TCP socket after the peer has closed the connection?\nWhat are three approaches for handling multiple clients in a server?\nHow do Unix domain sockets differ from Internet sockets in terms of addressing?\nWhat is the typical sequence of system calls for a TCP server?","suggested-tools#Suggested Tools":"nc (netcat) — versatile networking utility for testing (TCP/UDP client/server)\ntelnet — simple TCP client for testing servers\nss — display socket statistics and active connections\nnetstat — legacy tool for network connections (use ss instead)\nlsof -i — list open network connections\ntcpdump — capture and analyze network packets\nwireshark — GUI packet analyzer\ncurl — transfer data using various protocols\nstrace — trace socket system calls\nsocat — multipurpose relay tool (advanced netcat)\nnmap — network exploration and port scanning\niperf3 — network bandwidth testing"}},"/system-programming/topics/synchronization":{"title":"Synchronization and Critical Sections","data":{"overview#Overview":"This week explores one of the most important challenges in multithreaded programming — synchronization.\nStudents will understand how race conditions arise when multiple threads access shared data concurrently, and how to control access to critical sections using synchronization primitives such as mutexes, spinlocks, semaphores, condition variables, and atomic operations.","key-concepts#Key Concepts":"","concurrency-and-race-conditions#Concurrency and Race Conditions":"Race condition: when multiple threads access and modify shared data simultaneously, leading to unpredictable results.\nCritical section: a segment of code that must not be executed by more than one thread at a time.\nData consistency: maintaining integrity of shared resources under concurrent access.","synchronization-primitives#Synchronization Primitives":"Mutex (Mutual Exclusion Lock):\nEnsures only one thread executes a critical section at a time.\nCore functions: pthread_mutex_init, pthread_mutex_lock, pthread_mutex_unlock, pthread_mutex_destroy.\nSpinlock:\nLightweight lock that continuously checks availability without sleeping.\nSuitable for short critical sections on multicore systems.\nSemaphore:\nA counter-based synchronization mechanism for controlling access to a finite number of resources.\nPOSIX functions: sem_init, sem_wait, sem_post, sem_destroy.\nCondition Variable:\nUsed for signaling between threads.\nAllows a thread to wait until a certain condition becomes true.\nCore functions: pthread_cond_wait, pthread_cond_signal, pthread_cond_broadcast.\nAtomic Operations and CAS (Compare-And-Swap):\nLow-level operations ensuring atomic updates without explicit locks.\nFoundation for lock-free synchronization structures.","deadlocks-and-starvation-intro#Deadlocks and Starvation (Intro)":"Circular wait, hold and wait, no preemption, mutual exclusion — the four conditions for deadlock.\nTechniques to avoid or detect deadlocks will be discussed in future weeks.","practice#Practice":"","demonstrating-race-conditions#Demonstrating Race Conditions":"Create a shared counter updated by multiple threads without locks — observe inconsistent results.\nProtect the counter using a mutex and verify correct output.","working-with-mutexes#Working with Mutexes":"Use a mutex to protect a critical section in a multi-threaded program.\nExperiment with pthread_mutex_trylock and PTHREAD_MUTEX_RECURSIVE.","using-semaphores#Using Semaphores":"Implement a simple producer-consumer synchronization using semaphores.","condition-variables#Condition Variables":"Demonstrate thread signaling (one thread waits until another signals a condition).\nCompare busy-waiting vs. condition-based waiting.","spinlocks-and-atomics#Spinlocks and Atomics":"Experiment with short critical sections using spinlocks.\nObserve CPU utilization differences compared to mutexes.","homework#Homework":"TH-2: The thread pool implementation","references#References":"Required\nECE 252 Lecture 12: Concurrency: Synchronization & Atomicity\nECE 252 Lecture 13: Semaphores\nECE 252 Lecture 14: Synchronization Patterns\nПараллельное программирование. Лекция 2 Лекция\nMutex vs Semaphore\nSpinlocks - Part 1 - A Basic Spinlock \nCompare-and-swap\nAdvanced Programming in the UNIX Environment — W. Richard Stevens, Chapter 12 “Thread Synchronization”\nProgramming with POSIX Threads — David R. Butenhof, Chapters 4–6\nOperating Systems: Three Easy Pieces — Chapters “Concurrency,” “Locks,” and “Condition Variables”\nRecommended\nECE 252 Lecture 16: The Readers-Writers Problem\nECE 252 Lecture 17: Deadlock\nECE 252 Lecture 18: Deadlock Avoidance\nECE 252 Lecture 19: Deadlock Detection and Recovery\nMutex lock for Linux Thread Synchronization\nHow to use Semaphores in POSIX Concurrency Control\nLinux manual page - pthread_mutex_init(3p)\nLinux manual page - pthread_mutex_destroy(3p)\nLinux manual page - pthread_mutex_lock(3p)\nLinux manual page - pthread_mutex_unlock(3p)\nLinux manual page - spin_lock(3)\nLinux manual page - spin_unlock(3)\nLinux manual page - sem_init(3)\nLinux manual page - sem_destroy(3p)\nLinux manual page - sem_wait(3)\nLinux manual page - sem_post(3)\nLinux manual page - pthread_cond_wait(3)\nLinux manual page - pthread_cond_signal(3)","quiz-self-check#Quiz (Self-Check)":"What causes a race condition?\nWhat is the difference between a mutex and a spinlock?\nHow does a semaphore differ from a mutex?\nWhat are the typical use cases for condition variables?\nWhat does “atomic operation” mean?\nName the four necessary conditions for a deadlock.\nWhy is it important to minimize the time spent inside a critical section?"}},"/system-programming/topics/threads":{"title":"Multithreading and POSIX Threads","data":{"overview#Overview":"This week introduces threads as lightweight units of execution within a process.\nStudents will learn how threads differ from processes, how they share resources, and how to use the POSIX Threads (pthreads) API to create, synchronize, and manage them effectively in Linux.","key-concepts#Key Concepts":"Threads vs. Processes\nA process has its own memory space; threads share the same address space.\nThreads enable concurrent execution within a single process.\nThreads are more efficient for parallel tasks that share data.\nPOSIX Threads (pthreads)\nStandardized API for thread programming in UNIX/Linux environments.\nMain functions:\npthread_create() — create a new thread\npthread_join() — wait for a thread to complete\npthread_exit() — terminate the current thread\npthread_self() — obtain the thread ID\npthread_detach() — run thread independently (no join)\nThread Lifecycle\nStates: new → runnable → running → terminated\nResource management: stack, thread ID, attributes\nDetached vs. joinable threads and their memory implications\nThread Safety\nShared memory requires careful access to avoid conflicts (to be covered later).\nDistinguish between thread-safe and non-thread-safe library functions.","practice#Practice":"","thread-creation#Thread Creation":"Write a simple program that spawns multiple threads using pthread_create().\nPass arguments to threads and print thread identifiers with pthread_self().","joining-and-detaching#Joining and Detaching":"Use pthread_join() to synchronize thread completion.\nCreate detached threads using pthread_detach() and observe behavior.","thread-attributes#Thread Attributes":"Experiment with pthread_attr_t to set stack size or detach state.\nObserve resource usage differences using tools like htop (Shift + H).","observation#Observation":"Compare thread vs. process creation times using time and simple benchmarks.","homework#Homework":"TH-1: The array summary","samples#Samples":"Creating a thread","references#References":"Required\nFunction Pointer in C\nECE 252 Lecture 10: Threads\nECE 252 Lecture 11: Threads and Concurrency\nПараллельное программирование. Лекция 1 (RUS)\nIntroduction to Pthreads\nAdvanced Programming in the UNIX Environment — W. Richard Stevens, Chapter 11 “Threads”\nProgramming with POSIX Threads — David R. Butenhof\nOperating Systems: Three Easy Pieces — Chapter on “Concurrency and Threads”\nThe Open Group — POSIX Threads Specification\nRecommended\nLinux manual page - pthread_create(3)\nLinux manual page - pthread_join(3)\nLinux manual page - pthread_exit(3)\nLinux manual page - pthread_cancel(3)\nLinux manual page - pthread_attr_init(3)\nLinux manual page - pthread_attr_destroy(3)\nMultithreading in C\nThread functions in C/C++","quiz-self-check#Quiz (Self-Check)":"What is the key difference between a process and a thread?\nWhich function is used to create a new thread in POSIX?\nWhat happens if a joinable thread finishes without being joined?\nWhat is the purpose of pthread_detach()?\nWhy do threads share the same memory space, and what are the implications of this?\nWhat information does pthread_self() return?"}},"/system-programming/topics/unix-fs":{"title":"Unix Filesystem Basics","data":{"overview#Overview":"Building on the introductory tour of Linux, this week deepens your understanding of the command-line interface and the structure of the Unix filesystem.\nYou will learn how to use shell commands effectively, explore standard directories and their purposes, understand file types (regular files, directories, devices, links), and manage users, groups, and permissions.By the end of this week you should be able to confidently navigate the filesystem, interpret file metadata, and control access rights using the shell.","key-concepts#Key Concepts":"The shell as an interface: command syntax, arguments, options\nCommand synopsis and using man pages\nStandard Linux directory hierarchy (/bin, /etc, /home, /var, /proc, /dev, …)\nFile types: regular, directory, character/block devices, sockets, FIFOs\nHard links vs. symbolic (soft) links\nUsers, groups, and ownership model\nFile permissions: read/write/execute, chmod, chown, chgrp","practice--lab#Practice / Lab":"Shell Exploration:\nUse man, which, type to discover command info\nPractice navigation with cd, pwd, ls -l, tree\nFilesystem Walk:\nInspect the top-level folders under /\nExplore /proc and /dev for virtual and device files\nWorking with Links:\nCreate hard and symbolic links (ln, ln -s) and examine inode numbers with ls -i\nPermissions Management:\nCheck file metadata with ls -l\nChange mode and ownership (chmod, chown, chgrp)\nExperiment with umask and default file permissions\nUsers & Groups:\nInspect /etc/passwd and /etc/group\nUse id, who, groups to view account information","references--resources#References & Resources":"Required\nFilesystem Hierarchy Standard (FHS)\nLinux File Types (The Linux Documentation Project)\nGNU Coreutils Manual\nThe Unix File System\nECE 252 Lecture 3: The File System\nThe Unix File System (GeeksForGeeks)\nLinux File System Explained\nLinux File Permissions Explained\nFile Permissions\nLinux для Начинающих - Права Доступа и владения файлами и директориями (RUS)\nOptional / Enrichment\nLinux Journey: The Shell\nLinux Journey: Filesystem\nPermissions Explained (DigitalOcean)\nLinux Commands Part Two: Working With Files\n60 Linux Commands to Know\nBasic Linux Commands\nTools\nls, cd, pwd, man, file, stat, tree\nln, chmod, chown, groups, id","quiz-self-check#Quiz (Self-check)":"What is the difference between a hard link and a symbolic link?\nWhich directory holds configuration files for most system services?\nWhat do the three sets of characters in rwxr-xr-- represent?\nHow can you find the manual page for a command?\nWhich virtual directory contains information about running processes?"}}}