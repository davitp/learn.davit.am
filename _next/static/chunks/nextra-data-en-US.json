{"/_linux-programming":{"title":"Getting started","data":{"bibliography#Bibliography":"Programming via Operating Systems, Vahram Martirosyan, Feb 2022\nOperating Systems: Design and Implementation, Andrew S. Tanenbaum Albert S. Woodhull, Jan 1997\nStructured Computer Organization, Andrew S. Tanenbaum, Jan 1984\nOperating system design: the XINU approach, D. Comer Timothy V. Fossum, Jan 1984\nModern operating systems (2. ed.).,  Andrew S. Tanenbaum, Jan 2001\nLinux Kernel in a nutshell, Greg Kroah-Hartman, Jan 2006"}},"/_linux-programming/topics/advanced-input-output":{"title":"Advanced IO with File Systems API","data":{"overview#Overview":"Exploring more advanced functionalities provided by the File Systems API for file manipulations.\nUnderstanding concepts such as file descriptor duplication and granular control over file descriptors during file operations.\nDelving into the seek operation and its various modes, including handling holes and sparse files.","outline#Outline":"","controlling-standard-input-output-and-error-streams#Controlling Standard Input, Output, and Error Streams":"Understanding file descriptor duplication with functions like dup and dup2.\nExploring their applications in controlling standard streams for input/output redirection.","granular-control-over-open-file-descriptors#Granular Control Over Open File Descriptors":"Examining advanced options for opening files, including truncate-on-open, create-if-does-not-exist, and temporary files.\nUnderstanding how these options provide more flexibility and control in file handling.","seek-operation-lseek-on-open-files#Seek Operation (lseek) on Open Files":"Explaining the seek operation and its significance in navigating through files.\nUnderstanding various modes of seeking the file and their applications.","holes-and-sparse-files#Holes and Sparse Files":"Understanding the concept of holes and sparse files.\nExploring how to create sparse files using the seek operation and detecting holes within files.","practice#Practice":"","advanced-file-operations-using-shell#Advanced File Operations Using Shell":"Practical exercises involving advanced file operations in the shell, such as stream redirection, input/output piping, and utilities like grep and dd.\nDemonstrating how to leverage shell capabilities for efficient file handling.","random-file-access-using-lseek#Random File Access Using lseek":"Hands-on exercises to perform read and write operations at random file locations using the lseek function.\nUnderstanding the importance of random access in certain file manipulation scenarios.","creating-sparse-files-and-detecting-holes#Creating Sparse Files and Detecting Holes":"Practical demonstrations of creating sparse files using the lseek operation.\nExercises to detect and handle holes within sparse files for optimized file storage.","references#References":"Linux manual page - dup(2)\nLinux manual page - lseek(3p)\nlseek() in C/C++ to read the alternate nth byte and write it in another file","homework#Homework":"FS-4: Redirect standard input\nFS-5: Manaul append\nFS-10: Copy a file accounting holes","samples#Samples":"Redirect standard output and error\nCreate a file with holes\nDetect holes in the file"}},"/_linux-programming/topics/file-systems-api":{"title":"The File Systems API and File Manipulations from Code","data":{"overview#Overview":"Providing a basic understanding of file abstractions in the API.\nExplaining the concept of file descriptors and their role in file operations.\nCovering main file operations such as creat, open, read, write, and close.","outline#Outline":"","concept-of-file-descriptors#Concept of File Descriptors":"Understanding file descriptors as integer values representing open files.\nExplaining the standard input (stdin) and standard output (stdout) file descriptors.","working-with-files-using-file-system-api-functions#Working with Files Using File System API Functions":"Introduction to essential file system API functions: open, read, write, close.\nExploring their parameters and return values.","proper-error-handling-with-system-calls#Proper Error Handling with System Calls":"Emphasizing the importance of error handling while using file system API functions.\nUtilizing the \"errno\" variable to identify and handle errors.","references#References":"File Descriptor (Wiki)\nHandling a File by its Descriptor in C\nOS5 - File Descriptors, File Descriptor Table","practice#Practice":"","writing-simple-programs-to-demonstrate-file-operations#Writing Simple Programs to Demonstrate File Operations":"Hands-on exercises to demonstrate main file operations such as file creation, reading, writing, and closing.\nPractical examples to reinforce understanding of file system API functions.","demonstrating-redirection-of-standard-input-and-output-streams#Demonstrating Redirection of Standard Input and Output Streams":"Writing programs to demonstrate redirection of standard input and output streams using basic open/close operations.\nUnderstanding how to manipulate file descriptors for redirection purposes.","references-1#References":"Linux manual page - open(2)\nLinux manual page - creat(3p)\nLinux manual page - read(2)\nLinux manual page - write(2)\nLinux manual page - close(2)\nLinux manual page - fcntl(2)\nLinux manual page - errno(3)\nReading and Writing Files in C, two ways (fopen vs. open)","homework#Homework":"FS-1: Read from the file\nFS-2: Copy a file\nFS-3: Secure file deletion","samples#Samples":"Opening a file"}},"/_linux-programming/topics/file-systems-overview":{"title":"Overview of the Unix File Systems","data":{"overview#Overview":"Providing a concise understanding of files in Unix operating systems.\nDescribing the hierarchical tree structure of the file system.\nExploring different file types and their meanings in the Unix environment.\nCovering key attributes of files and directories, including ownership, permissions, and dates.","outline#Outline":"","tree-structure-of-unix-file-systems#Tree Structure of Unix File Systems":"Visualizing and understanding the hierarchical organization of files and directories in Unix.\nExploring the directory tree and its significance in file system navigation.","high-level-overview-of-main-file-types-in-unix#High-Level Overview of Main File Types in Unix":"Defining and discussing various file types: regular files, directories, links, etc.\nUnderstanding the purpose and characteristics of each file type in Unix.","main-attributes-of-files-and-directories#Main Attributes of Files and Directories":"Examining essential attributes such as owner, permissions, modification dates, etc.\nUnderstanding how these attributes contribute to file and directory management.","references#References":"The Unix File System\nECE 252 Lecture 3: The File System\nThe Unix File System (GeeksForGeeks)\nLinux File System Explained\nLinux File Permissions Explained\nFile Permissions\nLinux для Начинающих - Права Доступа и владения файлами и директориями (RUS)","practice#Practice":"","working-with-unix-file-systems-using-shell#Working with Unix File Systems Using Shell":"Hands-on exercises for navigating and interacting with Unix file systems through the command line.\nIntroduction to essential shell commands for effective file system manipulation.","manipulating-files-and-directories#Manipulating Files and Directories":"Practical exercises for creating, modifying, and deleting files and directories.\nUnderstanding common file operations and their command-line counterparts.","working-with-file-ownership-and-permissions#Working with File Ownership and Permissions":"In-depth exploration of commands like chmod and chown for managing file permissions and ownership.\nHands-on practice to reinforce concepts of access control.","using-text-editors-from-the-shell#Using Text Editors from the Shell":"Introduction to popular text editors like nano and vim.\nHands-on experience with creating and editing text files directly from the shell.","references-1#References":"Linux Commands Part Two: Working With Files\n60 Linux Commands to Know\nBasic Linux Commands"}},"/_linux-programming/topics/hardware-and-software":{"title":"Hardware and Software","data":{"overview#Overview":"Understanding the fundamental concepts of hardware and software.\nExploring the main components of a computer system.","outline#Outline":"","what-is-a-computer#What is a Computer?":"Defining the essential components and their functions.\nHighlighting the interplay between hardware and software.","operating-system-basics#Operating System Basics":"Providing a concise definition of an operating system.\nExploring the crucial role it plays in managing resources and providing user interfaces.","unix-gnu-and-free-software#UNIX, GNU, and Free Software":"Unveiling the significance of UNIX in computing history.\nUnderstanding the philosophy behind GNU and the concept of free software.","kernels-overview#Kernels: Overview":"Introduction to kernels and their role as the core of operating systems.\nExamining different kernels such as Minix, Linux, and BSD.","gnulinux-distributions#GNU/Linux Distributions":"Surveying the landscape of GNU/Linux distributions.\nDiscussing popular distributions and their unique features.","references#References":"ECE 252 Lecture 1: Introduction\nOperating Systems: Wiki\nKernel: Wiki\nFree Software and Open-Source\nЭволюция вычислительных систем (RUS)\nWhat is Kernel\nMicrokernel and Monolithic Kernel\nComputer Basics: Inside a Computer\nGNU/Linux Distributions\nDistributions Tree","practice#Practice":"","setting-up-a-virtual-machine-with-gnulinux#Setting Up a Virtual Machine with GNU/Linux":"Practical guide to creating a virtual environment for hands-on experience.\nEmphasizing the importance of virtualization in system programming.","command-line-mastery#Command Line Mastery":"Utilizing the command line for fundamental operations.\nHands-on practice with file manipulation, software installation, and more.","development-environment-setup#Development Environment Setup":"Configuring essential tools like Git, gcc/g++, and make for efficient programming.\nEstablishing a robust development environment for system programming tasks.","github-repository-setup#GitHub Repository Setup":"Understanding key concepts for version control with Git.\nCreating and managing repositories on GitHub for organized collaboration.","overview-of-existing-gnulinux-distributions#Overview of Existing GNU/Linux Distributions":"In-depth exploration of prominent GNU/Linux distributions.\nInsight into the strengths and use-cases of different distributions.","references-1#References":"Download VirtualBox\nDownload Ubuntu\nInstall Ubuntu in VirtualBox\nGit and GitHub\nGit Username Setup\nGit Commit Email Setup","homework#Homework":"ENV-1: Setup GNU/Linux Environment"}},"/_linux-programming/topics/linux-programming":{"title":"Introduction to System Programming","data":{"overview#Overview":"Providing a concise introduction to programming in the Linux operating system.\nExplaining the key aspects of compiling and executing C/C++ code.\nUnderstanding the main phases of compilation and the significance of binary executable files.","outline#Outline":"","anatomy-of-cc-source-file#Anatomy of C/C++ Source File":"Breaking down the components of a source file: directives, code, comments, etc.\nUnderstanding the structure that makes up C/C++ source code.","program-entry-point-main-function#Program Entry Point: Main Function":"Exploring the main function as the entry point of a C/C++ program.\nUnderstanding the role of arguments passed to the main function.","compilation-process#Compilation Process":"Overview of the compilation phases: pre-processing, translation, assembling, and linking.\nExplaining the transformation of source code into an executable binary.","understanding-elf-binary-format#Understanding ELF Binary Format":"Introduction to the ELF (Executable and Linkable Format) binary format.\nDifferentiating between static and dynamic linking libraries.","loading-program-into-memory-and-memory-layout#Loading Program into Memory and Memory Layout":"Understanding how programs are loaded into memory during execution.\nExploring the memory layout of a running program.","references#References":"ECE 252 Lecture 1: Our C Toolkit\nUnderstanding C and C++ compilation process\nC++: препроцессор, компилятор, компоновщик (RUS)\nThe C++ compilation model\nMemory Layout of C Program","practice#Practice":"","analysis-of-a-hello-world-program-in-cc#Analysis of a \"Hello, World!\" Program in C/C++":"Step-by-step analysis of a simple program to understand its structure.\nEmphasizing key elements of C/C++ code.","compilation-using-g-from-shell#Compilation Using g++ from Shell":"Practical exercises on compiling C/C++ source code using the g++ compiler from the command line.\nExploring various compiler options.","introduction-to-development-tools#Introduction to Development Tools":"Brief overview of essential development tools such as man, nm, ldd, strip, etc.\nUnderstanding their roles in the development process.","build-process-and-makefiles#Build Process and Makefiles":"Explaining the build process and the importance of automation.\nIntroduction to writing Makefiles for streamlining the compilation and linking process.\nExploring alternative build tools.","references-1#References":"Compiling with g++\nC Programming: Makefiles\nBegineer Makefile tutorial\nMakefile tutorial\n9 Essential GNU binutils tools\nCMake Tutorial EP 1 | Understanding The Basics","homework#Homework":"ENV-2: Complex numbers and sorting","guides#Guides":"Compilation and build process","samples#Samples":"Compiling multiple files using Makefile"}},"/_linux-programming/topics/processes":{"title":"Overview of Unix Processes","data":{"outline#Outline":"","definition-of-process-and-process-tree#Definition of Process and Process Tree":"Understanding the concept of a process as a program in execution state.\nIntroduction to the init process and the hierarchical tree structure of processes.","introduction-to-virtual-memory#Introduction to Virtual Memory":"Brief overview of virtual memory and its role in process execution.\nExplaining concepts such as pages and page tables within the virtual memory of a process.","properties-of-a-process#Properties of a Process":"Exploring key properties of processes, including process ID (pid) and file descriptor table.\nUnderstanding other process-related attributes essential for management and identification.","process-creation-workflow#Process Creation Workflow":"Understanding the process creation workflow through functions like fork and clone.\nExplaining the parent-child relationship and the lifecycle of a process.","execution-of-programs-in-processes#Execution of Programs in Processes":"Overview of executing programs within a process using exec* functions.\nUnderstanding how these functions replace the current process image with a new one.","references#References":"ECE 252 Lecture 4: Processes\nECE 252 Lecture 5: Processes in UNIX\nThe Exec Family of Functions\nThe fork function in C\nWaiting for processes to finish in C","practice#Practice":"","practical-overview-of-the-process-tree#Practical Overview of the Process Tree":"Hands-on exploration of the process tree using shell commands like ps.\nUnderstanding the structure and relationships within the process hierarchy.","demonstration-of-process-lifecycle#Demonstration of Process Lifecycle":"Writing a simple program to demonstrate the lifecycle of a process using fork, wait, and exec functions.\nPractical exercises to illustrate process creation, execution, and termination.","usage-of-command-line-arguments-and-environment-variables#Usage of Command Line Arguments and Environment Variables":"Demonstrating the usage of command line arguments with exec functions.\nUnderstanding the inheritance of environment variables between parent and child processes.","references-1#References":"Linux manual page - fork(2)\nLinux manual page - wait(2)\nLinux manual page - clone(2)\nLinux manual page - exec(3)\nExample of fork() in C\nFork System Call in Operating System","homework#Homework":"PS-1: Do command\nPS-2: Interactive shell","samples#Samples":"Creating a process"}},"/_linux-programming/topics/producer-consumer":{"title":"The Producer-Consumer Problem Definition and Solutions","data":{"outline#Outline":"","definition-of-producer-consumer-problem#Definition of Producer-Consumer Problem":"Explaining the producer-consumer problem and its importance in synchronization.\nDiscussing various variations of the problem, such as bounded and unbounded buffers.","solution-strategies-for-multi-threaded-producer-consumer-problem#Solution Strategies for Multi-Threaded Producer-Consumer Problem":"Introducing strategies to solve the producer-consumer problem in a multi-threaded context.\nDiscussing the use of synchronization primitives like mutexes, semaphores, and conditional variables.","conditional-variables-and-the-waitnotify-pattern#Conditional Variables and the Wait/Notify Pattern":"Understanding the role of conditional variables in synchronization.\nExploring the wait/notify pattern and its application in solving synchronization issues.","references#References":"ECE 252 Lecture 15: The Producer-Consumer Problem\nПараллельное программирование\nThread Pool","practice#Practice":"","writing-a-multi-threaded-producer-consumer-program#Writing a Multi-Threaded Producer-Consumer Program":"Developing a typical multi-threaded producer-consumer program to demonstrate synchronization problems.\nIdentifying and analyzing the synchronization issues that arise.","solving-the-producer-consumer-problem-using-synchronization-primitives#Solving the Producer-Consumer Problem Using Synchronization Primitives":"Implementing solutions to the producer-consumer problem using semaphores.\nAlternative implementation using conditional variables to manage synchronization.","references-1#References":"Producer Consumer Problem in C\nHands-On Multithreading with C++ 04 — Producer-Consumer Problem\nProducer-Consumer Problem and its Implementation with C++\nThread Pools in C (using the PTHREAD API)","homework#Homework":"TH-2: The thread pool implementation"}},"/_linux-programming/topics/synchronization":{"title":"Introduction to Synchronization Problems","data":{"outline#Outline":"","understanding-synchronization-problems#Understanding Synchronization Problems":"Introduction to synchronization problems and the reasons they occur in multi-threaded and multi-process environments.","definition-of-race-condition-atomicity-and-critical-section#Definition of Race Condition, Atomicity, and Critical Section":"Explaining the concept of race conditions and how they arise.\nUnderstanding atomicity and its importance in preventing race conditions.\nDefining the critical section and its role in synchronization.","overview-of-synchronization-primitives#Overview of Synchronization Primitives":"Introducing key synchronization primitives such as mutexes, semaphores, spin locks, and compare-and-swap (CAS) operations.\nDiscussing the usage scenarios for each primitive.","differences-between-synchronization-primitives-and-their-drawbacks#Differences Between Synchronization Primitives and Their Drawbacks":"Comparing synchronization primitives and their performance implications.\nHighlighting the potential drawbacks and limitations of each primitive.","references#References":"ECE 252 Lecture 12: Concurrency: Synchronization & Atomicity\nECE 252 Lecture 13: Semaphores\nECE 252 Lecture 14: Synchronization Patterns\nПараллельное программирование. Лекция 2 Лекция\nMutex vs Semaphore\nSpinlocks - Part 1 - A Basic Spinlock \nCompare-and-swap","advanced#Advanced":"ECE 252 Lecture 16: The Readers-Writers Problem\nECE 252 Lecture 17: Deadlock\nECE 252 Lecture 18: Deadlock Avoidance\nECE 252 Lecture 19: Deadlock Detection and Recovery","practice#Practice":"","demonstrating-a-race-condition#Demonstrating a Race Condition":"Writing a multi-threaded program to illustrate a race condition.\nAnalyzing the output to understand the nature of race conditions.","solving-race-conditions-using-synchronization-primitives#Solving Race Conditions Using Synchronization Primitives":"Implementing solutions to race conditions using synchronization primitives such as mutexes and spin locks.\nWriting code examples to show the correct usage of these primitives.","comparing-performance-overhead-of-synchronization-primitives#Comparing Performance Overhead of Synchronization Primitives":"Programmatically comparing the performance overhead of different synchronization primitives in various scenarios.\nConducting experiments to measure and analyze the impact of synchronization on program efficiency.","references-1#References":"Mutex lock for Linux Thread Synchronization\nHow to use Semaphores in POSIX Concurrency Control\nLinux manual page - pthread_mutex_init(3p)\nLinux manual page - pthread_mutex_destroy(3p)\nLinux manual page - pthread_mutex_lock(3p)\nLinux manual page - pthread_mutex_unlock(3p)\nLinux manual page - spin_lock(3)\nLinux manual page - spin_unlock(3)\nLinux manual page - sem_init(3)\nLinux manual page - sem_destroy(3p)\nLinux manual page - sem_wait(3)\nLinux manual page - sem_post(3)\nLinux manual page - pthread_cond_wait(3)\nLinux manual page - pthread_cond_signal(3)"}},"/_linux-programming/topics/system-calls":{"title":"System calls, hardware-software communication, POSIX standard","data":{"overview#Overview":"Understanding the essential aspects of communication between hardware and software.\nExploring the functionality exposed by operating systems and the role of System Calls.\nIntroduction to the POSIX standard for hardware and software compatibility.","outline#Outline":"","how-cpu-and-memory-work-together#How CPU and Memory Work Together?":"Explaining the synergy between the CPU and RAM in a computer system.\nUnderstanding the fundamental principles of memory management.","kernel-communication-with-cpu-ram-and-devices#Kernel Communication with CPU, RAM, and Devices":"Unraveling the mechanisms through which the Kernel communicates with critical components.\nInsight into the role of the Kernel in managing hardware resources.","operating-system-functionality-for-application-development-system-calls#Operating System Functionality for Application Development: System Calls":"Examining the functionality exposed by the operating system for application development.\nUnderstanding the significance of System Calls in facilitating communication between applications and the OS.","introduction-to-posix-standard#Introduction to POSIX Standard":"Exploring the POSIX standard and its importance for ensuring hardware and software compatibility.\nDiscussing key POSIX concepts and their impact on cross-platform development.","references#References":"ECE 252 Lecture 2: Interrupts and System Calls\nThe Fetch-Execute Cycle\nЛекция 1. Генезис операционных систем: Назначение ОС (RUS)\nSystem Calls\nSystem Calls: Wiki\nPOSIX Standard Explained","practice#Practice":"","using-gnulinux-as-a-development-environment#Using GNU/Linux as a Development Environment":"Practical guidance on leveraging GNU/Linux for efficient development.\nIncorporating essential tools and practices for seamless system programming.","overview-of-git-and-repository-setup#Overview of Git and Repository Setup":"Brief overview of Git for version control and collaboration.\nStep-by-step guide on setting up repositories for homework assignments.","basic-shell-commands-and-inputoutput-operations#Basic Shell Commands and Input/Output Operations":"Hands-on experience with fundamental shell commands.\nExploring standard input and output operations, including redirection and piping.","high-level-introduction-to-shell-scripting#High-Level Introduction to Shell Scripting":"Introduction to the basics of shell scripting.\nUnderstanding the power of automation through simple script creation.","references-1#References":"Man Pages - The Complete Guide\nManual Pages\nThe Missing Semester of Your CS Education\nMissing Semester: The Shell\nMissing Semester: Shell Tools and Scripting\nMissing Semester: Editors (vim)\nMissing Semester: Version Control (git)"}},"/_linux-programming/topics/threads":{"title":"Threading: Parallelism and Concurrency","data":{"topic-outline#Topic Outline":"","overview-of-memory-layout-heap-and-stack#Overview of Memory Layout: Heap and Stack":"Understanding the memory layout of a process, including the heap and stack.\nExplaining the concept of the call stack and its role in thread execution.","the-concept-of-thread-and-thread-context#The Concept of Thread and Thread Context":"Introducing the concept of a thread and its execution context.\nHighlighting the main differences between a process and a thread in terms of isolation, memory management, and scheduling.","understanding-parallelism-and-concurrency#Understanding Parallelism and Concurrency":"Explaining the difference between parallel and concurrent execution.\nUnderstanding how threads enable concurrent execution within a single process.","introduction-to-pthread-library#Introduction to Pthread Library":"Overview of the Pthread library (POSIX threads) for thread programmability.\nCovering essential functions for creating, joining, and cancelling threads using the Pthread API.","references#References":"Function Pointer in C\nECE 252 Lecture 10: Threads\nECE 252 Lecture 11: Threads and Concurrency\nПараллельное программирование. Лекция 1\nIntroduction to Pthreads","practice#Practice":"","writing-multi-threaded-programs-using-pthread-library#Writing Multi-threaded Programs using Pthread Library":"Hands-on exercises to write multi-threaded programs using the Pthread library.\nImplementing parallel execution of tasks within a single process using threads.","using-library-functions-to-manage-threads#Using Library Functions to Manage Threads":"Practical demonstrations of using library functions to join and cancel threads within a program.\nUnderstanding the role of thread synchronization and coordination.","compilation-and-linking-with-pthread-library#Compilation and Linking with Pthread Library":"Understanding the compilation and linking process with the Pthread library.\nEnsuring proper integration of Pthread library functions in multi-threaded programs.","references-1#References":"Linux manual page - pthread_create(3)\nLinux manual page - pthread_join(3)\nLinux manual page - pthread_exit(3)\nLinux manual page - pthread_cancel(3)\nLinux manual page - pthread_attr_init(3)\nLinux manual page - pthread_attr_destroy(3)\nMultithreading in C\nThread functions in C/C++","homework#Homework":"TH-1: The array summary","samples#Samples":"Creating a thread"}},"/_operating-systems":{"title":"Getting Started","data":{}},"/_operating-systems/topics":{"title":"Topics","data":{"":"This is topics outline"}},"/_operating-systems/topics/introduction":{"title":"Introduction","data":{"":"This is an intro"}},"/":{"title":"Home","data":{}},"/system-programming/guides":{"title":"Guides","data":{}},"/system-programming/guides/compilation":{"title":"Compilation and build process","data":{"":"The set of samples showcases different aspects of the compilation process in the Linux environment using various tools such as gcc, make, cmake, etc.","single-file-compilation#Single file compilation":"Consider main.cpp as a source file containing the whole logic of the application:\nTo compile the source code into an executable file execute the following line in the source directory:\nwhere parameter -o app defines the name of the output file (a.out by default).If the command completes successfully, the source directory will contain a file called app that is ready to execute as follows:","pre-processing-a-c-source-file#Pre-processing a C++ source file":"You may want to stop the compiler after the pre-processing phase when all the directives such as include, define, etc. are resolved.\nIn that case you will need to run the pass the -E flag to the compiler as follows:\nThe result of the command prints the result on a console by default, hence we redirected the content to be written to file \"preprocessed-main.cpp\" by using redirection operator (>) of shell.","translation-of-the-source#Translation of the source":"You may also want to stop the compiler after the translation phase to get the low-level code in assembler language. For that you need to pass -S flag to the compiler. It will generate a new file with .s extension by default:\nAfter the command is completed successfully you will get a main.s file containing your source in assembler language. The file will contain something like this:","assembling-the-compiled-file#Assembling the compiled file":"Most commonly, you will need to compile your source file to a binary object file containing your source code in a binary format, but not ready to execute. Object files are generated by passing -c to the compiler. By default a file with \".o\" extension will be generated:\nAfter this command, a file named main.o will be generated.","linking-object-files#Linking object files":"In most of the cases, you will have many source files compiled into object files separately and after all object files are ready you will link those together and add necessary libraries. For example, if you have files main.o, module1.o and module2.o you will need to link those together into an executable file (or a library):\nAfter this command, a file named \"a.out\" will be generated and will be ready to run.Also, you may want to see the libraries your executable is linked to using the following command:\nIn this basic example, your executable will be linked with the standard libraries as follows:"}},"/system-programming":{"title":"Getting started","data":{"":"This course introduces students to system programming in Linux, focusing on how applications interact directly with the operating system through the kernel API. Students will move from basic exploration of the Linux environment to writing programs that manage files, processes, threads, interprocess communication, and network connections.","sections#Sections":"","bibliography#Bibliography":"Programming via Operating Systems, Vahram Martirosyan, Feb 2022\nThe Art of Unix Programming, Eric S. Raymond\nW. Richard Stevens & Stephen A. Rago — Advanced Programming in the UNIX Environment (APUE), 3rd Edition\nW. Richard Stevens — UNIX Network Programming, Volume 1: The Sockets Networking API, 3rd Edition\nRemzi H. Arpaci-Dusseau & Andrea C. Arpaci-Dusseau — Operating Systems: Three Easy Pieces (OSTEP) read online\nMichael Kerrisk — The Linux Programming Interface (TLPI)\nThe Linux man-pages project read online\nBeej’s Guides read online\nOperating Systems: Design and Implementation, Andrew S. Tanenbaum Albert S. Woodhull, Jan 1997\nRobert Love — Linux System Programming (O’Reilly, 2nd Ed.)\nBrian W. Kernighan & Dennis M. Ritchie — The C Programming Language (K&R)\nStructured Computer Organization, Andrew S. Tanenbaum, Jan 1984\nOperating system design: the XINU approach, D. Comer Timothy V. Fossum, Jan 1984\nModern operating systems (2. ed.).,  Andrew S. Tanenbaum, Jan 2001\nLinux Kernel in a nutshell, Greg Kroah-Hartman, Jan 2006"}},"/system-programming/samples":{"title":"Samples","data":{}},"/system-programming/samples/copy-file":{"title":"Copy the given file","data":{"":"This sample demonstrates how to implement a basic copy program using read and write functions.\nThe file can be compiled with the following command:\nRunning the resulting application ./copy source-file.txt new-file.txt duplicate source-file.txt with name new-file.txt."}},"/system-programming/samples/create-process":{"title":"Creating a process","data":{"":"The sample demonstrates how to create a process using fork() function.\nThe file can be compiled and executed as follows:\nThe program is supposed to start a process and clone itself printing appropriate messages as follows:"}},"/system-programming/samples/create-thread":{"title":"Creating a thread","data":{"":"The sample demonstrates how to create a thread using pthread_create() function and wait for its completion.\nThe file can be compiled and executed as follows:\nThe program is supposed to print + and - signs without any particular order as follows:"}},"/system-programming/samples/detect-holes":{"title":"Detect holes in the file","data":{"":"The sample demonstrates how to detect data and hole segments in the given file.\nThe file can be compiled and executed as follows:\nThe program is supposed to print start and end indexes of all the data and hole segments if any."}},"/system-programming/samples/make-hole":{"title":"Create a file with holes","data":{"":"This sample demonstrates the ability to create a sparse file containing both data segments and holes using lseek function.\nThe program is expected to accept the target file name as a first argument and sequence of sizes for created data and hole segments in the file.\nThe file can be compiled and executed as follows:\nAfter successful completion of the program, we will have file \"file_with_holes\" created containing 2 data segments of size 4096 and 2 holes of size 4096."}},"/system-programming/samples/makefile":{"title":"Compiling multiple files using Makefile","data":{"":"In this sample, we will compile a program having two modules with Makefile.The program will contain two modules:\nmain.cpp - the main logic of the application\nmessage.cpp - a module that can simply print messages\nLet's assume the main.cpp contains the following logic:\nThe file message.h contains only a declaration of the used function:\nThen the module message.cpp should implement the mentioned function as follows:\nWe can manually compile the modules one by one as follows:\nThen, having two modules main.o and message.o we can build the final executable by linking those together:\nTo automate the process we could also write a Makefile as follows:\nNow, invoking make command will create all the necessary files for the program.You may also want to clean the build output with a special clean target as follows:"}},"/system-programming/samples/open-file":{"title":"Opening a file","data":{"":"This sample demonstrates the usage of functions open and close.\nThe file can be compiled with the following command:\nRunning the resulting application ./open should create a file named foo.txt and print the following result:"}},"/system-programming/samples/read-file":{"title":"Reading file contents","data":{"":"This sample demonstrates how to read a text file using read() function.\nThe file can be compiled with the following command:\nRunning the resulting application ./read some-file.txt will print the contents of the given file to the console."}},"/system-programming/samples/redirect-output":{"title":"Redirect standard output and error","data":{"":"This sample demonstrates how to redirect standard output and standard error into a file (using dup/dup2) while keeping possibility to write to the console when needed.\nThe file can be compiled with the following command:\nRunning the resulting application ./redirect is supposed to print \"Hello\" on the console screen and create a file output.log containing cout and cerr text."}},"/system-programming/tasks":{"title":"Tasks","data":{}},"/system-programming/tasks/environment":{"title":"Environment","data":{}},"/system-programming/tasks/environment/complex-number":{"title":"ENV-2: Complex numbers and sorting","data":{"requirements#Requirements":"Write multi-file C++ program consisting of following 3 modules:\nA class that represents a complex number along with all the basic operations: plus, minus, multiply by a constant, absolute value.\nA function that implements any sorting algorithm on an array/vector of complex numbers.\nA main function containing a demonstration of having multiple complex numbers in array and sorting them.\nModules for complex number class and sorting algorithm should be separate and each of them should have source and header files.","expected-result#Expected result":"A solution containing all the described modules (source and header files), as well as, a Makefile for automated build of the solution.The final solution should contain a Makefile for the multi-stage build. The Makefile should also contain targets all and clean. It's recommended to have compiler and compiler flags to be declared as a Makefile variables. Alternatively, cmake could also be used instead of make."}},"/system-programming/tasks/environment/environment-setup":{"title":"ENV-1: Setup GNU/Linux Environment","data":{"requirements#Requirements":"Install any GNU/Linux distribution on a Virtual or Physical Machine.\nRun lsb_release -a >> $USER.txt command (if available) in a shell and get the result.\nRun cat /etc/os-release >> $USER.txt command (if available) in a shell and get the result.\nSubmit $USER.txt file to the Github as a solution for the task.","expected-output#Expected output":"The expected output is a text file named $USER.txt where $USER is the current user's username. The content is expected to be similar to the following:"}},"/system-programming/tasks/file-systems":{"title":"File Systems","data":{}},"/system-programming/tasks/file-systems/copy-file":{"title":"FS-2: Copy a file","data":{"requirements#Requirements":"Write a C++ program simple-copy accepting two command line arguments representing source file path and destination file path.\nImplement proper error handling to account if not all arguments are passed or if one of arguments is not a valid one.\nCopy the content of the source file into a destination file. If destination file already exists, it should be overwritten.","expected-result#Expected result":"The resulting application should be able to build and execute from command line as follows:\nThe final solution should contain a Makefile for the multi-stage build. The Makefile should also contain targets all and clean. It's recommended to have compiler and compiler flags to be declared as a Makefile variables. Alternatively, cmake could also be used instead of make."}},"/system-programming/tasks/file-systems/copy-with-holes":{"title":"FS-10: Copy a file accounting holes","data":{"requirements#Requirements":"Write a C++ program accepting two command line arguments representing source file path and destination file path.\nImplement proper error handling to account if not all arguments are passed or if one of arguments is not a valid one.\nCopy the content of the source file into a destination file. If destination file already exists, it should be overwritten.\nIf source file contains holes, the destination file should also contain hole as is.\nPrint overall amount of bytes copied to the destination file including total amount of physical data and total amount of holes if any.","expected-result#Expected result":"The resulting application should be able to build and execute from command line as follows:\nAfter copy is completed, program should print following message to the console:\nThe logical and physical sizes of source and destination files should match exactly.The final solution should contain a Makefile for the multi-stage build. The Makefile should also contain targets all and clean. It's recommended to have compiler and compiler flags to be declared as a Makefile variables. Alternatively, cmake could also be used instead of make."}},"/system-programming/tasks/file-systems/manual-append":{"title":"FS-5: Manaul append","data":{"description#Description":"Your task is to write a program on C/C++ that writes two lines in the files \"first line\" and \"second line\".\nWriting should happen into two different file descriptors but write into the same file.","requirements#Requirements":"Write a C/C++ program that gets the filepath with the first argument and opens it.\nFile should not be opened with the O_APPEND file.\nYou are not allowed to use seek/lseek to move the cursor to the end.\nThe program writes two lines: \"first line\" and \"second line\". Each line is written in a different descriptor.\nAfter write, the file should contain both lines in the same file.\nHint: you may use dup/dup2.","expected-result#Expected result":"The resulting application should be able to build and execute from command line as follows:\nThe output file should contain the following text:\nThe final solution should contain a Makefile for the multi-stage build. The Makefile should also contain targets all and clean. It's recommended to have compiler and compiler flags to be declared as a Makefile variables. Alternatively, cmake could also be used instead of make."}},"/system-programming/tasks/file-systems/read-file":{"title":"FS-1: Read from the file","data":{"description#Description":"You need to implement a program that does the same thing as the cat command in the Linux.","requirements#Requirements":"Write a C++ program read-file accepting a file path as an argument.\nImplement proper error handling to make sure required file path is passed.\nOpen the given file with proper mode and make sure errors are handled.\nRead the content of the file into a buffer until reaching the end of the file.\nPrint every portion of the file read in the iteration.\nHint: if you use printf or std::cin, make sure your strings are terminated with '\\0' symbol.","expected-result#Expected result":"The resulting application should be able to build and execute from command line as follows:\nThe program should output the content of the input.txt file on the screen.The final solution should contain a Makefile for the multi-stage build. The Makefile should also contain targets all and clean. It's recommended to have compiler and compiler flags to be declared as a Makefile variables. Alternatively, cmake could also be used instead of make."}},"/system-programming/tasks/file-systems/redirect-cin":{"title":"FS-4: Redirect standard input","data":{"description#Description":"By default, program gets standard input waiting for the keyboard input. Your task is to make any program to read input from the file instead of waiting for the keyboard input without changing usages of std::cin or scanf.","requirements#Requirements":"Write a C++ program named \"redirect-cin\" that accepts a path to a file as a command-line argument.\nImplement the function initialize(int argc, char** argv) to start reading from the given file with a proper error handling.\nImplement a simple logic for main() function to read string from the standard input (std::cin) and print the reversed string to the cosnsole (std::out).\nIf there is an error with given file, the program should terminate with the proper error code.\nThe program's main source file should look like:\nHint: you can use one of dup() functions.","expected-result#Expected result":"The resulting application should be able to build and execute from command line as follows:\nAnd, assuming input file contains the text \"123456789\", the program should output the following:\nThe final solution should contain a Makefile for the multi-stage build. The Makefile should also contain targets all and clean. It's recommended to have compiler and compiler flags to be declared as a Makefile variables. Alternatively, cmake could also be used instead of make."}},"/system-programming/tasks/ipc":{"title":"IPC","data":{}},"/system-programming/tasks/file-systems/secure-file-deletion":{"title":"FS-3: Secure file deletion","data":{"description#Description":"Your task is to implement a C++ program that deletes the file from the filesystem along with its content by replacing every byte in the files with '\\0' character.","requirements#Requirements":"Write a C++ program named \"hacker-rm\" that accepts a path to a file as a command-line argument.\nImplement proper error handling to check if the file exists and if the input path is valid.\nOpen the file for writing and replace every byte with the null character ('\\0').\nRemove the file from the file system after overwriting its content.\nEnsure that your program works for various file sizes and types.\nHint: you can use write, stat, lseek, unlink function to solve the problem.","expected-result#Expected result":"The resulting application should be able to build and execute from command line as follows:\nThe final solution should contain a Makefile for the multi-stage build. The Makefile should also contain targets all and clean. It's recommended to have compiler and compiler flags to be declared as a Makefile variables. Alternatively, cmake could also be used instead of make."}},"/system-programming/tasks/ipc/prime-calculator":{"title":"IPC-2: Prime calculator","data":{"requirements#Requirements":"Write a C++ program that creates a child process.\nThe main process infinitely waits for the user's input integer m.\nOnce number m is received by the main process, it gets passed to the child process via anonymous pipe.\nThe child process takes m from the anonymous pipe and calculates the m-th prime number.\nThe child process should send the result of the calculation back to the parent process, which, should print it and wait for the next input.\nIf the \"exit\" command is entered, the main process should stop its execution.","expected-result#Expected result":"The resulting application should be able to build and execute from the command line as follows:\nThe typical execution of the program should look like the following:\nThe final solution should contain a Makefile for the multi-stage build. The Makefile should also contain targets all and clean. It's recommended to have compiler and compiler flags declared as Makefile variables. Alternatively, cmake could also be used instead of make."}},"/system-programming/tasks/ipc/shared-array":{"title":"IPC-3: Shared array implementation","data":{"requirements#Requirements":"Write a C++ class implementing a module shared_array which is an array of integers shared between processes.\nThe class is supposed to be initialized as follows: shared_array array(\"array-name\", size);\nThe size of the array (number of elements) could be between 1 and 1 000 000 000\nTwo shared arrays are the same in the system if they have equal names and sizes, otherwise, they are different.\nThe class should provide operator [] for indexing an element with a given index i.\nAny process that knows the name and the size of the array should be able to use it.\nWrite two infinite programs (first and second) to work with the shared array using cross-process semaphore.","expected-result#Expected result":"The resulting application should be able to build from the command line as follows:\nThe execution of the program should demonstrate how the array changes from the first and second processes.The final solution should contain a Makefile for the multi-stage build. The Makefile should also contain targets all and clean. It's recommended to have compiler and compiler flags declared as Makefile variables. Alternatively, cmake could also be used instead of make."}},"/system-programming/tasks/processes":{"title":"Processes","data":{}},"/system-programming/tasks/ipc/signal-echo":{"title":"IPC-1: Signal echo","data":{"requirements#Requirements":"Write a C++ program that prints its PID and registers a signal handler for SIGUSR1.\nThe handler of the signal SIGUSR1 is suppose to react by printing the following information:\nThe PID of the sender process,\nThe UID and the user name of the sender,\nThe current values of the EIP, EAX, EBX registers.\nProgram should enter an infinite loop and perform a sleeping delay on each iteration (example: sleep for 10 seconds).","expected-result#Expected result":"The resulting application should be able to build and execute from command line as follows:\nThen, once any other process sends SIGUSR1 signal to our process, it should print the following information:\nThe final solution should contain a Makefile for the multi-stage build. The Makefile should also contain targets all and clean. It's recommended to have compiler and compiler flags to be declared as a Makefile variables. Alternatively, cmake could also be used instead of make."}},"/system-programming/tasks/processes/do-command":{"title":"PS-1: Do command","data":{"description#Description":"Your task is to implement a C++ program that accepts a command name and command arguments with command-line arguments and executes it in a new process.","requirements#Requirements":"Write a C++ program called \"do-command\" that takes N arguments as an input.\nAssume that first argument is command name and others are arguments for the given command.\nA program should contain a special function do_command(char** argv), where argv is null-terminated vector of arguments.\nThe function \"do_command\" should create a new process, execute the given command with the given arguments and wait for its completion.\nAfter program execution is done, do_function should print exit status of the command and the duration of the command execution.\nThe \"main\" function of the program is responsible for building proper argument vector and using do_command function to execute the command.","expected-result#Expected result":"The resulting application should be able to build and execute from command line as follows:\nThe command is expected to print program output to the console and a line as follows:\nThe final solution should contain a Makefile for the multi-stage build. The Makefile should also contain targets all and clean. It's recommended to have compiler and compiler flags to be declared as a Makefile variables. Alternatively, cmake could also be used instead of make."}},"/system-programming/tasks/processes/interactive-shell":{"title":"PS-2: Interactive shell","data":{"requirements#Requirements":"Write a C++ program that implements an interactive shell with an infinite loop waiting for a command.\nOn every iteration of the loop a command string is passed to the shell program.\nA command can be either a name of command or a path (relative or absolute).\nAfter command is entered, program should create a new process to run the command.\nThe current directory of the shell program should be temporarily added to the PATH variable of every new process.\nIf \"exit\" command is entered, shell program should stop and exit with a success code.\nIf entered command starts with word \"silent\", the executing command should redirect the standard output and error streams into the PID.log file where PID is the process id of the child process.","expected-result#Expected result":"The resulting application should be able to build and execute from command line as follows:\nUser may enter commands as follows:\nor\nor\nand the command should print the output to the console.Also user may want to enter commands as follows\nand the output of program ls should be redirected into the file PID.log where PID is the identifier of the child process.The final solution should contain a Makefile for the multi-stage build. The Makefile should also contain targets all and clean. It's recommended to have compiler and compiler flags to be declared as a Makefile variables. Alternatively, cmake could also be used instead of make."}},"/system-programming/tasks/threads":{"title":"Threads","data":{}},"/system-programming/tasks/threads/array-sum":{"title":"TH-1: The array summary","data":{"requirements#Requirements":"Write a C++ program creates an array of N elements (N > 1 000 000).\nInitialize the array with random values at the beginning.\nCompute summary of the array using a regular for loop and calculate the time spent for the operation.\nCreate M threads to sum the same array with multiple threads, considering that every thread gets an equal portion to sum, except, maybe, the last one.\nWait for all the threads to complete and measure the time spent for summing the array using M threads.\nPrint the durations spent to sum the array with and without threads.\nNote that N and M variables should be passed to the program via command line arguments.","expected-result#Expected result":"The resulting application should be able to build and execute from command line as follows:\nand the command should print the output to the console as follows:\nThe final solution should contain a Makefile for the multi-stage build. The Makefile should also contain targets all and clean. It's recommended to have compiler and compiler flags to be declared as a Makefile variables. Alternatively, cmake could also be used instead of make."}},"/system-programming/tasks/threads/thread-pool":{"title":"TH-2: The thread pool implementation","data":{"requirements#Requirements":"Create a C++ library (shared object) that implements a simple thread pool\nThread pool should be implemented as a class called \"parallel_scheduler\"\nThread pool takes a capacity argument in the constructor as a maximum number of threads in the pool.\nThread pool defines a method run that takes as an input two arguments function and the argument.\nAll the functions given to the \"run\" method are enqueued and the thread pool should execute them as soon as any of its threads gets time.\nNext, another executable application is implemented to demonstrate the usage of the thread pool library.\nThe demonstration application should enqueue various functions for the execution (more than the capacity).\nThe module \"parallel_scheduler\" should be compiled as a shared library (parallel_scheduler.so) and should be linked with the demo application.","expected-result#Expected result":"The resulting application should be able to build and execute from command line as follows:\nThe final solution should contain a Makefile for the multi-stage build. The Makefile should also contain targets all and clean. It's recommended to have compiler and compiler flags to be declared as a Makefile variables. Alternatively, cmake could also be used instead of make."}},"/system-programming/topics":{"title":"Topics","data":{}},"/system-programming/topics/advanced-io":{"title":"Advanced File I/O","data":{"overview#Overview":"This week extends the foundation of Linux file I/O by exploring advanced file descriptor manipulation and low-level file positioning.\nStudents will learn how to duplicate file descriptors, control file behavior using fcntl, and manage files beyond simple read/write operations — including seeking, truncation, and sparse file handling.By the end of this week, students will have a complete understanding of how Linux manages file descriptors and how processes interact with files efficiently and flexibly.","key-concepts#Key Concepts":"","file-descriptor-duplication#File Descriptor Duplication":"dup() and dup2() system calls\nFile descriptor table and shared open file descriptions\nStandard output redirection example with dup2()\nRelationship between dup2() and shell redirection","file-positioning#File Positioning":"The lseek() system call: repositioning file offsets\nSeeking modes:\nSEEK_SET – from beginning\nSEEK_CUR – from current position\nSEEK_END – from end of file\nPractical uses: appending, measuring file size, random access","sparse-files-and-holes#Sparse Files and Holes":"Concept of holes (unallocated regions in files)\nCreating and inspecting sparse files\nComparing allocated and logical sizes\nSEEK_DATA and SEEK_HOLE (modern extensions for efficient traversal)","file-control-and-management#File Control and Management":"The fcntl() system call:\nDuplicating descriptors (F_DUPFD)\nManaging flags (FD_CLOEXEC, O_APPEND, O_NONBLOCK)\nTruncating files with ftruncate()\nRetrieving file information with fstat()","practice--lab#Practice / Lab":"","descriptor-duplication#Descriptor Duplication":"Redirect program output to files using file descriptor duplication.\nExplore descriptor inheritance and redirection behavior.","file-positioning-and-sparse-files#File Positioning and Sparse Files":"Create files with gaps using lseek() to demonstrate sparse allocation.\nCompare logical and physical file sizes using shell utilities.","file-control-and-metadata#File Control and Metadata":"Use fcntl() to retrieve and modify descriptor properties.\nTruncate and inspect file length using system utilities.","homework#Homework":"FS-4: Redirect standard input\nFS-5: Manaul append\nFS-10: Copy a file accounting holes","samples#Samples":"Redirect standard output and error\nCreate a file with holes\nDetect holes in the file","references--resources#References & Resources":"Required Reading\nKerrisk, The Linux Programming Interface\nChapter 5: File I/O – Deeper Concepts\nChapter 6: Advanced File I/O\nRecommended\nUnderstanding Sparse Files (Red Hat)\nBeej’s Guide – File Descriptors\nLinux manual page - fcntl(2)\nLinux manual page - dup(2)\nLinux manual page - lseek(3p)\nlseek() in C/C++ to read the alternate nth byte and write it in another file","quiz-self-check#Quiz (Self-check)":"What happens to the file offset when a descriptor is duplicated?\nHow does dup2() differ from shell redirection?\nWhat is the difference between SEEK_END and SEEK_CUR?\nHow does a sparse file conserve storage space?\nWhat are the purposes of SEEK_DATA and SEEK_HOLE?\nWhat does FD_CLOEXEC accomplish in practice?","suggested-tools#Suggested Tools":"strace – observe system calls like dup2 and lseek\nls, du, stat – inspect logical and physical file properties\nhexdump – verify data placement within sparse files"}},"/system-programming/topics/basic-io":{"title":"System Calls and Basic File I/O","data":{"overview#Overview":"This week marks the beginning of direct interaction with the kernel.\nStudents will learn what a system call (syscall) is, how it bridges user space and kernel space, and how errors are communicated via errno.We then explore file descriptors, the foundation of Linux’s “everything is a file” philosophy, and practice with fundamental file-related system calls: creat, open, read, write, and close.","key-concepts#Key Concepts":"System Calls\nRole of syscalls in OS design\nUser mode vs. kernel mode\nInterrupts, traps, and context switching\nsyscall interface vs. library wrappers (glibc)\nError Handling\nReturn values (-1 convention)\nerrno global variable\nUsing perror() and strerror()\nFile Descriptors\nConcept of file descriptors (integers representing open files)\nStandard descriptors: stdin (0), stdout (1), stderr (2)\n“Everything is a file” in Unix: devices, pipes, sockets\nEssential File System Calls\ncreat(), open(), read(), write(), close()\nFlags: O_RDONLY, O_WRONLY, O_RDWR, O_CREAT, O_APPEND, etc.\nPermissions and the umask effect\nDifferences between system calls and stdio (fopen, fread, etc.)","practice--lab#Practice / Lab":"Syscall Tracing\nUse strace ls to observe syscalls in action\nIdentify open, read, write, close in the trace\nError Handling\nWrite a C program to open a non-existent file, print error with perror\nFile I/O Basics\nWrite a program that:\nCreates a file with creat()\nWrites a string to it with write()\nReads it back with read() and prints to stdout\nCloses the file descriptor","homework#Homework":"FS-1: Read from the file\nFS-2: Copy a file\nFS-3: Secure file deletion","references--resources#References & Resources":"Required\nThe Linux Programming Interface – Kerrisk, Ch. 4–5: System Calls & File I/O\nFile Descriptor (Wiki)\nHandling a File by its Descriptor in C\nOS5 - File Descriptors, File Descriptor Table\nOptional\nBeej’s Guide to Unix IPC (intro chapters)\nLinux Syscalls Table\nLinux manual page - open(2)\nLinux manual page - creat(3p)\nLinux manual page - read(2)\nLinux manual page - write(2)\nLinux manual page - close(2)\nLinux manual page - fcntl(2)\nLinux manual page - errno(3)\nerrno – C library\nReading and Writing Files in C, two ways (fopen vs. open)\nTools\nstrace, errno, perror, man","quiz-self-check#Quiz (Self-check)":"What distinguishes a system call from a regular library function?\nWhich system calls are involved when reading a file from disk?\nWhat values are reserved for stdin, stdout, and stderr file descriptors?\nHow does errno get set, and how should you properly print its meaning?\nWhat is the difference between open and creat?"}},"/system-programming/topics/compilation":{"title":"The Compilation Process","data":{"overview#Overview":"This week introduces the compilation pipeline that turns source code into an executable program.\nStarting with a simple Hello World in C/C++, we’ll explore each step: preprocessing, compiling, assembling, and linking. Students will gain hands-on experience using gcc or g++ at each stage and learn how Makefiles automate the build process.By the end of this week, you should be able to manually trace the build process, understand the role of each stage, and create a simple Makefile for structured project builds.","key-concepts#Key Concepts":"Source code lifecycle: from .c or .cpp to executable binary\nStages of the compilation pipeline:\nPreprocessing (cpp): handling #include, #define, macros, conditional compilation\nCompilation: converting preprocessed code into assembly\nAssembling: turning assembly into object files (.o)\nLinking: combining object files and libraries into an executable\nUsing gcc or g++ to invoke each stage individually\nUnderstanding object files and executables with file, nm, objdump\nStatic vs. dynamic linking basics\nBuild automation: Makefiles, rules, targets, dependencies\nOther useful tools: make, pkg-config, ldd","practice--lab#Practice / Lab":"Hello World Compilation Steps:\nRun gcc -E hello.c -o hello.i (preprocessor)\nRun gcc -S hello.i -o hello.s (compiler → assembly)\nRun gcc -c hello.s -o hello.o (assembler → object file)\nRun gcc hello.o -o hello (linker → executable)\nExploring Artifacts:\nInspect .i, .s, .o and executable with less and file\nUse nm hello.o to list symbols\nUse objdump -d hello.o to view assembly\nMakefile Basics:\nWrite a simple Makefile with targets: all, clean\nPractice make, make clean, dependency tracking\nLinking Check:\nUse ldd hello to see linked libraries\nCompare static vs dynamic builds (gcc -static)","homework#Homework":"ENV-2: Complex numbers and sorting","guides#Guides":"Compilation and build process","references--resources#References & Resources":"Required\nGNU Compiler Collection (GCC) Documentation\nMake Manual (GNU Make)\nIntroduction to the Compilation Process (GeeksforGeeks)\nECE 252 Lecture 1: Our C Toolkit\nUnderstanding C and C++ compilation process\nC++: препроцессор, компилятор, компоновщик (RUS)\nThe C++ compilation model\nMemory Layout of C Program\nOptional\nThe Linux Programming Interface (Kerrisk) – Chapter 4: Program Execution\nLearn Makefiles by Example (GNU)\nobjdump, nm, and ldd Usage Guide (Tutorialspoint)\nCompiling with g++\nC Programming: Makefiles\nBegineer Makefile tutorial\nMakefile tutorial\n9 Essential GNU binutils tools\nCMake Tutorial EP 1 | Understanding The Basics\nTools\ngcc, cpp, as, ld\nmake, pkg-config, ldd, objdump, nm","quiz-self-check#Quiz (Self-check)":"What is the role of the preprocessor in compilation?\nWhat file extension is typically produced by the assembler?\nHow does static linking differ from dynamic linking?\nWhich tool is used to inspect the symbols inside an object file?\nWhy are Makefiles useful in larger projects?"}},"/system-programming/topics/intro":{"title":"Introduction to Unix and Linux","data":{"overview#Overview":"In this first week, we establish the foundation for system programming. Students will explore what an operating system is, how kernels are structured, and how Linux fits into the broader family of operating systems. We also introduce GNU/Linux distributions, the concept of free and open-source software, and the shell as the main interface to the system.By the end of this week, students will have a working Linux environment, a basic understanding of the command line, and an introduction to version control with Git and GitHub.","key-concepts#Key Concepts":"What is an operating system? Roles and responsibilities\nKernel vs. user space; system calls as the bridge\nKernel architectures: monolithic, microkernel, hybrid\nUnix lineage and Linux history (vs. Windows, macOS, BSD)\nGNU/Linux ecosystem: distributions and package managers\nThe shell: prompt, commands, redirection, and pipelines","practice--lab#Practice / Lab":"Set up a Virtual Machine: Install Ubuntu (or another Linux distribution) on VirtualBox/VMware.\nCommand Line Basics:\nRun and understand ls, cd, pwd, man, echo, cat\nTry redirection (>, >>) and pipelines (|)\nInstall software with apt or your distro’s package manager\nDevelopment Environment Setup: Install and test gcc, g++, make, and git. Configure an editor (e.g., VS Code or Vim).\nGit & GitHub Essentials: Initialize a local repo, make a commit, and push to GitHub.\nExploring Distributions: Find your kernel version (uname -a) and distro info (lsb_release -a). Compare Ubuntu, Fedora, Arch, Debian.","homework#Homework":"Complete task: ENV-1: Setup GNU/Linux Environment","references--resources#References & Resources":"Required\nOperating Systems (Wikipedia)\nKernel (Wikipedia)\nGNU/Linux Distributions\nOptional / Enrichment\nWhat is Kernel (Video)\nMicrokernel vs Monolithic Kernel (Video)\nLinux Distribution Timeline (Diagram)\nЭволюция вычислительных систем (RUS)\nTools\nDownload VirtualBox\nDownload Ubuntu\nInstall Ubuntu in VirtualBox (Video)\nGit and GitHub Basics (Video)","quiz-self-check#Quiz (Self-check)":"What is the difference between the kernel and user space?\nName two major differences between Linux and Windows.\nWhich shell command is used to find your current directory?\nWhat is the purpose of a package manager in Linux?"}},"/system-programming/topics/unix-fs":{"title":"Unix Filesystem Basics","data":{"overview#Overview":"Building on the introductory tour of Linux, this week deepens your understanding of the command-line interface and the structure of the Unix filesystem.\nYou will learn how to use shell commands effectively, explore standard directories and their purposes, understand file types (regular files, directories, devices, links), and manage users, groups, and permissions.By the end of this week you should be able to confidently navigate the filesystem, interpret file metadata, and control access rights using the shell.","key-concepts#Key Concepts":"The shell as an interface: command syntax, arguments, options\nCommand synopsis and using man pages\nStandard Linux directory hierarchy (/bin, /etc, /home, /var, /proc, /dev, …)\nFile types: regular, directory, character/block devices, sockets, FIFOs\nHard links vs. symbolic (soft) links\nUsers, groups, and ownership model\nFile permissions: read/write/execute, chmod, chown, chgrp","practice--lab#Practice / Lab":"Shell Exploration:\nUse man, which, type to discover command info\nPractice navigation with cd, pwd, ls -l, tree\nFilesystem Walk:\nInspect the top-level folders under /\nExplore /proc and /dev for virtual and device files\nWorking with Links:\nCreate hard and symbolic links (ln, ln -s) and examine inode numbers with ls -i\nPermissions Management:\nCheck file metadata with ls -l\nChange mode and ownership (chmod, chown, chgrp)\nExperiment with umask and default file permissions\nUsers & Groups:\nInspect /etc/passwd and /etc/group\nUse id, who, groups to view account information","references--resources#References & Resources":"Required\nFilesystem Hierarchy Standard (FHS)\nLinux File Types (The Linux Documentation Project)\nGNU Coreutils Manual\nThe Unix File System\nECE 252 Lecture 3: The File System\nThe Unix File System (GeeksForGeeks)\nLinux File System Explained\nLinux File Permissions Explained\nFile Permissions\nLinux для Начинающих - Права Доступа и владения файлами и директориями (RUS)\nOptional / Enrichment\nLinux Journey: The Shell\nLinux Journey: Filesystem\nPermissions Explained (DigitalOcean)\nLinux Commands Part Two: Working With Files\n60 Linux Commands to Know\nBasic Linux Commands\nTools\nls, cd, pwd, man, file, stat, tree\nln, chmod, chown, groups, id","quiz-self-check#Quiz (Self-check)":"What is the difference between a hard link and a symbolic link?\nWhich directory holds configuration files for most system services?\nWhat do the three sets of characters in rwxr-xr-- represent?\nHow can you find the manual page for a command?\nWhich virtual directory contains information about running processes?"}}}