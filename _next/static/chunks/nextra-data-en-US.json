{"/":{"title":"Index","data":{}},"/linux-programming/guides":{"title":"Guides","data":{}},"/linux-programming/guides/compilation":{"title":"Compilation and build process","data":{"":"The set of samples showcases different aspects of the compilation process in the Linux environment using various tools such as gcc, make, cmake, etc.","single-file-compilation#Single file compilation":"Consider main.cpp as a source file containing the whole logic of the application:\nTo compile the source code into an executable file execute the following line in the source directory:\nwhere parameter -o app defines the name of the output file (a.out by default).If the command completes successfully, the source directory will contain a file called app that is ready to execute as follows:","pre-processing-a-c-source-file#Pre-processing a C++ source file":"You may want to stop the compiler after the pre-processing phase when all the directives such as include, define, etc. are resolved.\nIn that case you will need to run the pass the -E flag to the compiler as follows:\nThe result of the command prints the result on a console by default, hence we redirected the content to be written to file \"preprocessed-main.cpp\" by using redirection operator (>) of shell.","translation-of-the-source#Translation of the source":"You may also want to stop the compiler after the translation phase to get the low-level code in assembler language. For that you need to pass -S flag to the compiler. It will generate a new file with .s extension by default:\nAfter the command is completed successfully you will get a main.s file containing your source in assembler language. The file will contain something like this:","assembling-the-compiled-file#Assembling the compiled file":"Most commonly, you will need to compile your source file to a binary object file containing your source code in a binary format, but not ready to execute. Object files are generated by passing -c to the compiler. By default a file with \".o\" extension will be generated:\nAfter this command, a file named main.o will be generated.","linking-object-files#Linking object files":"In most of the cases, you will have many source files compiled into object files separately and after all object files are ready you will link those together and add necessary libraries. For example, if you have files main.o, module1.o and module2.o you will need to link those together into an executable file (or a library):\nAfter this command, a file named \"a.out\" will be generated and will be ready to run.Also, you may want to see the libraries your executable is linked to using the following command:\nIn this basic example, your executable will be linked with the standard libraries as follows:"}},"/linux-programming":{"title":"Getting Started","data":{}},"/linux-programming/samples":{"title":"Samples","data":{}},"/linux-programming/samples/copy-file":{"title":"Copy the given file","data":{"":"This sample demonstrates how to implement a basic copy program using read and write functions.\nThe file can be compiled with the following command:\nRunning the resulting application ./copy source-file.txt new-file.txt duplicate source-file.txt with name new-file.txt."}},"/linux-programming/samples/create-process":{"title":"Creating a process","data":{"":"The sample demonstrates how to create a process using fork() function.\nThe file can be compiled and executed as follows:\nThe program is supposed to start a process and clone itself printing appropriate messages as follows:"}},"/linux-programming/samples/create-thread":{"title":"Creating a thread","data":{"":"The sample demonstrates how to create a thread using pthread_create() function and wait for its completion.\nThe file can be compiled and executed as follows:\nThe program is supposed to print + and - signs without any particular order as follows:"}},"/linux-programming/samples/detect-holes":{"title":"Detect holes in the file","data":{"":"The sample demonstrates how to detect data and hole segments in the given file.\nThe file can be compiled and executed as follows:\nThe program is supposed to print start and end indexes of all the data and hole segments if any."}},"/linux-programming/samples/make-hole":{"title":"Create a file with holes","data":{"":"This sample demonstrates the ability to create a sparse file containing both data segments and holes using lseek function.\nThe program is expected to accept the target file name as a first argument and sequence of sizes for created data and hole segments in the file.\nThe file can be compiled and executed as follows:\nAfter successful completion of the program, we will have file \"file_with_holes\" created containing 2 data segments of size 4096 and 2 holes of size 4096."}},"/linux-programming/samples/makefile":{"title":"Compiling multiple files using Makefile","data":{"":"In this sample, we will compile a program having two modules with Makefile.The program will contain two modules:\nmain.cpp - the main logic of the application\nmessage.cpp - a module that can simply print messages\nLet's assume the main.cpp contains the following logic:\nThe file message.h contains only a declaration of the used function:\nThen the module message.cpp should implement the mentioned function as follows:\nWe can manually compile the modules one by one as follows:\nThen, having two modules main.o and message.o we can build the final executable by linking those together:\nTo automate the process we could also write a Makefile as follows:\nNow, invoking make command will create all the necessary files for the program.You may also want to clean the build output with a special clean target as follows:"}},"/linux-programming/samples/open-file":{"title":"Opening a file","data":{"":"This sample demonstrates the usage of functions open and close.\nThe file can be compiled with the following command:\nRunning the resulting application ./open should create a file named foo.txt and print the following result:"}},"/linux-programming/samples/read-file":{"title":"Reading file contents","data":{"":"This sample demonstrates how to read a text file using read() function.\nThe file can be compiled with the following command:\nRunning the resulting application ./read some-file.txt will print the contents of the given file to the console."}},"/linux-programming/samples/redirect-output":{"title":"Redirect standard output and error","data":{"":"This sample demonstrates how to redirect standard output and standard error into a file (using dup/dup2) while keeping possibility to write to the console when needed.\nThe file can be compiled with the following command:\nRunning the resulting application ./redirect is supposed to print \"Hello\" on the console screen and create a file output.log containing cout and cerr text."}},"/linux-programming/tasks":{"title":"Tasks","data":{}},"/linux-programming/tasks/array-sum":{"title":"TH-1: The array summary","data":{"requirements#Requirements":"Write a C++ program creates an array of N elements (N > 1 000 000).\nInitialize the array with random values at the beginning.\nCompute summary of the array using a regular for loop and calculate the time spent for the operation.\nCreate M threads to sum the same array with multiple threads, considering that every thread gets an equal portion to sum, except, maybe, the last one.\nWait for all the threads to complete and measure the time spent for summing the array using M threads.\nPrint the durations spent to sum the array with and without threads.\nNote that N and M variables should be passed to the program via command line arguments.","expected-result#Expected result":"The resulting application should be able to build and execute from command line as follows:\nand the command should print the output to the console as follows:\nThe final solution should contain a Makefile for the multi-stage build. The Makefile should also contain targets all and clean. It's recommended to have compiler and compiler flags to be declared as a Makefile variables. Alternatively, cmake could also be used instead of make."}},"/linux-programming/tasks/complex-number":{"title":"ENV-2: Complex numbers and sorting","data":{"requirements#Requirements":"Write multi-file C++ program consisting of following 3 modules:\nA class that represents a complex number along with all the basic operations: plus, minus, multiply by a constant, absolute value.\nA function that implements any sorting algorithm on an array/vector of complex numbers.\nA main function containing a demonstration of having multiple complex numbers in array and sorting them.\nModules for complex number class and sorting algorithm should be separate and each of them should have source and header files.","expected-result#Expected result":"A solution containing all the described modules (source and header files), as well as, a Makefile for automated build of the solution.The final solution should contain a Makefile for the multi-stage build. The Makefile should also contain targets all and clean. It's recommended to have compiler and compiler flags to be declared as a Makefile variables. Alternatively, cmake could also be used instead of make."}},"/linux-programming/tasks/copy-file":{"title":"FS-2: Copy a file","data":{"requirements#Requirements":"Write a C++ program simple-copy accepting two command line arguments representing source file path and destination file path.\nImplement proper error handling to account if not all arguments are passed or if one of arguments is not a valid one.\nCopy the content of the source file into a destination file. If destination file already exists, it should be overwritten.","expected-result#Expected result":"The resulting application should be able to build and execute from command line as follows:\nThe final solution should contain a Makefile for the multi-stage build. The Makefile should also contain targets all and clean. It's recommended to have compiler and compiler flags to be declared as a Makefile variables. Alternatively, cmake could also be used instead of make."}},"/linux-programming/tasks/copy-with-holes":{"title":"FS-10: Copy a file accounting holes","data":{"requirements#Requirements":"Write a C++ program accepting two command line arguments representing source file path and destination file path.\nImplement proper error handling to account if not all arguments are passed or if one of arguments is not a valid one.\nCopy the content of the source file into a destination file. If destination file already exists, it should be overwritten.\nIf source file contains holes, the destination file should also contain hole as is.\nPrint overall amount of bytes copied to the destination file including total amount of physical data and total amount of holes if any.","expected-result#Expected result":"The resulting application should be able to build and execute from command line as follows:\nAfter copy is completed, program should print following message to the console:\nThe logical and physical sizes of source and destination files should match exactly.The final solution should contain a Makefile for the multi-stage build. The Makefile should also contain targets all and clean. It's recommended to have compiler and compiler flags to be declared as a Makefile variables. Alternatively, cmake could also be used instead of make."}},"/linux-programming/tasks/do-command":{"title":"PS-1: Do command","data":{"description#Description":"Your task is to implement a C++ program that accepts a command name and command arguments with command-line arguments and executes it in a new process.","requirements#Requirements":"Write a C++ program called \"do-command\" that takes N arguments as an input.\nAssume that first argument is command name and others are arguments for the given command.\nA program should contain a special function do_command(char** argv), where argv is null-terminated vector of arguments.\nThe function \"do_command\" should create a new process, execute the given command with the given arguments and wait for its completion.\nAfter program execution is done, do_function should print exit status of the command and the duration of the command execution.\nThe \"main\" function of the program is responsible for building proper argument vector and using do_command function to execute the command.","expected-result#Expected result":"The resulting application should be able to build and execute from command line as follows:\nThe command is expected to print program output to the console and a line as follows:\nThe final solution should contain a Makefile for the multi-stage build. The Makefile should also contain targets all and clean. It's recommended to have compiler and compiler flags to be declared as a Makefile variables. Alternatively, cmake could also be used instead of make."}},"/linux-programming/tasks/environment-setup":{"title":"ENV-1: Setup GNU/Linux Environment","data":{"requirements#Requirements":"Install any GNU/Linux distribution on a Virtual or Physical Machine.\nRun lsb_release -a >> $USER.txt command (if available) in a shell and get the result.\nRun cat /etc/os-release >> $USER.txt command (if available) in a shell and get the result.\nSubmit $USER.txt file to the Github as a solution for the task.","expected-output#Expected output":"The expected output is a text file named $USER.txt where $USER is the current user's username. The content is expected to be similar to the following:"}},"/linux-programming/tasks/interactive-shell":{"title":"PS-2: Interactive shell","data":{"requirements#Requirements":"Write a C++ program that implements an interactive shell with an infinite loop waiting for a command.\nOn every iteration of the loop a command string is passed to the shell program.\nA command can be either a name of command or a path (relative or absolute).\nAfter command is entered, program should create a new process to run the command.\nThe current directory of the shell program should be temporarily added to the PATH variable of every new process.\nIf \"exit\" command is entered, shell program should stop and exit with a success code.\nIf entered command starts with word \"silent\", the executing command should redirect the standard output and error streams into the PID.log file where PID is the process id of the child process.","expected-result#Expected result":"The resulting application should be able to build and execute from command line as follows:\nUser may enter commands as follows:\nor\nor\nand the command should print the output to the console.Also user may want to enter commands as follows\nand the output of program ls should be redirected into the file PID.log where PID is the identifier of the child process.The final solution should contain a Makefile for the multi-stage build. The Makefile should also contain targets all and clean. It's recommended to have compiler and compiler flags to be declared as a Makefile variables. Alternatively, cmake could also be used instead of make."}},"/linux-programming/tasks/manual-append":{"title":"FS-5: Manaul append","data":{"description#Description":"Your task is to write a program on C/C++ that writes two lines in the files \"first line\" and \"second line\".\nWriting should happen into two different file descriptors but write into the same file.","requirements#Requirements":"Write a C/C++ program that gets the filepath with the first argument and opens it.\nFile should not be opened with the O_APPEND file.\nYou are not allowed to use seek/lseek to move the cursor to the end.\nThe program writes two lines: \"first line\" and \"second line\". Each line is written in a different descriptor.\nAfter write, the file should contain both lines in the same file.\nHint: you may use dup/dup2.","expected-result#Expected result":"The resulting application should be able to build and execute from command line as follows:\nThe output file should contain the following text:\nThe final solution should contain a Makefile for the multi-stage build. The Makefile should also contain targets all and clean. It's recommended to have compiler and compiler flags to be declared as a Makefile variables. Alternatively, cmake could also be used instead of make."}},"/linux-programming/tasks/prime-calculator":{"title":"IPC-2: Prime calculator","data":{"requirements#Requirements":"Write a C++ program that creates a child process.\nThe main process infinitely waits for the user's input integer m.\nOnce number m is received by the main process, it gets passed to the child process via anonymous pipe.\nThe child process takes m from the anonymous pipe and calculates the m-th prime number.\nThe child process should send the result of the calculation back to the parent process, which, should print it and wait for the next input.\nIf the \"exit\" command is entered, the main process should stop its execution.","expected-result#Expected result":"The resulting application should be able to build and execute from the command line as follows:\nThe typical execution of the program should look like the following:\nThe final solution should contain a Makefile for the multi-stage build. The Makefile should also contain targets all and clean. It's recommended to have compiler and compiler flags declared as Makefile variables. Alternatively, cmake could also be used instead of make."}},"/linux-programming/tasks/read-file":{"title":"FS-1: Read from the file","data":{"description#Description":"You need to implement a program that does the same thing as the cat command in the Linux.","requirements#Requirements":"Write a C++ program read-file accepting a file path as an argument.\nImplement proper error handling to make sure required file path is passed.\nOpen the given file with proper mode and make sure errors are handled.\nRead the content of the file into a buffer until reaching the end of the file.\nPrint every portion of the file read in the iteration.\nHint: if you use printf or std::cin, make sure your strings are terminated with '\\0' symbol.","expected-result#Expected result":"The resulting application should be able to build and execute from command line as follows:\nThe program should output the content of the input.txt file on the screen.The final solution should contain a Makefile for the multi-stage build. The Makefile should also contain targets all and clean. It's recommended to have compiler and compiler flags to be declared as a Makefile variables. Alternatively, cmake could also be used instead of make."}},"/linux-programming/tasks/redirect-cin":{"title":"FS-4: Redirect standard input","data":{"description#Description":"By default, program gets standard input waiting for the keyboard input. Your task is to make any program to read input from the file instead of waiting for the keyboard input without changing usages of std::cin or scanf.","requirements#Requirements":"Write a C++ program named \"redirect-cin\" that accepts a path to a file as a command-line argument.\nImplement the function initialize(int argc, char** argv) to start reading from the given file with a proper error handling.\nImplement a simple logic for main() function to read string from the standard input (std::cin) and print the reversed string to the cosnsole (std::out).\nIf there is an error with given file, the program should terminate with the proper error code.\nThe program's main source file should look like:\nHint: you can use one of dup() functions.","expected-result#Expected result":"The resulting application should be able to build and execute from command line as follows:\nAnd, assuming input file contains the text \"123456789\", the program should output the following:\nThe final solution should contain a Makefile for the multi-stage build. The Makefile should also contain targets all and clean. It's recommended to have compiler and compiler flags to be declared as a Makefile variables. Alternatively, cmake could also be used instead of make."}},"/linux-programming/tasks/secure-file-deletion":{"title":"FS-3: Secure file deletion","data":{"description#Description":"Your task is to implement a C++ program that deletes the file from the filesystem along with its content by replacing every byte in the files with '\\0' character.","requirements#Requirements":"Write a C++ program named \"hacker-rm\" that accepts a path to a file as a command-line argument.\nImplement proper error handling to check if the file exists and if the input path is valid.\nOpen the file for writing and replace every byte with the null character ('\\0').\nRemove the file from the file system after overwriting its content.\nEnsure that your program works for various file sizes and types.\nHint: you can use write, stat, lseek, unlink function to solve the problem.","expected-result#Expected result":"The resulting application should be able to build and execute from command line as follows:\nThe final solution should contain a Makefile for the multi-stage build. The Makefile should also contain targets all and clean. It's recommended to have compiler and compiler flags to be declared as a Makefile variables. Alternatively, cmake could also be used instead of make."}},"/linux-programming/tasks/shared-array":{"title":"IPC-3: Shared array implementation","data":{"requirements#Requirements":"Write a C++ class implementing a module shared_array which is an array of integers shared between processes.\nThe class is supposed to be initialized as follows: shared_array array(\"array-name\", size);\nThe size of the array (number of elements) could be between 1 and 1 000 000 000\nTwo shared arrays are the same in the system if they have equal names and sizes, otherwise, they are different.\nThe class should provide operator [] for indexing an element with a given index i.\nAny process that knows the name and the size of the array should be able to use it.\nWrite two infinite programs (first and second) to work with the shared array using cross-process semaphore.","expected-result#Expected result":"The resulting application should be able to build from the command line as follows:\nThe execution of the program should demonstrate how the array changes from the first and second processes.The final solution should contain a Makefile for the multi-stage build. The Makefile should also contain targets all and clean. It's recommended to have compiler and compiler flags declared as Makefile variables. Alternatively, cmake could also be used instead of make."}},"/linux-programming/tasks/signal-echo":{"title":"IPC-1: Signal echo","data":{"requirements#Requirements":"Write a C++ program that prints its PID and registers a signal handler for SIGUSR1.\nThe handler of the signal SIGUSR1 is suppose to react by printing the following information:\nThe PID of the sender process,\nThe UID and the user name of the sender,\nThe current values of the EIP, EAX, EBX registers.\nProgram should enter an infinite loop and perform a sleeping delay on each iteration (example: sleep for 10 seconds).","expected-result#Expected result":"The resulting application should be able to build and execute from command line as follows:\nThen, once any other process sends SIGUSR1 signal to our process, it should print the following information:\nThe final solution should contain a Makefile for the multi-stage build. The Makefile should also contain targets all and clean. It's recommended to have compiler and compiler flags to be declared as a Makefile variables. Alternatively, cmake could also be used instead of make."}},"/linux-programming/tasks/thread-pool":{"title":"TH-2: The thread pool implementation","data":{"requirements#Requirements":"Create a C++ library (shared object) that implements a simple thread pool\nThread pool should be implemented as a class called \"parallel_scheduler\"\nThread pool takes a capacity argument in the constructor as a maximum number of threads in the pool.\nThread pool defines a method run that takes as an input two arguments function and the argument.\nAll the functions given to the \"run\" method are enqueued and the thread pool should execute them as soon as any of its threads gets time.\nNext, another executable application is implemented to demonstrate the usage of the thread pool library.\nThe demonstration application should enqueue various functions for the execution (more than the capacity).\nThe module \"parallel_scheduler\" should be compiled as a shared library (parallel_scheduler.so) and should be linked with the demo application.","expected-result#Expected result":"The resulting application should be able to build and execute from command line as follows:\nThe final solution should contain a Makefile for the multi-stage build. The Makefile should also contain targets all and clean. It's recommended to have compiler and compiler flags to be declared as a Makefile variables. Alternatively, cmake could also be used instead of make."}},"/linux-programming/topics":{"title":"Topics","data":{}},"/linux-programming/topics/hardware-and-software":{"title":"Hardware and Software","data":{"overview#Overview":"Understanding the fundamental concepts of hardware and software.\nExploring the main components of a computer system.","outline#Outline":"","what-is-a-computer#What is a Computer?":"Defining the essential components and their functions.\nHighlighting the interplay between hardware and software.","operating-system-basics#Operating System Basics":"Providing a concise definition of an operating system.\nExploring the crucial role it plays in managing resources and providing user interfaces.","unix-gnu-and-free-software#UNIX, GNU, and Free Software":"Unveiling the significance of UNIX in computing history.\nUnderstanding the philosophy behind GNU and the concept of free software.","kernels-overview#Kernels: Overview":"Introduction to kernels and their role as the core of operating systems.\nExamining different kernels such as Minix, Linux, and BSD.","gnulinux-distributions#GNU/Linux Distributions":"Surveying the landscape of GNU/Linux distributions.\nDiscussing popular distributions and their unique features.","references#References":"Operating Systems: Wiki\nKernel: Wiki\nFree Software and Open-Source\nWhat is Kernel\nMicrokernel and Monolithic Kernel\nComputer Basics: Inside a Computer\nGNU/Linux Distributions\nDistributions Tree","practice#Practice":"","setting-up-a-virtual-machine-with-gnulinux#Setting Up a Virtual Machine with GNU/Linux":"Practical guide to creating a virtual environment for hands-on experience.\nEmphasizing the importance of virtualization in system programming.","command-line-mastery#Command Line Mastery":"Utilizing the command line for fundamental operations.\nHands-on practice with file manipulation, software installation, and more.","development-environment-setup#Development Environment Setup":"Configuring essential tools like Git, gcc/g++, and make for efficient programming.\nEstablishing a robust development environment for system programming tasks.","github-repository-setup#GitHub Repository Setup":"Understanding key concepts for version control with Git.\nCreating and managing repositories on GitHub for organized collaboration.","overview-of-existing-gnulinux-distributions#Overview of Existing GNU/Linux Distributions":"In-depth exploration of prominent GNU/Linux distributions.\nInsight into the strengths and use-cases of different distributions.","references-1#References":"Download VirtualBox\nDownload Ubuntu\nInstall Ubuntu in VirtualBox\nGit and GitHub\nGit Username Setup\nGit Commit Email Setup"}},"/linux-programming/topics/system-calls":{"title":"System calls, hardware-software communication, POSIX standard.","data":{"overview#Overview":"Understanding the essential aspects of communication between hardware and software.\nExploring the functionality exposed by operating systems and the role of System Calls.\nIntroduction to the POSIX standard for hardware and software compatibility.","topic-outline#Topic Outline":"","how-cpu-and-memory-work-together#How CPU and Memory Work Together?":"Explaining the synergy between the CPU and RAM in a computer system.\nUnderstanding the fundamental principles of memory management.","kernel-communication-with-cpu-ram-and-devices#Kernel Communication with CPU, RAM, and Devices":"Unraveling the mechanisms through which the Kernel communicates with critical components.\nInsight into the role of the Kernel in managing hardware resources.","operating-system-functionality-for-application-development-system-calls#Operating System Functionality for Application Development: System Calls":"Examining the functionality exposed by the operating system for application development.\nUnderstanding the significance of System Calls in facilitating communication between applications and the OS.","introduction-to-posix-standard#Introduction to POSIX Standard":"Exploring the POSIX standard and its importance for ensuring hardware and software compatibility.\nDiscussing key POSIX concepts and their impact on cross-platform development.","references#References":"The Fetch-Execute Cycle\nSystem Calls\nSystem Calls: Wiki\nPOSIX Standard Explained","practice#Practice":"","using-gnulinux-as-a-development-environment#Using GNU/Linux as a Development Environment":"Practical guidance on leveraging GNU/Linux for efficient development.\nIncorporating essential tools and practices for seamless system programming.","overview-of-git-and-repository-setup#Overview of Git and Repository Setup":"Brief overview of Git for version control and collaboration.\nStep-by-step guide on setting up repositories for homework assignments.","basic-shell-commands-and-inputoutput-operations#Basic Shell Commands and Input/Output Operations":"Hands-on experience with fundamental shell commands.\nExploring standard input and output operations, including redirection and piping.","high-level-introduction-to-shell-scripting#High-Level Introduction to Shell Scripting":"Introduction to the basics of shell scripting.\nUnderstanding the power of automation through simple script creation.","references-1#References":"The Missing Semester of Your CS Education\nMissing Semester: The Shell\nMissing Semester: Shell Tools and Scripting\nMissing Semester: Editors (vim)\nMissing Semester: Version Control (git)"}},"/operating-systems":{"title":"Getting Started","data":{}},"/operating-systems/topics":{"title":"Topics","data":{"":"This is topics outline"}},"/operating-systems/topics/introduction":{"title":"Introduction","data":{"":"This is an intro"}}}