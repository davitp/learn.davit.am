{"/":{"title":"Home","data":{}},"/system-programming/guides":{"title":"Guides","data":{}},"/system-programming/guides/compilation":{"title":"Compilation and build process","data":{"":"The set of samples showcases different aspects of the compilation process in the Linux environment using various tools such as gcc, make, cmake, etc.","single-file-compilation#Single file compilation":"Consider main.cpp as a source file containing the whole logic of the application:\nTo compile the source code into an executable file execute the following line in the source directory:\nwhere parameter -o app defines the name of the output file (a.out by default).If the command completes successfully, the source directory will contain a file called app that is ready to execute as follows:","pre-processing-a-c-source-file#Pre-processing a C++ source file":"You may want to stop the compiler after the pre-processing phase when all the directives such as include, define, etc. are resolved.\nIn that case you will need to run the pass the -E flag to the compiler as follows:\nThe result of the command prints the result on a console by default, hence we redirected the content to be written to file \"preprocessed-main.cpp\" by using redirection operator (>) of shell.","translation-of-the-source#Translation of the source":"You may also want to stop the compiler after the translation phase to get the low-level code in assembler language. For that you need to pass -S flag to the compiler. It will generate a new file with .s extension by default:\nAfter the command is completed successfully you will get a main.s file containing your source in assembler language. The file will contain something like this:","assembling-the-compiled-file#Assembling the compiled file":"Most commonly, you will need to compile your source file to a binary object file containing your source code in a binary format, but not ready to execute. Object files are generated by passing -c to the compiler. By default a file with \".o\" extension will be generated:\nAfter this command, a file named main.o will be generated.","linking-object-files#Linking object files":"In most of the cases, you will have many source files compiled into object files separately and after all object files are ready you will link those together and add necessary libraries. For example, if you have files main.o, module1.o and module2.o you will need to link those together into an executable file (or a library):\nAfter this command, a file named \"a.out\" will be generated and will be ready to run.Also, you may want to see the libraries your executable is linked to using the following command:\nIn this basic example, your executable will be linked with the standard libraries as follows:"}},"/system-programming/samples":{"title":"Samples","data":{}},"/system-programming":{"title":"Getting started","data":{"":"This course introduces students to system programming in Linux, focusing on how applications interact directly with the operating system through the kernel API. Students will move from basic exploration of the Linux environment to writing programs that manage files, processes, threads, interprocess communication, and network connections.","sections#Sections":"","bibliography#Bibliography":"Programming via Operating Systems, Vahram Martirosyan, Feb 2022\nThe Art of Unix Programming, Eric S. Raymond\nW. Richard Stevens & Stephen A. Rago — Advanced Programming in the UNIX Environment (APUE), 3rd Edition\nW. Richard Stevens — UNIX Network Programming, Volume 1: The Sockets Networking API, 3rd Edition\nRemzi H. Arpaci-Dusseau & Andrea C. Arpaci-Dusseau — Operating Systems: Three Easy Pieces (OSTEP) read online\nMichael Kerrisk — The Linux Programming Interface (TLPI)\nThe Linux man-pages project read online\nBeej’s Guides read online\nOperating Systems: Design and Implementation, Andrew S. Tanenbaum Albert S. Woodhull, Jan 1997\nRobert Love — Linux System Programming (O’Reilly, 2nd Ed.)\nBrian W. Kernighan & Dennis M. Ritchie — The C Programming Language (K&R)\nStructured Computer Organization, Andrew S. Tanenbaum, Jan 1984\nOperating system design: the XINU approach, D. Comer Timothy V. Fossum, Jan 1984\nModern operating systems (2. ed.).,  Andrew S. Tanenbaum, Jan 2001\nLinux Kernel in a nutshell, Greg Kroah-Hartman, Jan 2006"}},"/system-programming/samples/copy-file":{"title":"Copy the given file","data":{"":"This sample demonstrates how to implement a basic copy program using read and write functions.\nThe file can be compiled with the following command:\nRunning the resulting application ./copy source-file.txt new-file.txt duplicate source-file.txt with name new-file.txt."}},"/system-programming/samples/create-process":{"title":"Creating a process","data":{"":"The sample demonstrates how to create a process using fork() function.\nThe file can be compiled and executed as follows:\nThe program is supposed to start a process and clone itself printing appropriate messages as follows:"}},"/system-programming/samples/create-thread":{"title":"Creating a thread","data":{"":"The sample demonstrates how to create a thread using pthread_create() function and wait for its completion.\nThe file can be compiled and executed as follows:\nThe program is supposed to print + and - signs without any particular order as follows:"}},"/system-programming/samples/detect-holes":{"title":"Detect holes in the file","data":{"":"The sample demonstrates how to detect data and hole segments in the given file.\nThe file can be compiled and executed as follows:\nThe program is supposed to print start and end indexes of all the data and hole segments if any."}},"/system-programming/samples/make-hole":{"title":"Create a file with holes","data":{"":"This sample demonstrates the ability to create a sparse file containing both data segments and holes using lseek function.\nThe program is expected to accept the target file name as a first argument and sequence of sizes for created data and hole segments in the file.\nThe file can be compiled and executed as follows:\nAfter successful completion of the program, we will have file \"file_with_holes\" created containing 2 data segments of size 4096 and 2 holes of size 4096."}},"/system-programming/samples/makefile":{"title":"Compiling multiple files using Makefile","data":{"":"In this sample, we will compile a program having two modules with Makefile.The program will contain two modules:\nmain.cpp - the main logic of the application\nmessage.cpp - a module that can simply print messages\nLet's assume the main.cpp contains the following logic:\nThe file message.h contains only a declaration of the used function:\nThen the module message.cpp should implement the mentioned function as follows:\nWe can manually compile the modules one by one as follows:\nThen, having two modules main.o and message.o we can build the final executable by linking those together:\nTo automate the process we could also write a Makefile as follows:\nNow, invoking make command will create all the necessary files for the program.You may also want to clean the build output with a special clean target as follows:"}},"/system-programming/samples/open-file":{"title":"Opening a file","data":{"":"This sample demonstrates the usage of functions open and close.\nThe file can be compiled with the following command:\nRunning the resulting application ./open should create a file named foo.txt and print the following result:"}},"/system-programming/samples/redirect-output":{"title":"Redirect standard output and error","data":{"":"This sample demonstrates how to redirect standard output and standard error into a file (using dup/dup2) while keeping possibility to write to the console when needed.\nThe file can be compiled with the following command:\nRunning the resulting application ./redirect is supposed to print \"Hello\" on the console screen and create a file output.log containing cout and cerr text."}},"/system-programming/samples/read-file":{"title":"Reading file contents","data":{"":"This sample demonstrates how to read a text file using read() function.\nThe file can be compiled with the following command:\nRunning the resulting application ./read some-file.txt will print the contents of the given file to the console."}},"/system-programming/tasks":{"title":"Tasks","data":{}},"/system-programming/tasks/environment":{"title":"Environment","data":{}},"/system-programming/tasks/environment/complex-number":{"title":"ENV-2: Complex numbers and sorting","data":{"requirements#Requirements":"Write multi-file C++ program consisting of following 3 modules:\nA class that represents a complex number along with all the basic operations: plus, minus, multiply by a constant, absolute value.\nA function that implements any sorting algorithm on an array/vector of complex numbers.\nA main function containing a demonstration of having multiple complex numbers in array and sorting them.\nModules for complex number class and sorting algorithm should be separate and each of them should have source and header files.","expected-result#Expected result":"A solution containing all the described modules (source and header files), as well as, a Makefile for automated build of the solution.The final solution should contain a Makefile for the multi-stage build. The Makefile should also contain targets all and clean. It's recommended to have compiler and compiler flags to be declared as a Makefile variables. Alternatively, cmake could also be used instead of make."}},"/system-programming/tasks/environment/environment-setup":{"title":"ENV-1: Setup GNU/Linux Environment","data":{"requirements#Requirements":"Install any GNU/Linux distribution on a Virtual or Physical Machine.\nRun lsb_release -a >> $USER.txt command (if available) in a shell and get the result.\nRun cat /etc/os-release >> $USER.txt command (if available) in a shell and get the result.\nSubmit $USER.txt file to the Github as a solution for the task.","expected-output#Expected output":"The expected output is a text file named $USER.txt where $USER is the current user's username. The content is expected to be similar to the following:"}},"/system-programming/tasks/file-systems":{"title":"File Systems","data":{}},"/system-programming/tasks/file-systems/copy-file":{"title":"FS-2: Copy a file","data":{"requirements#Requirements":"Write a C++ program simple-copy accepting two command line arguments representing source file path and destination file path.\nImplement proper error handling to account if not all arguments are passed or if one of arguments is not a valid one.\nCopy the content of the source file into a destination file. If destination file already exists, it should be overwritten.","expected-result#Expected result":"The resulting application should be able to build and execute from command line as follows:\nThe final solution should contain a Makefile for the multi-stage build. The Makefile should also contain targets all and clean. It's recommended to have compiler and compiler flags to be declared as a Makefile variables. Alternatively, cmake could also be used instead of make."}},"/system-programming/tasks/file-systems/copy-with-holes":{"title":"FS-10: Copy a file accounting holes","data":{"requirements#Requirements":"Write a C++ program accepting two command line arguments representing source file path and destination file path.\nImplement proper error handling to account if not all arguments are passed or if one of arguments is not a valid one.\nCopy the content of the source file into a destination file. If destination file already exists, it should be overwritten.\nIf source file contains holes, the destination file should also contain hole as is.\nPrint overall amount of bytes copied to the destination file including total amount of physical data and total amount of holes if any.","expected-result#Expected result":"The resulting application should be able to build and execute from command line as follows:\nAfter copy is completed, program should print following message to the console:\nThe logical and physical sizes of source and destination files should match exactly.The final solution should contain a Makefile for the multi-stage build. The Makefile should also contain targets all and clean. It's recommended to have compiler and compiler flags to be declared as a Makefile variables. Alternatively, cmake could also be used instead of make."}},"/system-programming/tasks/file-systems/manual-append":{"title":"FS-5: Manaul append","data":{"description#Description":"Your task is to write a program on C/C++ that writes two lines in the files \"first line\" and \"second line\".\nWriting should happen into two different file descriptors but write into the same file.","requirements#Requirements":"Write a C/C++ program that gets the filepath with the first argument and opens it.\nFile should not be opened with the O_APPEND file.\nYou are not allowed to use seek/lseek to move the cursor to the end.\nThe program writes two lines: \"first line\" and \"second line\". Each line is written in a different descriptor.\nAfter write, the file should contain both lines in the same file.\nHint: you may use dup/dup2.","expected-result#Expected result":"The resulting application should be able to build and execute from command line as follows:\nThe output file should contain the following text:\nThe final solution should contain a Makefile for the multi-stage build. The Makefile should also contain targets all and clean. It's recommended to have compiler and compiler flags to be declared as a Makefile variables. Alternatively, cmake could also be used instead of make."}},"/system-programming/tasks/file-systems/read-file":{"title":"FS-1: Read from the file","data":{"description#Description":"You need to implement a program that does the same thing as the cat command in the Linux.","requirements#Requirements":"Write a C++ program read-file accepting a file path as an argument.\nImplement proper error handling to make sure required file path is passed.\nOpen the given file with proper mode and make sure errors are handled.\nRead the content of the file into a buffer until reaching the end of the file.\nPrint every portion of the file read in the iteration.\nHint: if you use printf or std::cin, make sure your strings are terminated with '\\0' symbol.","expected-result#Expected result":"The resulting application should be able to build and execute from command line as follows:\nThe program should output the content of the input.txt file on the screen.The final solution should contain a Makefile for the multi-stage build. The Makefile should also contain targets all and clean. It's recommended to have compiler and compiler flags to be declared as a Makefile variables. Alternatively, cmake could also be used instead of make."}},"/system-programming/tasks/file-systems/secure-file-deletion":{"title":"FS-3: Secure file deletion","data":{"description#Description":"Your task is to implement a C++ program that deletes the file from the filesystem along with its content by replacing every byte in the files with '\\0' character.","requirements#Requirements":"Write a C++ program named \"hacker-rm\" that accepts a path to a file as a command-line argument.\nImplement proper error handling to check if the file exists and if the input path is valid.\nOpen the file for writing and replace every byte with the null character ('\\0').\nRemove the file from the file system after overwriting its content.\nEnsure that your program works for various file sizes and types.\nHint: you can use write, stat, lseek, unlink function to solve the problem.","expected-result#Expected result":"The resulting application should be able to build and execute from command line as follows:\nThe final solution should contain a Makefile for the multi-stage build. The Makefile should also contain targets all and clean. It's recommended to have compiler and compiler flags to be declared as a Makefile variables. Alternatively, cmake could also be used instead of make."}},"/system-programming/tasks/file-systems/redirect-cin":{"title":"FS-4: Redirect standard input","data":{"description#Description":"By default, program gets standard input waiting for the keyboard input. Your task is to make any program to read input from the file instead of waiting for the keyboard input without changing usages of std::cin or scanf.","requirements#Requirements":"Write a C++ program named \"redirect-cin\" that accepts a path to a file as a command-line argument.\nImplement the function initialize(int argc, char** argv) to start reading from the given file with a proper error handling.\nImplement a simple logic for main() function to read string from the standard input (std::cin) and print the reversed string to the cosnsole (std::out).\nIf there is an error with given file, the program should terminate with the proper error code.\nThe program's main source file should look like:\nHint: you can use one of dup() functions.","expected-result#Expected result":"The resulting application should be able to build and execute from command line as follows:\nAnd, assuming input file contains the text \"123456789\", the program should output the following:\nThe final solution should contain a Makefile for the multi-stage build. The Makefile should also contain targets all and clean. It's recommended to have compiler and compiler flags to be declared as a Makefile variables. Alternatively, cmake could also be used instead of make."}},"/system-programming/tasks/ipc":{"title":"IPC","data":{}},"/system-programming/tasks/ipc/prime-calculator":{"title":"IPC-2: Prime calculator","data":{"requirements#Requirements":"Write a C++ program that creates a child process.\nThe main process infinitely waits for the user's input integer m.\nOnce number m is received by the main process, it gets passed to the child process via anonymous pipe.\nThe child process takes m from the anonymous pipe and calculates the m-th prime number.\nThe child process should send the result of the calculation back to the parent process, which, should print it and wait for the next input.\nIf the \"exit\" command is entered, the main process should stop its execution.","expected-result#Expected result":"The resulting application should be able to build and execute from the command line as follows:\nThe typical execution of the program should look like the following:\nThe final solution should contain a Makefile for the multi-stage build. The Makefile should also contain targets all and clean. It's recommended to have compiler and compiler flags declared as Makefile variables. Alternatively, cmake could also be used instead of make."}},"/system-programming/tasks/ipc/shared-array":{"title":"IPC-3: Shared array implementation","data":{"requirements#Requirements":"Write a C++ class implementing a module shared_array which is an array of integers shared between processes.\nThe class is supposed to be initialized as follows: shared_array array(\"array-name\", size);\nThe size of the array (number of elements) could be between 1 and 1 000 000 000\nTwo shared arrays are the same in the system if they have equal names and sizes, otherwise, they are different.\nThe class should provide operator [] for indexing an element with a given index i.\nAny process that knows the name and the size of the array should be able to use it.\nWrite two infinite programs (first and second) to work with the shared array using cross-process semaphore.","expected-result#Expected result":"The resulting application should be able to build from the command line as follows:\nThe execution of the program should demonstrate how the array changes from the first and second processes.The final solution should contain a Makefile for the multi-stage build. The Makefile should also contain targets all and clean. It's recommended to have compiler and compiler flags declared as Makefile variables. Alternatively, cmake could also be used instead of make."}},"/system-programming/tasks/ipc/signal-echo":{"title":"IPC-1: Signal echo","data":{"requirements#Requirements":"Write a C++ program that prints its PID and registers a signal handler for SIGUSR1.\nThe handler of the signal SIGUSR1 is suppose to react by printing the following information:\nThe PID of the sender process,\nThe UID and the user name of the sender,\nThe current values of the EIP, EAX, EBX registers.\nProgram should enter an infinite loop and perform a sleeping delay on each iteration (example: sleep for 10 seconds).","expected-result#Expected result":"The resulting application should be able to build and execute from command line as follows:\nThen, once any other process sends SIGUSR1 signal to our process, it should print the following information:\nThe final solution should contain a Makefile for the multi-stage build. The Makefile should also contain targets all and clean. It's recommended to have compiler and compiler flags to be declared as a Makefile variables. Alternatively, cmake could also be used instead of make."}},"/system-programming/tasks/processes":{"title":"Processes","data":{}},"/system-programming/tasks/processes/do-command":{"title":"PS-1: Do command","data":{"description#Description":"Your task is to implement a C++ program that accepts a command name and command arguments with command-line arguments and executes it in a new process.","requirements#Requirements":"Write a C++ program called \"do-command\" that takes N arguments as an input.\nAssume that first argument is command name and others are arguments for the given command.\nA program should contain a special function do_command(char** argv), where argv is null-terminated vector of arguments.\nThe function \"do_command\" should create a new process, execute the given command with the given arguments and wait for its completion.\nAfter program execution is done, do_function should print exit status of the command and the duration of the command execution.\nThe \"main\" function of the program is responsible for building proper argument vector and using do_command function to execute the command.","expected-result#Expected result":"The resulting application should be able to build and execute from command line as follows:\nThe command is expected to print program output to the console and a line as follows:\nThe final solution should contain a Makefile for the multi-stage build. The Makefile should also contain targets all and clean. It's recommended to have compiler and compiler flags to be declared as a Makefile variables. Alternatively, cmake could also be used instead of make."}},"/system-programming/tasks/processes/interactive-shell":{"title":"PS-2: Interactive shell","data":{"requirements#Requirements":"Write a C++ program that implements an interactive shell with an infinite loop waiting for a command.\nOn every iteration of the loop a command string is passed to the shell program.\nA command can be either a name of command or a path (relative or absolute).\nAfter command is entered, program should create a new process to run the command.\nThe current directory of the shell program should be temporarily added to the PATH variable of every new process.\nIf \"exit\" command is entered, shell program should stop and exit with a success code.\nIf entered command starts with word \"silent\", the executing command should redirect the standard output and error streams into the PID.log file where PID is the process id of the child process.","expected-result#Expected result":"The resulting application should be able to build and execute from command line as follows:\nUser may enter commands as follows:\nor\nor\nand the command should print the output to the console.Also user may want to enter commands as follows\nand the output of program ls should be redirected into the file PID.log where PID is the identifier of the child process.The final solution should contain a Makefile for the multi-stage build. The Makefile should also contain targets all and clean. It's recommended to have compiler and compiler flags to be declared as a Makefile variables. Alternatively, cmake could also be used instead of make."}},"/system-programming/tasks/threads":{"title":"Threads","data":{}},"/system-programming/tasks/threads/array-sum":{"title":"TH-1: The array summary","data":{"requirements#Requirements":"Write a C++ program creates an array of N elements (N > 1 000 000).\nInitialize the array with random values at the beginning.\nCompute summary of the array using a regular for loop and calculate the time spent for the operation.\nCreate M threads to sum the same array with multiple threads, considering that every thread gets an equal portion to sum, except, maybe, the last one.\nWait for all the threads to complete and measure the time spent for summing the array using M threads.\nPrint the durations spent to sum the array with and without threads.\nNote that N and M variables should be passed to the program via command line arguments.","expected-result#Expected result":"The resulting application should be able to build and execute from command line as follows:\nand the command should print the output to the console as follows:\nThe final solution should contain a Makefile for the multi-stage build. The Makefile should also contain targets all and clean. It's recommended to have compiler and compiler flags to be declared as a Makefile variables. Alternatively, cmake could also be used instead of make."}},"/system-programming/tasks/threads/thread-pool":{"title":"TH-2: The thread pool implementation","data":{"requirements#Requirements":"Create a C++ library (shared object) that implements a simple thread pool\nThread pool should be implemented as a class called \"parallel_scheduler\"\nThread pool takes a capacity argument in the constructor as a maximum number of threads in the pool.\nThread pool defines a method run that takes as an input two arguments function and the argument.\nAll the functions given to the \"run\" method are enqueued and the thread pool should execute them as soon as any of its threads gets time.\nNext, another executable application is implemented to demonstrate the usage of the thread pool library.\nThe demonstration application should enqueue various functions for the execution (more than the capacity).\nThe module \"parallel_scheduler\" should be compiled as a shared library (parallel_scheduler.so) and should be linked with the demo application.","expected-result#Expected result":"The resulting application should be able to build and execute from command line as follows:\nThe final solution should contain a Makefile for the multi-stage build. The Makefile should also contain targets all and clean. It's recommended to have compiler and compiler flags to be declared as a Makefile variables. Alternatively, cmake could also be used instead of make."}},"/system-programming/topics":{"title":"Topics","data":{}},"/system-programming/topics/advanced-io":{"title":"Advanced File I/O","data":{"overview#Overview":"This week extends the foundation of Linux file I/O by exploring advanced file descriptor manipulation and low-level file positioning.\nStudents will learn how to duplicate file descriptors, control file behavior using fcntl, and manage files beyond simple read/write operations — including seeking, truncation, and sparse file handling.By the end of this week, students will have a complete understanding of how Linux manages file descriptors and how processes interact with files efficiently and flexibly.","key-concepts#Key Concepts":"","file-descriptor-duplication#File Descriptor Duplication":"dup() and dup2() system calls\nFile descriptor table and shared open file descriptions\nStandard output redirection example with dup2()\nRelationship between dup2() and shell redirection","file-positioning#File Positioning":"The lseek() system call: repositioning file offsets\nSeeking modes:\nSEEK_SET – from beginning\nSEEK_CUR – from current position\nSEEK_END – from end of file\nPractical uses: appending, measuring file size, random access","sparse-files-and-holes#Sparse Files and Holes":"Concept of holes (unallocated regions in files)\nCreating and inspecting sparse files\nComparing allocated and logical sizes\nSEEK_DATA and SEEK_HOLE (modern extensions for efficient traversal)","file-control-and-management#File Control and Management":"The fcntl() system call:\nDuplicating descriptors (F_DUPFD)\nManaging flags (FD_CLOEXEC, O_APPEND, O_NONBLOCK)\nTruncating files with ftruncate()\nRetrieving file information with fstat()","practice--lab#Practice / Lab":"","descriptor-duplication#Descriptor Duplication":"Redirect program output to files using file descriptor duplication.\nExplore descriptor inheritance and redirection behavior.","file-positioning-and-sparse-files#File Positioning and Sparse Files":"Create files with gaps using lseek() to demonstrate sparse allocation.\nCompare logical and physical file sizes using shell utilities.","file-control-and-metadata#File Control and Metadata":"Use fcntl() to retrieve and modify descriptor properties.\nTruncate and inspect file length using system utilities.","homework#Homework":"FS-4: Redirect standard input\nFS-5: Manaul append\nFS-10: Copy a file accounting holes","samples#Samples":"Redirect standard output and error\nCreate a file with holes\nDetect holes in the file","references--resources#References & Resources":"Required\nKerrisk, The Linux Programming Interface\nChapter 5: File I/O – Deeper Concepts\nChapter 6: Advanced File I/O\nRecommended\nUnderstanding Sparse Files (Red Hat)\nBeej’s Guide – File Descriptors\nLinux manual page - fcntl(2)\nLinux manual page - dup(2)\nLinux manual page - lseek(3p)\nlseek() in C/C++ to read the alternate nth byte and write it in another file","quiz-self-check#Quiz (Self-check)":"What happens to the file offset when a descriptor is duplicated?\nHow does dup2() differ from shell redirection?\nWhat is the difference between SEEK_END and SEEK_CUR?\nHow does a sparse file conserve storage space?\nWhat are the purposes of SEEK_DATA and SEEK_HOLE?\nWhat does FD_CLOEXEC accomplish in practice?","suggested-tools#Suggested Tools":"strace – observe system calls like dup2 and lseek\nls, du, stat – inspect logical and physical file properties\nhexdump – verify data placement within sparse files"}},"/system-programming/topics/basic-io":{"title":"System Calls and Basic File I/O","data":{"overview#Overview":"This week marks the beginning of direct interaction with the kernel.\nStudents will learn what a system call (syscall) is, how it bridges user space and kernel space, and how errors are communicated via errno.We then explore file descriptors, the foundation of Linux’s “everything is a file” philosophy, and practice with fundamental file-related system calls: creat, open, read, write, and close.","key-concepts#Key Concepts":"System Calls\nRole of syscalls in OS design\nUser mode vs. kernel mode\nInterrupts, traps, and context switching\nsyscall interface vs. library wrappers (glibc)\nError Handling\nReturn values (-1 convention)\nerrno global variable\nUsing perror() and strerror()\nFile Descriptors\nConcept of file descriptors (integers representing open files)\nStandard descriptors: stdin (0), stdout (1), stderr (2)\n“Everything is a file” in Unix: devices, pipes, sockets\nEssential File System Calls\ncreat(), open(), read(), write(), close()\nFlags: O_RDONLY, O_WRONLY, O_RDWR, O_CREAT, O_APPEND, etc.\nPermissions and the umask effect\nDifferences between system calls and stdio (fopen, fread, etc.)","practice--lab#Practice / Lab":"Syscall Tracing\nUse strace ls to observe syscalls in action\nIdentify open, read, write, close in the trace\nError Handling\nWrite a C program to open a non-existent file, print error with perror\nFile I/O Basics\nWrite a program that:\nCreates a file with creat()\nWrites a string to it with write()\nReads it back with read() and prints to stdout\nCloses the file descriptor","homework#Homework":"FS-1: Read from the file\nFS-2: Copy a file\nFS-3: Secure file deletion","references--resources#References & Resources":"Required\nThe Linux Programming Interface – Kerrisk, Ch. 4–5: System Calls & File I/O\nFile Descriptor (Wiki)\nHandling a File by its Descriptor in C\nOS5 - File Descriptors, File Descriptor Table\nOptional\nBeej’s Guide to Unix IPC (intro chapters)\nLinux Syscalls Table\nLinux manual page - open(2)\nLinux manual page - creat(3p)\nLinux manual page - read(2)\nLinux manual page - write(2)\nLinux manual page - close(2)\nLinux manual page - fcntl(2)\nLinux manual page - errno(3)\nerrno – C library\nReading and Writing Files in C, two ways (fopen vs. open)\nTools\nstrace, errno, perror, man","quiz-self-check#Quiz (Self-check)":"What distinguishes a system call from a regular library function?\nWhich system calls are involved when reading a file from disk?\nWhat values are reserved for stdin, stdout, and stderr file descriptors?\nHow does errno get set, and how should you properly print its meaning?\nWhat is the difference between open and creat?"}},"/system-programming/topics/classical-sync-problems":{"title":"Classical Synchronization Problems","data":{"overview#Overview":"This week focuses on applying synchronization primitives to solve classical concurrency problems that appear in operating systems, parallel systems, and real-world software design.\nThrough hands-on examples, students will learn how mutexes, semaphores, and condition variables can coordinate multiple threads or processes to prevent race conditions and ensure correct execution order.","key-concepts#Key Concepts":"Purpose of Classical Problems\nServe as canonical models for understanding synchronization mechanisms.\nHelp develop reasoning about shared resources, fairness, and avoidance of deadlock or starvation.","producerconsumer-bounded-buffer#Producer–Consumer (Bounded Buffer)":"Scenario: Producers generate data and place it in a buffer; consumers remove and process it.\nChallenge: Prevent buffer overflow (too many producers) and underflow (too many consumers).\nSolution: Use semaphores or condition variables to control buffer state.\nDemonstrates: resource counting, mutual exclusion, condition signaling.","readerswriters-problem#Readers–Writers Problem":"Scenario: Multiple readers can access shared data simultaneously, but writers require exclusive access.\nChallenge: Avoid conflicts between readers and writers.\nSolution: Use reader/writer counters, semaphores, or RW locks.\nDemonstrates: fairness, reader/writer preference, starvation prevention.","dining-philosophers-problem#Dining Philosophers Problem":"Scenario: Philosophers seated around a table alternate between thinking and eating, each needing two forks.\nChallenge: Prevent deadlock (everyone waiting) and starvation (someone never eating).\nSolution: Control fork acquisition order or use semaphores for resource allocation.\nDemonstrates: deadlock prevention, resource hierarchy, symmetry breaking.","sleeping-barber-problem#Sleeping Barber Problem":"Scenario: A barber sleeps when no customers are waiting; customers wait if the barber is busy.\nChallenge: Synchronize waiting customers and barber’s state transitions.\nSolution: Semaphores for managing waiting chairs and signaling events.\nDemonstrates: event signaling, resource utilization, thread coordination.","references#References":"Operating Systems: Three Easy Pieces — Chapters “Synchronization Examples” and “Semaphores”\nModern Operating Systems — Andrew S. Tanenbaum, Chapter on “Processes and Threads”\nProgramming with POSIX Threads — David R. Butenhof, examples on coordination\npthreads(7)\nsem_overview(7)\nSynchronization problems overview (Wikipedia)","quiz-self-check#Quiz (Self-Check)":"What causes deadlock in the Dining Philosophers problem?\nHow can starvation occur in the Readers–Writers problem?\nWhich synchronization primitives can be used to solve the Producer–Consumer problem?\nIn the Sleeping Barber problem, what does each semaphore represent?\nWhy is fairness important in synchronization design?\nHow does symmetry breaking help in preventing deadlocks?"}},"/system-programming/topics/compilation":{"title":"The Compilation Process","data":{"overview#Overview":"This week introduces the compilation pipeline that turns source code into an executable program.\nStarting with a simple Hello World in C/C++, we’ll explore each step: preprocessing, compiling, assembling, and linking. Students will gain hands-on experience using gcc or g++ at each stage and learn how Makefiles automate the build process.By the end of this week, you should be able to manually trace the build process, understand the role of each stage, and create a simple Makefile for structured project builds.","key-concepts#Key Concepts":"Source code lifecycle: from .c or .cpp to executable binary\nStages of the compilation pipeline:\nPreprocessing (cpp): handling #include, #define, macros, conditional compilation\nCompilation: converting preprocessed code into assembly\nAssembling: turning assembly into object files (.o)\nLinking: combining object files and libraries into an executable\nUsing gcc or g++ to invoke each stage individually\nUnderstanding object files and executables with file, nm, objdump\nStatic vs. dynamic linking basics\nBuild automation: Makefiles, rules, targets, dependencies\nOther useful tools: make, pkg-config, ldd","practice--lab#Practice / Lab":"Hello World Compilation Steps:\nRun gcc -E hello.c -o hello.i (preprocessor)\nRun gcc -S hello.i -o hello.s (compiler → assembly)\nRun gcc -c hello.s -o hello.o (assembler → object file)\nRun gcc hello.o -o hello (linker → executable)\nExploring Artifacts:\nInspect .i, .s, .o and executable with less and file\nUse nm hello.o to list symbols\nUse objdump -d hello.o to view assembly\nMakefile Basics:\nWrite a simple Makefile with targets: all, clean\nPractice make, make clean, dependency tracking\nLinking Check:\nUse ldd hello to see linked libraries\nCompare static vs dynamic builds (gcc -static)","homework#Homework":"ENV-2: Complex numbers and sorting","guides#Guides":"Compilation and build process","references--resources#References & Resources":"Required\nGNU Compiler Collection (GCC) Documentation\nMake Manual (GNU Make)\nIntroduction to the Compilation Process (GeeksforGeeks)\nECE 252 Lecture 1: Our C Toolkit\nUnderstanding C and C++ compilation process\nC++: препроцессор, компилятор, компоновщик (RUS)\nThe C++ compilation model\nMemory Layout of C Program\nOptional\nThe Linux Programming Interface (Kerrisk) – Chapter 4: Program Execution\nLearn Makefiles by Example (GNU)\nobjdump, nm, and ldd Usage Guide (Tutorialspoint)\nCompiling with g++\nC Programming: Makefiles\nBegineer Makefile tutorial\nMakefile tutorial\n9 Essential GNU binutils tools\nCMake Tutorial EP 1 | Understanding The Basics\nTools\ngcc, cpp, as, ld\nmake, pkg-config, ldd, objdump, nm","quiz-self-check#Quiz (Self-check)":"What is the role of the preprocessor in compilation?\nWhat file extension is typically produced by the assembler?\nHow does static linking differ from dynamic linking?\nWhich tool is used to inspect the symbols inside an object file?\nWhy are Makefiles useful in larger projects?"}},"/system-programming/topics/processes":{"title":"Processes","data":{"overview#Overview":"This week introduces the process model — the fundamental abstraction for executing programs in an operating system.\nStudents will learn how processes are created, how they relate to one another, and how Linux represents and manages them.\nWe will also briefly explore virtual memory and its role in isolating processes, followed by the main system calls for creating and controlling processes.By the end of this week, students will understand how programs become running processes, how parent and child processes interact, and how process management underpins multitasking in Linux.","key-concepts#Key Concepts":"","what-is-a-process#What is a Process?":"A process as an executing program instance\nProcess attributes: PID, state, program counter, registers, open files\nProcess lifecycle: creation → execution → termination\nRelationship between programs and processes\nContext switching overview","virtual-memory-brief-overview#Virtual Memory (Brief Overview)":"Concept of process isolation\nLogical vs physical address spaces\nPaging: mapping memory in fixed-size blocks (pages)\nRole of MMU and page tables (at a high level)\nHow virtual memory supports multitasking and protection","process-hierarchy-and-inheritance#Process Hierarchy and Inheritance":"The process tree: init/systemd as ancestor of all processes\nParent and child relationships\nInheritance of environment variables and file descriptors\nProcess groups and sessions","process-creation-and-execution#Process Creation and Execution":"fork() — duplicating the current process\nReturn semantics of fork() (0 in child, PID in parent)\nexec() family — replacing the current process image\ngetpid(), getppid() — identifying process lineage\nwait() and waitpid() — synchronizing process termination\nZombies and orphan processes","practice--lab#Practice / Lab":"","exploring-the-process-tree#Exploring the Process Tree":"Use shell tools (ps, pstree, top, htop) to inspect running processes.\nIdentify parent-child relationships and PIDs.\nObserve behavior when starting background jobs (&) and pipelines.","process-creation#Process Creation":"Write a simple program that spawns child processes using fork().\nObserve execution order and differences in PID and PPID.","executing-new-programs#Executing New Programs":"Use exec() to replace a process image and observe that it does not return.\nCombine fork() and exec() to launch external commands from your program.","process-synchronization#Process Synchronization":"Use wait() and waitpid() to ensure orderly termination of child processes.\nObserve zombie processes when a parent does not wait.","homework#Homework":"PS-1: Do command\nPS-2: Interactive shell","samples#Samples":"Creating a process","references--resources#References & Resources":"Required\nECE 252 Lecture 4: Processes\nECE 252 Lecture 5: Processes in UNIX\nThe Exec Family of Functions\nThe fork function in C\nWaiting for processes to finish in C\nKerrisk, The Linux Programming Interface\nChapter 24: Process Creation\nChapter 25: Process Termination\nChapter 26: Executing Programs\nRecommended\nLinux manual page - fork(2)\nLinux manual page - wait(2)\nLinux manual page - clone(2)\nLinux manual page - exec(3)\nExample of fork() in C\nFork System Call in Operating System\nLinux Processes and Threads (IBM Developer)\nUnderstanding fork() and exec() (GeeksforGeeks)\nThe Process Tree (Red Hat Docs)","quiz-self-check#Quiz (Self-check)":"What is the difference between a program and a process?\nWhat does virtual memory achieve in process isolation?\nWhat are the main differences between fork() and exec()?\nWhat is inherited by a child process after fork()?\nWhat happens if a parent process never calls wait()?\nWhat is a zombie process, and how is it removed?\nHow do getpid() and getppid() relate within a process tree?","suggested-tools#Suggested Tools":"ps, pstree, top, htop – inspect running processes\nstrace – trace fork, exec, wait system calls\npmap – display memory map of a process\nlsof – list open files for a given process"}},"/system-programming/topics/intro":{"title":"Introduction to Unix and Linux","data":{"overview#Overview":"In this first week, we establish the foundation for system programming. Students will explore what an operating system is, how kernels are structured, and how Linux fits into the broader family of operating systems. We also introduce GNU/Linux distributions, the concept of free and open-source software, and the shell as the main interface to the system.By the end of this week, students will have a working Linux environment, a basic understanding of the command line, and an introduction to version control with Git and GitHub.","key-concepts#Key Concepts":"What is an operating system? Roles and responsibilities\nKernel vs. user space; system calls as the bridge\nKernel architectures: monolithic, microkernel, hybrid\nUnix lineage and Linux history (vs. Windows, macOS, BSD)\nGNU/Linux ecosystem: distributions and package managers\nThe shell: prompt, commands, redirection, and pipelines","practice--lab#Practice / Lab":"Set up a Virtual Machine: Install Ubuntu (or another Linux distribution) on VirtualBox/VMware.\nCommand Line Basics:\nRun and understand ls, cd, pwd, man, echo, cat\nTry redirection (>, >>) and pipelines (|)\nInstall software with apt or your distro’s package manager\nDevelopment Environment Setup: Install and test gcc, g++, make, and git. Configure an editor (e.g., VS Code or Vim).\nGit & GitHub Essentials: Initialize a local repo, make a commit, and push to GitHub.\nExploring Distributions: Find your kernel version (uname -a) and distro info (lsb_release -a). Compare Ubuntu, Fedora, Arch, Debian.","homework#Homework":"Complete task: ENV-1: Setup GNU/Linux Environment","references--resources#References & Resources":"Required\nOperating Systems (Wikipedia)\nKernel (Wikipedia)\nGNU/Linux Distributions\nOptional / Enrichment\nWhat is Kernel (Video)\nMicrokernel vs Monolithic Kernel (Video)\nLinux Distribution Timeline (Diagram)\nЭволюция вычислительных систем (RUS)\nTools\nDownload VirtualBox\nDownload Ubuntu\nInstall Ubuntu in VirtualBox (Video)\nGit and GitHub Basics (Video)","quiz-self-check#Quiz (Self-check)":"What is the difference between the kernel and user space?\nName two major differences between Linux and Windows.\nWhich shell command is used to find your current directory?\nWhat is the purpose of a package manager in Linux?"}},"/system-programming/topics/synchronization":{"title":"Synchronization and Critical Sections","data":{"overview#Overview":"This week explores one of the most important challenges in multithreaded programming — synchronization.\nStudents will understand how race conditions arise when multiple threads access shared data concurrently, and how to control access to critical sections using synchronization primitives such as mutexes, spinlocks, semaphores, condition variables, and atomic operations.","key-concepts#Key Concepts":"","concurrency-and-race-conditions#Concurrency and Race Conditions":"Race condition: when multiple threads access and modify shared data simultaneously, leading to unpredictable results.\nCritical section: a segment of code that must not be executed by more than one thread at a time.\nData consistency: maintaining integrity of shared resources under concurrent access.","synchronization-primitives#Synchronization Primitives":"Mutex (Mutual Exclusion Lock):\nEnsures only one thread executes a critical section at a time.\nCore functions: pthread_mutex_init, pthread_mutex_lock, pthread_mutex_unlock, pthread_mutex_destroy.\nSpinlock:\nLightweight lock that continuously checks availability without sleeping.\nSuitable for short critical sections on multicore systems.\nSemaphore:\nA counter-based synchronization mechanism for controlling access to a finite number of resources.\nPOSIX functions: sem_init, sem_wait, sem_post, sem_destroy.\nCondition Variable:\nUsed for signaling between threads.\nAllows a thread to wait until a certain condition becomes true.\nCore functions: pthread_cond_wait, pthread_cond_signal, pthread_cond_broadcast.\nAtomic Operations and CAS (Compare-And-Swap):\nLow-level operations ensuring atomic updates without explicit locks.\nFoundation for lock-free synchronization structures.","deadlocks-and-starvation-intro#Deadlocks and Starvation (Intro)":"Circular wait, hold and wait, no preemption, mutual exclusion — the four conditions for deadlock.\nTechniques to avoid or detect deadlocks will be discussed in future weeks.","practice#Practice":"","demonstrating-race-conditions#Demonstrating Race Conditions":"Create a shared counter updated by multiple threads without locks — observe inconsistent results.\nProtect the counter using a mutex and verify correct output.","working-with-mutexes#Working with Mutexes":"Use a mutex to protect a critical section in a multi-threaded program.\nExperiment with pthread_mutex_trylock and PTHREAD_MUTEX_RECURSIVE.","using-semaphores#Using Semaphores":"Implement a simple producer-consumer synchronization using semaphores.","condition-variables#Condition Variables":"Demonstrate thread signaling (one thread waits until another signals a condition).\nCompare busy-waiting vs. condition-based waiting.","spinlocks-and-atomics#Spinlocks and Atomics":"Experiment with short critical sections using spinlocks.\nObserve CPU utilization differences compared to mutexes.","homework#Homework":"TH-2: The thread pool implementation","references#References":"Required\nECE 252 Lecture 12: Concurrency: Synchronization & Atomicity\nECE 252 Lecture 13: Semaphores\nECE 252 Lecture 14: Synchronization Patterns\nПараллельное программирование. Лекция 2 Лекция\nMutex vs Semaphore\nSpinlocks - Part 1 - A Basic Spinlock \nCompare-and-swap\nAdvanced Programming in the UNIX Environment — W. Richard Stevens, Chapter 12 “Thread Synchronization”\nProgramming with POSIX Threads — David R. Butenhof, Chapters 4–6\nOperating Systems: Three Easy Pieces — Chapters “Concurrency,” “Locks,” and “Condition Variables”\nRecommended\nECE 252 Lecture 16: The Readers-Writers Problem\nECE 252 Lecture 17: Deadlock\nECE 252 Lecture 18: Deadlock Avoidance\nECE 252 Lecture 19: Deadlock Detection and Recovery\nMutex lock for Linux Thread Synchronization\nHow to use Semaphores in POSIX Concurrency Control\nLinux manual page - pthread_mutex_init(3p)\nLinux manual page - pthread_mutex_destroy(3p)\nLinux manual page - pthread_mutex_lock(3p)\nLinux manual page - pthread_mutex_unlock(3p)\nLinux manual page - spin_lock(3)\nLinux manual page - spin_unlock(3)\nLinux manual page - sem_init(3)\nLinux manual page - sem_destroy(3p)\nLinux manual page - sem_wait(3)\nLinux manual page - sem_post(3)\nLinux manual page - pthread_cond_wait(3)\nLinux manual page - pthread_cond_signal(3)","quiz-self-check#Quiz (Self-Check)":"What causes a race condition?\nWhat is the difference between a mutex and a spinlock?\nHow does a semaphore differ from a mutex?\nWhat are the typical use cases for condition variables?\nWhat does “atomic operation” mean?\nName the four necessary conditions for a deadlock.\nWhy is it important to minimize the time spent inside a critical section?"}},"/system-programming/topics/threads":{"title":"Multithreading and POSIX Threads","data":{"overview#Overview":"This week introduces threads as lightweight units of execution within a process.\nStudents will learn how threads differ from processes, how they share resources, and how to use the POSIX Threads (pthreads) API to create, synchronize, and manage them effectively in Linux.","key-concepts#Key Concepts":"Threads vs. Processes\nA process has its own memory space; threads share the same address space.\nThreads enable concurrent execution within a single process.\nThreads are more efficient for parallel tasks that share data.\nPOSIX Threads (pthreads)\nStandardized API for thread programming in UNIX/Linux environments.\nMain functions:\npthread_create() — create a new thread\npthread_join() — wait for a thread to complete\npthread_exit() — terminate the current thread\npthread_self() — obtain the thread ID\npthread_detach() — run thread independently (no join)\nThread Lifecycle\nStates: new → runnable → running → terminated\nResource management: stack, thread ID, attributes\nDetached vs. joinable threads and their memory implications\nThread Safety\nShared memory requires careful access to avoid conflicts (to be covered later).\nDistinguish between thread-safe and non-thread-safe library functions.","practice#Practice":"","thread-creation#Thread Creation":"Write a simple program that spawns multiple threads using pthread_create().\nPass arguments to threads and print thread identifiers with pthread_self().","joining-and-detaching#Joining and Detaching":"Use pthread_join() to synchronize thread completion.\nCreate detached threads using pthread_detach() and observe behavior.","thread-attributes#Thread Attributes":"Experiment with pthread_attr_t to set stack size or detach state.\nObserve resource usage differences using tools like htop (Shift + H).","observation#Observation":"Compare thread vs. process creation times using time and simple benchmarks.","homework#Homework":"TH-1: The array summary","samples#Samples":"Creating a thread","references#References":"Required\nFunction Pointer in C\nECE 252 Lecture 10: Threads\nECE 252 Lecture 11: Threads and Concurrency\nПараллельное программирование. Лекция 1 (RUS)\nIntroduction to Pthreads\nAdvanced Programming in the UNIX Environment — W. Richard Stevens, Chapter 11 “Threads”\nProgramming with POSIX Threads — David R. Butenhof\nOperating Systems: Three Easy Pieces — Chapter on “Concurrency and Threads”\nThe Open Group — POSIX Threads Specification\nRecommended\nLinux manual page - pthread_create(3)\nLinux manual page - pthread_join(3)\nLinux manual page - pthread_exit(3)\nLinux manual page - pthread_cancel(3)\nLinux manual page - pthread_attr_init(3)\nLinux manual page - pthread_attr_destroy(3)\nMultithreading in C\nThread functions in C/C++","quiz-self-check#Quiz (Self-Check)":"What is the key difference between a process and a thread?\nWhich function is used to create a new thread in POSIX?\nWhat happens if a joinable thread finishes without being joined?\nWhat is the purpose of pthread_detach()?\nWhy do threads share the same memory space, and what are the implications of this?\nWhat information does pthread_self() return?"}},"/system-programming/topics/unix-fs":{"title":"Unix Filesystem Basics","data":{"overview#Overview":"Building on the introductory tour of Linux, this week deepens your understanding of the command-line interface and the structure of the Unix filesystem.\nYou will learn how to use shell commands effectively, explore standard directories and their purposes, understand file types (regular files, directories, devices, links), and manage users, groups, and permissions.By the end of this week you should be able to confidently navigate the filesystem, interpret file metadata, and control access rights using the shell.","key-concepts#Key Concepts":"The shell as an interface: command syntax, arguments, options\nCommand synopsis and using man pages\nStandard Linux directory hierarchy (/bin, /etc, /home, /var, /proc, /dev, …)\nFile types: regular, directory, character/block devices, sockets, FIFOs\nHard links vs. symbolic (soft) links\nUsers, groups, and ownership model\nFile permissions: read/write/execute, chmod, chown, chgrp","practice--lab#Practice / Lab":"Shell Exploration:\nUse man, which, type to discover command info\nPractice navigation with cd, pwd, ls -l, tree\nFilesystem Walk:\nInspect the top-level folders under /\nExplore /proc and /dev for virtual and device files\nWorking with Links:\nCreate hard and symbolic links (ln, ln -s) and examine inode numbers with ls -i\nPermissions Management:\nCheck file metadata with ls -l\nChange mode and ownership (chmod, chown, chgrp)\nExperiment with umask and default file permissions\nUsers & Groups:\nInspect /etc/passwd and /etc/group\nUse id, who, groups to view account information","references--resources#References & Resources":"Required\nFilesystem Hierarchy Standard (FHS)\nLinux File Types (The Linux Documentation Project)\nGNU Coreutils Manual\nThe Unix File System\nECE 252 Lecture 3: The File System\nThe Unix File System (GeeksForGeeks)\nLinux File System Explained\nLinux File Permissions Explained\nFile Permissions\nLinux для Начинающих - Права Доступа и владения файлами и директориями (RUS)\nOptional / Enrichment\nLinux Journey: The Shell\nLinux Journey: Filesystem\nPermissions Explained (DigitalOcean)\nLinux Commands Part Two: Working With Files\n60 Linux Commands to Know\nBasic Linux Commands\nTools\nls, cd, pwd, man, file, stat, tree\nln, chmod, chown, groups, id","quiz-self-check#Quiz (Self-check)":"What is the difference between a hard link and a symbolic link?\nWhich directory holds configuration files for most system services?\nWhat do the three sets of characters in rwxr-xr-- represent?\nHow can you find the manual page for a command?\nWhich virtual directory contains information about running processes?"}}}